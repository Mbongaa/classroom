Directory structure:
└── mbongaa-dashboard-mosque-/
    ├── components.json
    ├── DEPLOY_USER_CREATION_FIX.md
    ├── eslint.config.js
    ├── index.html
    ├── package.json
    ├── postcss.config.js
    ├── QUICK_DEPLOY.md
    ├── tailwind.config.ts
    ├── test-public-speeches.html
    ├── tsconfig.app.json
    ├── tsconfig.json
    ├── tsconfig.node.json
    ├── vercel.json
    ├── vite.config.ts
    ├── docs/
    │   ├── BILLING_IMPLEMENTATION_PLAN.md
    │   ├── ENABLE_AUTOMATIC_BILLING_SAVE.md
    │   ├── MULTI_TENANT_FIX.md
    │   └── SETUP_MONTHLY_BILLING_CRON.md
    ├── public/
    │   ├── manifest.json
    │   ├── robots.txt
    │   └── service-worker.js
    ├── src/
    │   ├── App.css
    │   ├── App.tsx
    │   ├── index.css
    │   ├── main.tsx
    │   ├── vite-env.d.ts
    │   ├── app/
    │   │   └── globals.css
    │   ├── components/
    │   │   ├── BroadcastChannelMonitor.tsx
    │   │   ├── ConversationAuthRoute.tsx
    │   │   ├── ErrorBoundary.tsx
    │   │   ├── HostControlFooterV3.tsx
    │   │   ├── ImpersonationBanner.tsx
    │   │   ├── ProtectedRoute.tsx
    │   │   ├── RealtimeConnectionMonitor.tsx
    │   │   ├── SupabaseChannelMonitor.tsx
    │   │   ├── layout/
    │   │   │   ├── GlobalHeader.tsx
    │   │   │   ├── SidebarNav.module.css
    │   │   │   └── SidebarNav.tsx
    │   │   ├── shared/
    │   │   │   ├── ConfirmDialog.tsx
    │   │   │   ├── DataTable.tsx
    │   │   │   ├── EmptyState.tsx
    │   │   │   ├── FormDrawer.tsx
    │   │   │   └── PageHeader.tsx
    │   │   └── ui/
    │   │       ├── alert-dialog.tsx
    │   │       ├── alert.tsx
    │   │       ├── avatar.tsx
    │   │       ├── badge.tsx
    │   │       ├── button.tsx
    │   │       ├── card.tsx
    │   │       ├── checkbox.tsx
    │   │       ├── command.tsx
    │   │       ├── dialog.tsx
    │   │       ├── dropdown-menu.tsx
    │   │       ├── empty-state.tsx
    │   │       ├── form.tsx
    │   │       ├── input.tsx
    │   │       ├── label.tsx
    │   │       ├── language-select-simple.tsx
    │   │       ├── language-selector-inline.tsx
    │   │       ├── language-selector.tsx
    │   │       ├── language-toggle.tsx
    │   │       ├── loading-skeleton.tsx
    │   │       ├── native-language-select.tsx
    │   │       ├── pagination.tsx
    │   │       ├── popover.tsx
    │   │       ├── progress.tsx
    │   │       ├── scroll-area.tsx
    │   │       ├── secure-toggle.tsx
    │   │       ├── select.tsx
    │   │       ├── separator.tsx
    │   │       ├── sheet.tsx
    │   │       ├── skeleton.tsx
    │   │       ├── slider.tsx
    │   │       ├── sonner.tsx
    │   │       ├── styled-headers.tsx
    │   │       ├── switch.tsx
    │   │       ├── table.tsx
    │   │       ├── tabs.tsx
    │   │       ├── textarea.tsx
    │   │       ├── theme-toggle.tsx
    │   │       ├── toast.tsx
    │   │       ├── toaster.tsx
    │   │       ├── toggle.tsx
    │   │       ├── tooltip.tsx
    │   │       └── use-toast.ts
    │   ├── config/
    │   │   ├── languages.ts
    │   │   └── navigation.ts
    │   ├── contexts/
    │   │   ├── LanguageContext.tsx
    │   │   └── VisibilityContext.tsx
    │   ├── features/
    │   │   ├── auth/
    │   │   │   ├── components/
    │   │   │   │   ├── UserCreationDialog.tsx
    │   │   │   │   └── UserMosqueAssignment.tsx
    │   │   │   ├── pages/
    │   │   │   │   └── AuthPage.tsx
    │   │   │   └── services/
    │   │   │       └── adminUserService.ts
    │   │   ├── conversation/
    │   │   │   ├── components/
    │   │   │   │   ├── BaseConversationView.tsx
    │   │   │   │   ├── ConversationDisconnectButton.tsx
    │   │   │   │   ├── ConversationHeader.tsx
    │   │   │   │   ├── ConversationLiveMonitor.tsx
    │   │   │   │   ├── ConversationMediaDeviceMenu.tsx
    │   │   │   │   ├── ConversationMicToggle.tsx
    │   │   │   │   ├── ConversationParticipantInfo.tsx
    │   │   │   │   ├── ConversationPushToTalkToggle.tsx
    │   │   │   │   ├── ConversationRoomSelector.tsx
    │   │   │   │   ├── ConversationSyncedMicToggle.tsx
    │   │   │   │   ├── ConversationUnifiedMicToggle.tsx
    │   │   │   │   ├── controls/
    │   │   │   │   │   ├── ConversationControlBar.tsx
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── display/
    │   │   │   │   │   ├── ConversationDisplay.tsx
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── SpeakerOverlay.tsx
    │   │   │   │   │   ├── TranscriptionView.tsx
    │   │   │   │   │   └── TranslationCards.tsx
    │   │   │   │   └── footer/
    │   │   │   │       ├── ConnectedControls.tsx
    │   │   │   │       ├── ConversationFooter.tsx
    │   │   │   │       ├── DisconnectedControls.tsx
    │   │   │   │       └── index.ts
    │   │   │   ├── hooks/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── useConversationCoordinator.ts
    │   │   │   │   ├── useConversationSession.ts
    │   │   │   │   ├── useConversationState.ts
    │   │   │   │   ├── useLiveKitConnection.ts
    │   │   │   │   ├── usePushToTalk.ts
    │   │   │   │   ├── useSecondaryWindowModifications.ts
    │   │   │   │   └── useWindowCoordination.ts
    │   │   │   ├── services/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── livekitManager.ts
    │   │   │   │   ├── pushToTalkService.ts
    │   │   │   │   ├── sessionManager.ts
    │   │   │   │   └── windowCoordinator.ts
    │   │   │   ├── types/
    │   │   │   │   ├── conversation.types.ts
    │   │   │   │   └── index.ts
    │   │   │   └── utils/
    │   │   │       └── conversationTheme.ts
    │   │   ├── dashboard/
    │   │   │   ├── components/
    │   │   │   │   ├── EditRoomForm.tsx
    │   │   │   │   ├── EditRoomFormInline.tsx
    │   │   │   │   ├── EmptyMonitorState.tsx
    │   │   │   │   ├── RoomForm.tsx
    │   │   │   │   ├── RoomsGrid.tsx
    │   │   │   │   └── StatsHeader.tsx
    │   │   │   ├── hooks/
    │   │   │   │   ├── useCrossMosqueData.ts
    │   │   │   │   ├── useMosqueData.ts
    │   │   │   │   ├── usePromptTemplates.ts
    │   │   │   │   ├── useRoomManagement.ts
    │   │   │   │   └── useSuperAdminStats.ts
    │   │   │   └── pages/
    │   │   │       ├── Billing.tsx
    │   │   │       ├── Mosques.tsx
    │   │   │       ├── Overview.tsx
    │   │   │       ├── Prompts.tsx
    │   │   │       ├── Rooms.tsx
    │   │   │       ├── Sessions.tsx
    │   │   │       ├── Settings.tsx
    │   │   │       └── Users.tsx
    │   │   ├── display/
    │   │   │   ├── components/
    │   │   │   │   ├── KioskToggle.tsx
    │   │   │   │   ├── PrayerTimesDisplay.tsx
    │   │   │   │   ├── QuranDisplayView.tsx
    │   │   │   │   ├── TypewriterView.tsx
    │   │   │   │   └── VideoStream.tsx
    │   │   │   ├── pages/
    │   │   │   │   ├── DisplayPage.tsx
    │   │   │   │   └── PublicDisplayPage.tsx
    │   │   │   └── utils/
    │   │   │       ├── TranslationCommaBuffer.test.ts
    │   │   │       └── TranslationCommaBuffer.ts
    │   │   ├── livekit/
    │   │   │   ├── components/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── BroadcastReceiver.tsx
    │   │   │   │   ├── EnhancedMediaDeviceMenu.tsx
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── LiveKitCleanupHandler.tsx
    │   │   │   │   ├── LiveMonitor.tsx
    │   │   │   │   ├── StyledDisconnectButton.tsx
    │   │   │   │   ├── StyledHostControls.tsx
    │   │   │   │   ├── StyledMediaDeviceMenu.tsx
    │   │   │   │   ├── StyledMicToggle.tsx
    │   │   │   │   ├── StyledParticipantInfo.tsx
    │   │   │   │   └── StyledTrackToggle.tsx
    │   │   │   └── hooks/
    │   │   │       ├── useRoomConnection.ts
    │   │   │       ├── useRoomSession.ts
    │   │   │       └── useTranscriptManager.ts
    │   │   ├── mosque/
    │   │   │   └── components/
    │   │   │       ├── MosqueAdminDashboard.tsx
    │   │   │       ├── MosqueCreationWizard.tsx
    │   │   │       ├── MosqueUsersTable.tsx
    │   │   │       ├── PromptTemplateManager.tsx
    │   │   │       └── RoomCodeManager.tsx
    │   │   └── session/
    │   │       ├── components/
    │   │       │   ├── SessionHistory.tsx
    │   │       │   └── SessionReplay.tsx
    │   │       └── pages/
    │   │           ├── HistoryPage.tsx
    │   │           └── SessionReplayPage.tsx
    │   ├── hooks/
    │   │   ├── use-mobile.tsx
    │   │   ├── use-toast.ts
    │   │   ├── useAuth.ts
    │   │   ├── useBroadcastChannel.ts
    │   │   ├── useImpersonation.ts
    │   │   ├── useManagedSubscription.ts
    │   │   ├── useRoomStatusMonitor.ts
    │   │   ├── useRoomStatusValidation.ts
    │   │   ├── useSessionCleanup.ts
    │   │   ├── useSupabaseSubscription.ts
    │   │   ├── useTranslation.ts
    │   │   └── data/
    │   │       ├── useMosques.ts
    │   │       └── useUsers.ts
    │   ├── integrations/
    │   │   └── supabase/
    │   │       └── client.ts
    │   ├── lib/
    │   │   ├── broadcastChannelManager.ts
    │   │   ├── supabase.ts
    │   │   ├── supabaseConnectionManager.ts
    │   │   ├── supabaseMonitoring.ts
    │   │   ├── utils.ts
    │   │   ├── __tests__/
    │   │   │   └── broadcastChannelManager.test.ts
    │   │   └── translations/
    │   │       ├── ar.ts
    │   │       ├── en.ts
    │   │       ├── index.ts
    │   │       ├── nl.ts
    │   │       ├── types.ts
    │   │       └── utils.ts
    │   ├── pages/
    │   │   ├── Dashboard.tsx
    │   │   ├── Index.tsx
    │   │   ├── NotFound.tsx
    │   │   ├── PublicSpeechDetail.tsx
    │   │   ├── PublicSpeechList.tsx
    │   │   ├── TestLanguageSelector.tsx
    │   │   └── dashboard/
    │   │       ├── ConversationMonitor.tsx
    │   │       ├── ConversationPage.tsx
    │   │       └── RemoteControlPage.tsx
    │   └── utils/
    │       ├── constants.ts
    │       ├── livekitAdmin.ts
    │       ├── roomHelpers.ts
    │       ├── sessionCleanupCoordinator.ts
    │       ├── sessionCleanupEnhanced.ts
    │       └── textAnimator.ts
    ├── supabase/
    │   ├── config.toml
    │   ├── functions/
    │   │   ├── admin-create-user/
    │   │   │   └── index.ts
    │   │   ├── cleanup-session/
    │   │   │   └── index.ts
    │   │   └── monthly-billing/
    │   │       └── index.ts
    │   └── migrations/
    │       ├── 20241201_create_billing_packages.sql
    │       ├── 20241201_package_with_slug_reference.sql
    │       ├── 20241201_simple_package_column.sql
    │       ├── 20241201_simplified_billing.sql
    │       ├── 20241202_add_monthly_billing_snapshot.sql
    │       ├── 20241202_simple_monthly_billing_save.sql
    │       ├── 20250114_add_unique_constraint_active_sessions.sql
    │       ├── 20250114_create_cleanup_room_sessions_function.sql
    │       ├── 20250116_fix_cleanup_parameter_mismatch.sql
    │       ├── 20250116_fix_cleanup_parameter_mismatch_simple.sql
    │       ├── 20250117180000_fix_prompt_template_structure.sql
    │       ├── 20250117_dashboard_improvements.sql
    │       ├── 20250117_fix_get_room_prompt_template.sql
    │       ├── 20250117_populate_existing_users.sql
    │       ├── 20250117_stale_session_cleanup.sql
    │       ├── 20250123_idempotent_session_cleanup.sql
    │       ├── 20250127_add_context_window_size.sql
    │       ├── 20250128_add_sentence_context_to_transcripts.sql
    │       ├── 20250128_add_speechmatics_domain.sql
    │       ├── 20250128_drop_problematic_functions.sql
    │       ├── 20250128_enhance_mosque_creation.sql
    │       ├── 20250128_fix_ghost_sessions_comprehensive.sql
    │       ├── 20250128_fix_missing_recover_function.sql
    │       ├── 20250128_fix_mosque_creation_auth.sql
    │       ├── 20250708125950-9e497f88-90a2-46df-8fcf-cfb602ac1cc3.sql
    │       ├── 20250708130005-a14acede-103a-41f8-9915-f84a88babc68.sql
    │       ├── 20250708131447-ce0d4a7b-fa8b-494d-a6db-6c62c72e953d.sql
    │       ├── 20250708134608-b3615715-3506-4afb-93ea-1c1ba90e6328.sql
    │       ├── 20250708134922-409329d5-49bc-4f0c-810d-82cbc902bdc9.sql
    │       ├── 20250708135316-391410a6-033f-4cbb-8165-c3b440dc42c1.sql
    │       ├── 20250708152919-9be4e1ee-de59-463c-9b8c-768ffaf424be.sql
    │       ├── 20250708152930-fece161e-d1ee-4cee-9646-e4371e9659ed.sql
    │       ├── 20250708181803-d97e37a7-261d-4a97-ab20-d6fbc7029393.sql
    │       ├── 20250708181824-7eb671f8-2a55-4902-ae29-ab74a8b5c8f8.sql
    │       ├── 20250708185851-6625a012-2382-4a52-bf16-60a891fa7caa.sql
    │       ├── 20250708221001-7d05fc81-515b-41a2-ab0e-3c3836222bc0.sql
    │       ├── 20250708230934-71965874-767d-4725-bc60-922460594589.sql
    │       ├── 20250708232117-9d12b530-45f3-4b69-a433-889a53b3b0a7.sql
    │       ├── 20250708232134-ffbb9436-e93c-4568-ab5a-b57961f87c7b.sql
    │       ├── 20250708232823-38e72a73-8ea5-4c73-a782-ac14bb3cf7cb.sql
    │       ├── 20250708232840-db9a4d28-31f1-4155-bbb0-6b71a6c105c5.sql
    │       ├── 20250709201903-3091bbce-3135-4e9d-90ae-0c488532b14f.sql
    │       ├── 20250709202002-8fc88d3c-d3c6-4239-ac70-3491882ece09.sql
    │       ├── 20250710135726-c3cfd2d1-0d02-4262-80cd-19af94a5a1cd.sql
    │       ├── 20250712173118-0ced2e36-e590-4d6a-b4bd-db29fdb50083.sql
    │       ├── 20250712234109-09a527ea-d212-4a10-97f3-3479c2bb79da.sql
    │       ├── 20250712234933-e5cc0a1d-bc19-4f26-bda5-e55417a08dc9.sql
    │       ├── 20250712234948-77412074-9a42-43a4-b5fa-6dca121b0b30.sql
    │       ├── 20250713192711-dd33874d-f818-425a-b721-d3f1add4988c.sql
    │       ├── 20250714002744-168522ee-003d-4436-9c7a-d74399c48efe.sql
    │       ├── 20250714002817-9230e1ef-b561-4c4a-9a18-6deae7211947.sql
    │       ├── 20250714134701-b2cbea28-c52b-401f-a7e8-024402d20e9a.sql
    │       ├── 20250714134715-38c3e185-5799-484c-a196-697fc6c2938d.sql
    │       ├── 20250714134724-65b7ebeb-b1c6-41a8-9769-24ba41b88174.sql
    │       ├── 20250714134736-13926ada-5092-4b36-9a7c-5fb266a3b118.sql
    │       ├── 20250714135020-a8c95995-d0e6-443d-bee2-8d53ee0c7b60.sql
    │       ├── 20250714155147-bc472851-529f-48cd-8f77-bc4d0bf161df.sql
    │       ├── 20250715014448-9fbe9f78-f7e5-4013-8a64-b402953f8cac.sql
    │       ├── 20250715023131-698d1daa-dd77-4d24-85a7-ab917259a2f9.sql
    │       ├── 20250715221309-b8da9b25-00e3-4f27-a57b-d97fd8cbb2b7.sql
    │       ├── 20250715_prompt_templates.sql
    │       ├── 20250717012925-a63b093a-9263-448d-b26b-e1b3ddfb035f.sql
    │       ├── 20250717012951-51d4f895-5f99-48c1-b5a3-dd6b88a81ff4.sql
    │       ├── 20250717013106-985d0313-93be-4edc-8414-30457903c82c.sql
    │       ├── 20250717165115-859344f0-b44d-492e-8323-a3632dc48d22.sql
    │       ├── 20250726022146-62c50d2b-b695-4bd4-9954-2af2aa3a1356.sql
    │       ├── 20250726022354-6f18ecc8-651a-4f10-bb10-cd1aaf771121.sql
    │       ├── 20250726022502-40dbb33a-66df-497b-9252-255e16f5402a.sql
    │       ├── 20250727194131_drop_room_templates.sql
    │       ├── 20250728014102-75638be8-37f1-4fb4-a844-9f1414f7774b.sql
    │       ├── 20250728020751-d62533bd-95f2-4972-bf5b-031f6c44ec6a.sql
    │       ├── 20250808_add_public_sessions_rls.sql
    │       ├── 20250808_add_public_title.sql
    │       ├── 20250810_add_super_admin_access_policies.sql
    │       ├── 20250810_fix_create_auth_user.sql
    │       ├── 20250810_fix_user_mosque_association.sql
    │       ├── 20250811_add_sentence_count_to_sessions.sql
    │       ├── 20250811_fix_public_sessions_rls.sql
    │       ├── 20250812_fix_get_room_by_code.sql
    │       ├── 20250812_fix_get_room_by_code_v2.sql
    │       └── 20250812_restore_public_access_enabled.sql
    └── .claude/
        └── settings.local.json

================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}


================================================
FILE: DEPLOY_USER_CREATION_FIX.md
================================================
# User Creation Fix - Deployment Instructions

## Overview
This fix enables proper user creation that creates both Supabase Auth users and database profiles simultaneously.

## What Was Fixed
1. **Created Edge Function** (`admin-create-user`) that:
   - Creates Supabase Auth user with Admin API
   - Automatically triggers profile creation
   - Ensures proper mosque assignment
   - Validates super admin permissions

2. **Updated Frontend** to:
   - Include password field in user creation dialog
   - Call Edge Function instead of database function
   - Show success when user is fully created

3. **Added Database Migration** with:
   - Enhanced `handle_new_user` trigger
   - Helper function for validation
   - Better metadata handling

## Deployment Steps

### Step 1: Deploy the Edge Function
```bash
cd "Frontend/Dashboard (Mosque Solution)"

# Deploy the Edge Function
supabase functions deploy admin-create-user

# Verify deployment
supabase functions list
```

### Step 2: Set Service Role Key (if not already set)
```bash
# Get your service role key from Supabase dashboard
# Settings -> API -> Service Role Key

# Set it as a secret
supabase secrets set SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here
```

### Step 3: Run the Database Migration
```bash
# Apply the migration
supabase db push

# Or manually run in SQL Editor:
# Copy contents of: supabase/migrations/20250810_fix_create_auth_user.sql
```

### Step 4: Test the Function
```bash
# Test with curl (replace with your project URL and anon key)
curl -X POST 'https://bpsahvbdlkzemwjdgxmq.supabase.co/functions/v1/admin-create-user' \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN' \
  -H 'Content-Type: application/json' \
  -H 'apikey: YOUR_ANON_KEY' \
  -d '{
    "email": "test@example.com",
    "password": "Test123!",
    "full_name": "Test User",
    "mosque_id": 546012,
    "role": "User"
  }'
```

## How It Works Now

1. **Super Admin creates user** in Users page
2. **Frontend calls** Edge Function with email, password, name, mosque_id
3. **Edge Function**:
   - Validates super admin permissions
   - Creates Auth user with Supabase Admin API
   - Auth user gets metadata (mosque_id, role, full_name)
4. **Database trigger** (`handle_new_user`) automatically:
   - Creates user profile in `public.users` table
   - Sets mosque assignment from metadata
5. **User can immediately log in** with credentials

## Verification

### Check if working:
1. Go to Users page as super admin
2. Click "Add User" button
3. Fill in: Email, Name, Password, Mosque, Role
4. Click Create
5. Check Supabase Dashboard:
   - Authentication tab: User should appear
   - Table Editor > users: Profile should exist
6. Try logging in as the new user

### Troubleshooting

If user creation fails:

1. **Check Edge Function logs**:
   ```bash
   supabase functions logs admin-create-user
   ```

2. **Verify Service Role Key**:
   - Must be set in Function Secrets
   - Get from: Supabase Dashboard > Settings > API

3. **Check permissions**:
   - Current user must be super_admin or mosque admin
   - Check in SQL: `SELECT * FROM users WHERE id = auth.uid()`

4. **Test database function**:
   ```sql
   SELECT check_edge_function_status();
   ```

## Security Notes

- Only super admins and mosque admins can create users
- Mosque admins can only create users for their own mosque
- Passwords are handled securely through Edge Function
- Email is auto-confirmed for immediate login
- Service Role Key is never exposed to frontend

## Success Indicators

✅ User appears in Authentication tab
✅ User profile exists in users table
✅ User can log in immediately
✅ Mosque assignment is correct
✅ Role is properly set


================================================
FILE: eslint.config.js
================================================
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "@typescript-eslint/no-unused-vars": "off",
    },
  }
);



================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bayaan - Mosque Solution Dashboard</title>
    <meta name="description" content="bayaan Platform - Real-time Translation and Mosque Management Solution" />
    <meta name="author" content="bayaan" />

    <meta property="og:title" content="bayaan - Mosque Solution Dashboard" />
    <meta property="og:description" content="bayaan Platform - Real-time Translation and Mosque Management Solution" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
    
    <!-- Noto Sans Arabic Font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@300;400;500;600;700&display=swap" />
    
    <!-- Poppins Font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" />
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Theme color for browser chrome -->
    <meta name="theme-color" content="#1a202c">
    
    <!-- Apple touch icon (optional but recommended) -->
    <link rel="apple-touch-icon" href="/icon-192.png">
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    
    <!-- Service Worker Registration -->
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then(reg => console.log('Service Worker registered'))
            .catch(err => console.log('Service Worker registration failed'));
        });
      }
    </script>
  </body>
</html>



================================================
FILE: package.json
================================================
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview",
    "vercel-build": "node node_modules/vite/bin/vite.js build"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.1.1",
    "@livekit/components-react": "^2.9.13",
    "@livekit/components-styles": "^1.1.6",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@supabase/supabase-js": "^2.50.3",
    "@tanstack/react-query": "^5.56.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.3.0",
    "framer-motion": "^12.23.3",
    "input-otp": "^1.2.4",
    "livekit-client": "^2.15.2",
    "livekit-server-sdk": "^2.13.1",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.60.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}



================================================
FILE: postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: QUICK_DEPLOY.md
================================================
# Quick Deploy Instructions

## Deploy Updated Edge Function

Since you can't use the Supabase CLI locally, deploy the Edge Function using the Supabase Dashboard:

### Option 1: Supabase Dashboard (Easiest)

1. Go to your Supabase Dashboard: https://supabase.com/dashboard/project/bpsahvbdlkzemwjdgxmq
2. Navigate to **Edge Functions** in the sidebar
3. Find `admin-create-user` function
4. Click **Edit** or **Deploy**
5. Copy the entire content from: `supabase/functions/admin-create-user/index.ts`
6. Paste and deploy

### Option 2: Using GitHub Actions (If connected)

If your repo is connected to Supabase:
1. Commit the changes
2. Push to your repository
3. Supabase will auto-deploy

### Option 3: Manual API Deploy

Use this curl command to check function status:
```bash
curl https://bpsahvbdlkzemwjdgxmq.supabase.co/functions/v1/admin-create-user \
  -H "Authorization: Bearer YOUR_ANON_KEY" \
  --head
```

## Check Edge Function Logs

To see what's happening:
1. Go to Supabase Dashboard
2. Navigate to **Edge Functions** → **Logs**
3. Look for `admin-create-user` function logs
4. Check for any error messages

## Test User Creation

After deploying:
1. Log in as super admin
2. Go to Users page
3. Click "Add User"
4. Fill in all fields including password
5. Submit

The user should:
- Appear in Authentication tab
- Have a profile in users table
- Be able to log in immediately

## Current Status

✅ Edge Function code updated with proper authorization
✅ Frontend updated to include password field
✅ Database migration ready

⚠️ Edge Function needs to be redeployed with the new code


================================================
FILE: tailwind.config.ts
================================================
import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			fontFamily: {
				sans: ['Poppins', 'system-ui', 'sans-serif'],
				'noto-arabic': ['Noto Sans Arabic', 'system-ui', 'sans-serif'],
				'poppins': ['Poppins', 'system-ui', 'sans-serif'],
			},
			keyframes: {
				'fade-in': {
					'0%': {
						opacity: '0',
						transform: 'translateY(10px)'
					},
					'100%': {
						opacity: '1',
						transform: 'translateY(0)'
					}
				},
				'scale-in': {
					'0%': {
						transform: 'scale(0.95)',
						opacity: '0'
					},
					'100%': {
						transform: 'scale(1)',
						opacity: '1'
					}
				},
				'slide-up': {
					'0%': {
						transform: 'translateY(20px)',
						opacity: '0'
					},
					'100%': {
						transform: 'translateY(0)',
						opacity: '1'
					}
				}
			},
			animation: {
				'fade-in': 'fade-in 0.3s ease-out',
				'scale-in': 'scale-in 0.2s ease-out',
				'slide-up': 'slide-up 0.3s ease-out',
				'card-enter': 'fade-in 0.3s ease-out'
			},
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				auth: {
					background: 'hsl(var(--auth-background))',
					card: 'hsl(var(--auth-card))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				},
				success: {
					DEFAULT: 'hsl(var(--success))',
					foreground: 'hsl(var(--success-foreground))'
				},
				warning: {
					DEFAULT: 'hsl(var(--warning))',
					foreground: 'hsl(var(--warning-foreground))'
				},
				error: {
					DEFAULT: 'hsl(var(--error))',
					foreground: 'hsl(var(--error-foreground))'
				},
				info: {
					DEFAULT: 'hsl(var(--info))',
					foreground: 'hsl(var(--info-foreground))'
				},
				tab: {
					active: {
						DEFAULT: 'hsl(var(--tab-active-bg))',
						foreground: 'hsl(var(--tab-active-fg))'
					}
				}
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;



================================================
FILE: test-public-speeches.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Public Speeches</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <h1>Testing Public Speeches Access</h1>
    <div id="status">Loading...</div>
    <div id="results"></div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = 'https://puvlcvhprwkmgfejfhzl.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB1dmxjdmhwcndrbWdmZWpmaHpsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzY2MDYxMTMsImV4cCI6MjA1MjE4MjExM30.qAhMhtQUqPCyAR1AztT0y3W6Y5LXlD9n4h5VOcGWP6Y';
        
        const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

        async function testPublicAccess() {
            const statusEl = document.getElementById('status');
            const resultsEl = document.getElementById('results');
            
            try {
                // Test 1: Try to fetch public sessions as anonymous user
                statusEl.innerHTML = '<h2>Test 1: Fetching public sessions (anonymous)</h2>';
                
                const { data: sessions, error: sessionsError } = await supabase
                    .from('room_sessions')
                    .select(`
                        *,
                        rooms (
                            Title,
                            transcription_language,
                            translation__language
                        ),
                        Mosque (
                            name
                        )
                    `)
                    .eq('is_public', true)
                    .eq('status', 'completed');

                if (sessionsError) {
                    resultsEl.innerHTML += `
                        <div style="color: red;">
                            <h3>❌ Failed to fetch public sessions</h3>
                            <p>Error: ${sessionsError.message}</p>
                            <p>Details: ${JSON.stringify(sessionsError, null, 2)}</p>
                        </div>
                    `;
                } else {
                    resultsEl.innerHTML += `
                        <div style="color: green;">
                            <h3>✅ Successfully fetched public sessions</h3>
                            <p>Found ${sessions?.length || 0} public sessions</p>
                            <pre>${JSON.stringify(sessions, null, 2)}</pre>
                        </div>
                    `;
                }

                // Test 2: Try direct query without joins
                statusEl.innerHTML += '<h2>Test 2: Direct query without joins</h2>';
                
                const { data: directSessions, error: directError } = await supabase
                    .from('room_sessions')
                    .select('*')
                    .eq('is_public', true)
                    .eq('status', 'completed');

                if (directError) {
                    resultsEl.innerHTML += `
                        <div style="color: red;">
                            <h3>❌ Failed direct query</h3>
                            <p>Error: ${directError.message}</p>
                        </div>
                    `;
                } else {
                    resultsEl.innerHTML += `
                        <div style="color: green;">
                            <h3>✅ Direct query successful</h3>
                            <p>Found ${directSessions?.length || 0} sessions</p>
                        </div>
                    `;
                }

                // Test 3: Check current user status
                statusEl.innerHTML += '<h2>Test 3: Checking authentication status</h2>';
                
                const { data: { user }, error: userError } = await supabase.auth.getUser();
                
                resultsEl.innerHTML += `
                    <div style="color: blue;">
                        <h3>🔍 Current User Status</h3>
                        <p>User: ${user ? `Logged in as ${user.email}` : 'Anonymous (not logged in)'}</p>
                    </div>
                `;

            } catch (err) {
                resultsEl.innerHTML += `
                    <div style="color: red;">
                        <h3>❌ Unexpected error</h3>
                        <p>${err.message}</p>
                    </div>
                `;
            }
            
            statusEl.innerHTML = '<h2>Tests Complete</h2>';
        }

        // Run tests when page loads
        testPublicAccess();
    </script>
</body>
</html>


================================================
FILE: tsconfig.app.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}



================================================
FILE: tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}



================================================
FILE: tsconfig.node.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: vercel.json
================================================
{
  "installCommand": "rm -rf node_modules && npm install",
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "framework": null,
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}


================================================
FILE: vite.config.ts
================================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' &&
    componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));



================================================
FILE: docs/BILLING_IMPLEMENTATION_PLAN.md
================================================
# 📋 Billing & Package Management Implementation Plan

## Overview
Implementation of a database-driven billing system with assignable packages for mosques, replacing the current hardcoded pricing tiers.

## 🗄️ Phase 1: Database Infrastructure (Day 1)

### Tables Created:
1. **billing_packages** - Define available subscription tiers
2. **mosque_subscriptions** - Assign packages to mosques
3. **billing_history** - Track monthly billing records
4. **usage_alerts** - Monitor usage thresholds

### Key Features:
- ✅ Flexible package definitions
- ✅ Custom pricing overrides per mosque
- ✅ RLS policies for security
- ✅ Helper functions for billing calculations

### Migration Status:
- [x] Migration file created: `20241201_create_billing_packages.sql`
- [ ] Run migration: `npx supabase db push`
- [ ] Verify tables in Supabase dashboard

## 📊 Phase 2: Update Billing Page (Day 1-2)

### Tasks:
1. **Fetch Dynamic Package Data**
   ```typescript
   // Replace hardcoded PRICING_TIERS with:
   const { data: subscription } = await supabase
     .from('mosque_subscriptions')
     .select(`
       *,
       package:billing_packages(*)
     `)
     .eq('mosque_id', mosque.id)
     .single();
   ```

2. **Update Billing Calculations**
   - Use `subscription.package` data instead of hardcoded tiers
   - Handle custom overrides (custom_price, custom_hours, custom_overage_rate)
   - Default to Starter package if no subscription exists

3. **Display Package Information**
   - Show actual assigned package
   - Display custom pricing if applicable
   - Show subscription status and billing cycle

## 🎛️ Phase 3: Package Management UI (Day 2-3)

### Super Admin Features:

#### Package Management Page (`/dashboard/packages`)
```typescript
// Component: src/features/dashboard/pages/PackageManagement.tsx
```
- View all packages
- Create new packages
- Edit existing packages
- Toggle active/inactive status
- Set features and limits

#### Mosque Subscription Management (`/dashboard/subscriptions`)
```typescript
// Component: src/features/dashboard/pages/SubscriptionManagement.tsx
```
- View all mosque subscriptions
- Assign packages to mosques
- Set custom pricing overrides
- Change subscription status
- View billing history

### Implementation:
1. Create new route in navigation
2. Build CRUD interface for packages
3. Build assignment interface for subscriptions
4. Add to super admin menu only

## 📈 Phase 4: Billing History & Invoicing (Day 3-4)

### Monthly Billing Job
```sql
-- Scheduled function to generate monthly billing records
CREATE OR REPLACE FUNCTION generate_monthly_billing()
RETURNS void AS $$
DECLARE
  v_mosque RECORD;
  v_billing RECORD;
BEGIN
  FOR v_mosque IN 
    SELECT DISTINCT m.id, m.name 
    FROM Mosque m
    JOIN mosque_subscriptions ms ON m.id = ms.mosque_id
    WHERE ms.status = 'active'
  LOOP
    SELECT * INTO v_billing FROM calculate_mosque_billing(
      v_mosque.id,
      date_trunc('month', CURRENT_DATE),
      date_trunc('month', CURRENT_DATE) + interval '1 month' - interval '1 day'
    );
    
    INSERT INTO billing_history (
      mosque_id,
      period_start,
      period_end,
      used_hours,
      overage_hours,
      base_price,
      overage_cost,
      total_cost
    ) VALUES (
      v_mosque.id,
      date_trunc('month', CURRENT_DATE),
      date_trunc('month', CURRENT_DATE) + interval '1 month' - interval '1 day',
      v_billing.total_hours,
      v_billing.overage_hours,
      v_billing.base_cost,
      v_billing.overage_cost,
      v_billing.total_cost
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### Invoice Generation
- Generate PDF invoices from billing_history
- Email notifications
- Payment tracking

## 🔔 Phase 5: Usage Alerts (Day 4-5)

### Alert Triggers:
1. **50% Usage** - Informational
2. **75% Usage** - Warning
3. **90% Usage** - Critical
4. **100% Exceeded** - Overage notification

### Implementation:
```typescript
// Check usage and create alerts
const checkUsageAlerts = async (mosqueId: number) => {
  const usage = await calculateCurrentUsage(mosqueId);
  const subscription = await getMosqueSubscription(mosqueId);
  
  const percentage = (usage.hours / subscription.included_hours) * 100;
  
  if (percentage >= 90 && !await hasAlert(mosqueId, '90%')) {
    await createAlert(mosqueId, '90%', usage.hours, subscription.included_hours);
    await sendEmailNotification(mosqueId, 'usage-critical');
  }
  // ... other thresholds
};
```

## 🚀 Phase 6: Migration & Deployment (Day 5-6)

### Data Migration:
1. **Assign Default Packages**
   ```sql
   -- Assign all existing mosques to Professional tier by default
   INSERT INTO mosque_subscriptions (mosque_id, package_id, status)
   SELECT 
     m.id,
     (SELECT id FROM billing_packages WHERE slug = 'professional'),
     'active'
   FROM Mosque m
   WHERE NOT EXISTS (
     SELECT 1 FROM mosque_subscriptions ms 
     WHERE ms.mosque_id = m.id
   );
   ```

2. **Historical Data**
   - Optionally import historical usage into billing_history
   - Set current_period_start for all subscriptions

### Testing Checklist:
- [ ] Package CRUD operations
- [ ] Subscription assignment
- [ ] Billing calculations match Excel export
- [ ] Custom pricing overrides work
- [ ] RLS policies enforce security
- [ ] Usage alerts trigger correctly
- [ ] Billing history generates monthly

## 📁 File Structure

```
src/features/
├── billing/
│   ├── components/
│   │   ├── PackageCard.tsx
│   │   ├── SubscriptionForm.tsx
│   │   └── BillingHistoryTable.tsx
│   ├── hooks/
│   │   ├── usePackages.ts
│   │   ├── useSubscription.ts
│   │   └── useBillingHistory.ts
│   └── services/
│       ├── packageService.ts
│       ├── subscriptionService.ts
│       └── billingService.ts
└── dashboard/pages/
    ├── Billing.tsx (updated)
    ├── PackageManagement.tsx (new)
    └── SubscriptionManagement.tsx (new)
```

## 🎯 Benefits

1. **Flexibility**: Easy to add new packages or modify existing ones
2. **Custom Pricing**: Per-mosque pricing overrides for enterprise clients
3. **Audit Trail**: Complete billing history for compliance
4. **Automation**: Monthly billing generation and alerts
5. **Scalability**: Database-driven system scales with growth
6. **Analytics**: Track usage patterns and revenue metrics

## 📊 Monitoring & Analytics

### Key Metrics:
- Average usage per package tier
- Overage frequency by mosque
- Revenue per package type
- Churn rate by tier
- Usage growth trends

### Dashboard Queries:
```sql
-- Revenue by package
SELECT 
  bp.name,
  COUNT(ms.id) as subscribers,
  SUM(COALESCE(ms.custom_price, bp.monthly_price)) as mrr
FROM billing_packages bp
LEFT JOIN mosque_subscriptions ms ON bp.id = ms.package_id
WHERE ms.status = 'active'
GROUP BY bp.id;

-- Usage distribution
SELECT 
  bp.name,
  AVG(bh.used_hours) as avg_usage,
  AVG(bh.overage_hours) as avg_overage
FROM billing_history bh
JOIN mosque_subscriptions ms ON bh.mosque_id = ms.mosque_id
JOIN billing_packages bp ON ms.package_id = bp.id
WHERE bh.period_start >= CURRENT_DATE - interval '3 months'
GROUP BY bp.id;
```

## ⏰ Timeline

- **Day 1**: Database setup, migration
- **Day 2**: Update Billing page
- **Day 3**: Package management UI
- **Day 4**: Subscription management UI
- **Day 5**: Usage alerts, billing history
- **Day 6**: Testing, deployment

## 🔄 Next Steps

1. Review and approve migration file
2. Run migration in development
3. Update Billing.tsx to use dynamic data
4. Create management interfaces
5. Test with sample data
6. Deploy to production

## 📝 Notes

- Consider Stripe integration for payment processing
- Plan for annual billing discounts
- Design upgrade/downgrade flow
- Implement proration for mid-cycle changes
- Add webhook for payment confirmations


================================================
FILE: docs/ENABLE_AUTOMATIC_BILLING_SAVE.md
================================================
# Enable Automatic Monthly Billing Save

## What It Does
Automatically saves the previous month's billing data on the 1st of each month at midnight.

## Setup - Just 2 Steps

### Step 1: Deploy the Migration
```bash
npx supabase db push
```

### Step 2: Enable pg_cron in Supabase
1. Go to your Supabase Dashboard
2. Navigate to Database → Extensions
3. Find `pg_cron` and enable it
4. Done! The migration already sets up the cron job

## That's It!
The system will now automatically:
- Run at midnight on the 1st of each month
- Save the previous month's billing data to `billing_history` table
- Include hours used, transcript counts, sentence counts
- Calculate overage and total costs
- Never create duplicate records (idempotent)

## Manual Test (Optional)
To test it right now:
```sql
SELECT save_previous_month_billing();
```

## View Saved History
```sql
SELECT * FROM billing_history ORDER BY period_start DESC;
```

## How It Works
- The function `save_previous_month_billing()` runs automatically via pg_cron
- It loops through all mosques
- Calculates their usage for the previous month
- Saves it to the `billing_history` table
- Skips if already saved (prevents duplicates)


================================================
FILE: docs/MULTI_TENANT_FIX.md
================================================
# Multi-Tenant System Fix Documentation

## Problem Summary

The multi-tenant system had a critical flaw where users created through Supabase Authentication dashboard couldn't be properly associated with mosques. The system was hardcoded to assign all new users to `mosque_id = 1`, resulting in users being unable to see their mosque's data.

## Solution Implemented

### 1. Database Migration (`20250810_fix_user_mosque_association.sql`)

#### Improved User Creation Trigger
- **Old behavior**: All new users were hardcoded to `mosque_id = 1`
- **New behavior**: 
  - Checks user metadata for `mosque_id` during signup
  - Falls back to the first active mosque if no metadata provided
  - Extracts additional user data from metadata (name, role, etc.)

#### New Database Functions

1. **`assign_user_to_mosque(user_id, mosque_id, role)`**
   - Allows admins to reassign users to different mosques
   - Super admins can assign to any mosque
   - Mosque admins can only assign within their mosque

2. **`create_user_with_mosque(email, name, mosque_id, role)`**
   - Creates user profile with proper mosque assignment
   - Returns instructions for creating auth user
   - Validates admin permissions

3. **`get_unassigned_users()`**
   - Lists users without mosque assignments
   - Only accessible to super admins
   - Helps identify and fix orphaned users

### 2. Frontend Components

#### UserMosqueAssignment Component
- Visual interface for managing user-mosque associations
- Shows all users with their current mosque assignments
- Allows quick reassignment via dropdown
- Filter for unassigned users only
- Role management alongside mosque assignment

#### Updated UserCreationDialog
- Now uses the `create_user_with_mosque` RPC function
- Properly associates users with selected mosque
- Better error handling and user feedback

#### Enhanced Users Page
- Added "Mosque Assignments" tab for super admins
- Integrated UserMosqueAssignment component
- Maintains existing user management features

## How to Use the Fixed System

### For Super Admins

1. **Creating New Users with Mosque Assignment**:
   ```sql
   -- In Supabase SQL Editor or via RPC
   SELECT create_user_with_mosque(
     'user@example.com',
     'John Doe',
     2, -- mosque_id for Al Fourqaan
     'User' -- or 'Admin'
   );
   ```

2. **Via Dashboard UI**:
   - Go to Users page
   - Click "Create User" button
   - Select mosque from dropdown
   - System creates profile with correct association
   - Create auth user separately in Supabase dashboard

3. **Fixing Existing Users**:
   - Go to Users → Mosque Assignments tab
   - Find users without mosque or wrong mosque
   - Use dropdown to assign correct mosque
   - Changes save automatically

4. **Bulk Assignment via SQL**:
   ```sql
   -- Assign all unassigned users to a specific mosque
   UPDATE public.users 
   SET mosque_id = 2 -- Al Fourqaan's ID
   WHERE mosque_id IS NULL;
   ```

### For Creating Users with Metadata (Programmatically)

When creating users via Supabase Auth API, include metadata:

```javascript
const { data, error } = await supabase.auth.signUp({
  email: 'user@example.com',
  password: 'password123',
  options: {
    data: {
      mosque_id: 2,        // Mosque ID
      full_name: 'John Doe',
      role: 'User',        // or 'Admin'
      is_super_admin: false
    }
  }
});
```

### For Mosque Admins

1. **View Users in Your Mosque**:
   - Dashboard automatically filters to show only your mosque's users
   - Can view but not reassign to other mosques

2. **Create Users for Your Mosque**:
   - Use Create User button
   - New users automatically assigned to your mosque
   - Can set role as User or Admin

## Troubleshooting

### User Can't See Mosque Data
1. Check user's `mosque_id` in database:
   ```sql
   SELECT id, email, mosque_id, full_name 
   FROM public.users 
   WHERE email = 'user@example.com';
   ```

2. Fix if needed:
   ```sql
   SELECT assign_user_to_mosque(
     'user-uuid-here',
     2, -- correct mosque_id
     'User'
   );
   ```

### User Created in Auth but No Profile
1. Profile should auto-create via trigger
2. If not, manually create:
   ```sql
   INSERT INTO public.users (id, email, mosque_id, "Role")
   SELECT 
     id, 
     email,
     2, -- mosque_id
     'User'
   FROM auth.users
   WHERE email = 'user@example.com';
   ```

### Finding Orphaned Users
```sql
-- Users without mosque assignment
SELECT * FROM public.users WHERE mosque_id IS NULL;

-- Users in non-existent mosques
SELECT u.* 
FROM public.users u
LEFT JOIN public."Mosque" m ON u.mosque_id = m.id
WHERE m.id IS NULL AND u.mosque_id IS NOT NULL;
```

## Migration Checklist

After applying the migration:

1. ✅ Run the migration: `supabase db push`
2. ✅ Update existing users with correct mosque_id
3. ✅ Test user creation flow
4. ✅ Verify RLS policies still work
5. ✅ Test the UI assignment interface
6. ✅ Document mosque IDs for reference

## Important Notes

- The fix is backward compatible - existing users remain unchanged
- Super admins bypass mosque restrictions
- Each user must have a mosque_id for proper data access
- Creating auth users and profiles are separate steps (by design for security)

## Mosque Reference

Common mosque IDs in your system:
- ID 1: Default/Legacy mosque (check if this exists)
- ID 2: Al Fourqaan (or similar, verify exact ID)
- Add more as needed...

To get current mosque list:
```sql
SELECT id, name, "Subdomain" 
FROM public."Mosque" 
WHERE is_active = true
ORDER BY id;
```


================================================
FILE: docs/SETUP_MONTHLY_BILLING_CRON.md
================================================
# Setting Up Monthly Billing Automation

## Overview
The billing system now includes automatic monthly snapshots that save billing data at the end of each month. This ensures historical billing records are preserved and can be used for invoicing.

## Components

### 1. Database Functions
- `generate_monthly_billing_snapshot()` - Creates billing records for all mosques
- `check_and_run_monthly_billing()` - Safely checks and runs billing (idempotent)

### 2. Edge Function
- Located at: `supabase/functions/monthly-billing`
- Runs between 1st-5th of each month
- Sends notifications to super admins

### 3. Billing History Table
- Stores monthly billing snapshots
- Includes metadata (transcript counts, sentence counts)
- Tracks payment status

## Setup Instructions

### Step 1: Deploy Database Migration
```bash
npx supabase db push
```

### Step 2: Deploy Edge Function
```bash
npx supabase functions deploy monthly-billing
```

### Step 3: Set Up Cron Job

#### Option A: Supabase Cron (Recommended)
In Supabase Dashboard → Database → Extensions, enable `pg_cron` then run:

```sql
-- Schedule monthly billing to run on the 1st of each month at 2 AM
SELECT cron.schedule(
  'monthly-billing',
  '0 2 1 * *', -- Cron expression: 2 AM on the 1st day of every month
  $$SELECT check_and_run_monthly_billing();$$
);

-- To view scheduled jobs
SELECT * FROM cron.job;

-- To remove the job if needed
SELECT cron.unschedule('monthly-billing');
```

#### Option B: External Cron Service
Use a service like:
- **Cron-job.org** (free)
- **EasyCron** 
- **GitHub Actions**

Example GitHub Action:
```yaml
name: Monthly Billing
on:
  schedule:
    - cron: '0 2 1 * *' # 2 AM on 1st of each month
  workflow_dispatch: # Allow manual trigger

jobs:
  run-billing:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Monthly Billing
        run: |
          curl -X POST https://YOUR_PROJECT.supabase.co/functions/v1/monthly-billing \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -H "Content-Type: application/json"
```

#### Option C: Vercel Cron (if using Vercel)
Add to `vercel.json`:
```json
{
  "crons": [{
    "path": "/api/trigger-billing",
    "schedule": "0 2 1 * *"
  }]
}
```

### Step 4: Manual Testing
To test the billing snapshot manually:

```sql
-- Run this in Supabase SQL editor
SELECT check_and_run_monthly_billing();

-- Or trigger the edge function
curl -X POST https://YOUR_PROJECT.supabase.co/functions/v1/monthly-billing \
  -H "Authorization: Bearer YOUR_ANON_KEY" \
  -H "Content-Type: application/json"
```

### Step 5: View Billing History
After running, check the billing history:

```sql
-- View all billing records
SELECT * FROM billing_history ORDER BY period_start DESC;

-- View billing for specific mosque
SELECT * FROM billing_history 
WHERE mosque_id = YOUR_MOSQUE_ID
ORDER BY period_start DESC;
```

## Features

### Automatic Calculations
- Total hours used per mosque
- Overage hours beyond included allowance
- Overage costs
- Total monthly cost
- Session counts
- Transcript/translation counts

### Idempotent Design
- Safe to run multiple times
- Won't create duplicate records
- Checks if billing already exists for the period

### Grace Period
- Runs between 1st-5th of month
- Allows late sessions from previous month to be included
- Prevents premature billing

## Monitoring

### Check Billing Status
```sql
-- See last billing run for each mosque
SELECT 
  m.name as mosque_name,
  bh.period_start,
  bh.period_end,
  bh.used_hours,
  bh.total_cost,
  bh.created_at
FROM billing_history bh
JOIN "Mosque" m ON m.id = bh.mosque_id
WHERE bh.period_start = date_trunc('month', CURRENT_DATE - INTERVAL '1 month')
ORDER BY bh.created_at DESC;
```

### Check for Missing Billing
```sql
-- Find mosques without billing for last month
SELECT m.* 
FROM "Mosque" m
WHERE NOT EXISTS (
  SELECT 1 FROM billing_history bh
  WHERE bh.mosque_id = m.id
  AND bh.period_start = date_trunc('month', CURRENT_DATE - INTERVAL '1 month')
);
```

## Troubleshooting

### Billing Didn't Run
1. Check if it's between 1st-5th of month
2. Verify cron job is scheduled
3. Check edge function logs in Supabase dashboard
4. Manually trigger: `SELECT check_and_run_monthly_billing();`

### Incorrect Calculations
1. Verify room_sessions data is complete
2. Check package assignments are correct
3. Review the billing calculation in the function

### Missing Data
The `metadata` field stores additional information:
```sql
SELECT 
  mosque_id,
  metadata->>'transcript_count' as transcripts,
  metadata->>'sentence_count' as sentences,
  metadata->>'session_count' as sessions
FROM billing_history
WHERE period_start = date_trunc('month', CURRENT_DATE - INTERVAL '1 month');
```


================================================
FILE: public/manifest.json
================================================
{
  "name": "bayaan Platform Admin",
  "short_name": "bayaan Admin",
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#1a202c",
  "background_color": "#ffffff",
  "description": "bayaan Platform Administration Dashboard",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}


================================================
FILE: public/robots.txt
================================================
User-agent: Googlebot
Allow: /

User-agent: Bingbot
Allow: /

User-agent: Twitterbot
Allow: /

User-agent: facebookexternalhit
Allow: /

User-agent: *
Allow: /



================================================
FILE: public/service-worker.js
================================================
// Minimal service worker for PWA installability
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Install');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activate');
  event.waitUntil(clients.claim());
});

// Network-first fetch handler with proper error handling
self.addEventListener('fetch', (event) => {
  // Only handle GET requests
  if (event.request.method !== 'GET') {
    return;
  }

  // Skip chrome-extension and other non-http(s) protocols
  if (!event.request.url.startsWith('http')) {
    return;
  }

  event.respondWith(
    fetch(event.request)
      .catch((error) => {
        console.error('[Service Worker] Fetch failed:', error);
        // Return a basic offline response if needed
        return new Response('Offline', {
          status: 503,
          statusText: 'Service Unavailable',
          headers: new Headers({
            'Content-Type': 'text/plain'
          })
        });
      })
  );
});


================================================
FILE: src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em hsl(var(--primary) / 0.67));
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em hsl(var(--primary) / 0.67));
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: hsl(var(--muted-foreground));
}



================================================
FILE: src/App.tsx
================================================
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { VisibilityProvider } from "@/contexts/VisibilityContext";
import { LanguageProvider } from "@/contexts/LanguageContext";
import { ThemeProvider } from "next-themes";
import Index from "./pages/Index";
import AuthPage from "./features/auth/pages/AuthPage";
import Dashboard from "./pages/Dashboard";
import DisplayPage from "./features/display/pages/DisplayPage";
import PublicDisplayPage from "./features/display/pages/PublicDisplayPage";
import HistoryPage from "./features/session/pages/HistoryPage";
import SessionReplayPage from "./features/session/pages/SessionReplayPage";
import NotFound from "./pages/NotFound";
import ProtectedRoute from "./components/ProtectedRoute";
import ConversationAuthRoute from "./components/ConversationAuthRoute";
import ImpersonationBanner from "./components/ImpersonationBanner";
import ErrorBoundary from "./components/ErrorBoundary";
import { BroadcastChannelMonitor } from "./components/BroadcastChannelMonitor";

// Connection logger removed to prevent interference
// import "./lib/realtimeConnectionLogger";

// Start Supabase monitoring
import "./lib/supabaseMonitoring";

// Dashboard sub-pages
import Overview from "./features/dashboard/pages/Overview";
import Mosques from "./features/dashboard/pages/Mosques";
import Users from "./features/dashboard/pages/Users";
import Rooms from "./features/dashboard/pages/Rooms";
import Sessions from "./features/dashboard/pages/Sessions";
import Prompts from "./features/dashboard/pages/Prompts";
import Billing from "./features/dashboard/pages/Billing";
import Settings from "./features/dashboard/pages/Settings";
import { ConversationPage } from "./pages/dashboard/ConversationPage";
import { RemoteControlPage } from "./pages/dashboard/RemoteControlPage";
import { ConversationMonitor } from "./pages/dashboard/ConversationMonitor";

// Public pages
import PublicSpeechList from "./pages/PublicSpeechList";
import PublicSpeechDetail from "./pages/PublicSpeechDetail";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <ThemeProvider
      attribute="class"
      defaultTheme="dark"
      enableSystem={false}
      disableTransitionOnChange={false}
    >
      <TooltipProvider>
        <LanguageProvider>
          <VisibilityProvider>
            <Toaster />
            <Sonner />
            {process.env.NODE_ENV === 'development' && <BroadcastChannelMonitor />}
            <BrowserRouter>
            <ImpersonationBanner />
            <Routes>
              <Route path="/" element={<Index />} />
              <Route path="/auth" element={<AuthPage />} />
              <Route path="/dashboard" element={
                <ProtectedRoute>
                  <ErrorBoundary>
                    <Dashboard />
                  </ErrorBoundary>
                </ProtectedRoute>
              }>
                {/* Dashboard sub-routes */}
                <Route index element={<Overview />} />
                <Route path="mosques" element={<Mosques />} />
                <Route path="users" element={<Users />} />
                <Route path="rooms" element={<Rooms />} />
                <Route path="sessions" element={<Sessions />} />
                <Route path="prompts" element={<Prompts />} />
                <Route path="conversation" element={<ConversationPage />} />
                <Route path="remote" element={<RemoteControlPage />} />
                <Route path="billing" element={<Billing />} />
                <Route path="settings" element={<Settings />} />
              </Route>
              <Route path="/dashboard/conversation/monitor" element={
                <ConversationAuthRoute>
                  <ConversationMonitor />
                </ConversationAuthRoute>
              } />
              <Route path="/display" element={<DisplayPage />} />
              <Route path="/public-display" element={<PublicDisplayPage />} />
              <Route path="/history" element={
                <ProtectedRoute>
                  <HistoryPage />
                </ProtectedRoute>
              } />
              <Route path="/session/:sessionId" element={
                <ProtectedRoute>
                  <SessionReplayPage />
                </ProtectedRoute>
              } />
              {/* Public routes - no authentication required */}
              <Route path="/public/speeches" element={<PublicSpeechList />} />
              <Route path="/public/speeches/:sessionId" element={<PublicSpeechDetail />} />
              {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
              <Route path="*" element={<NotFound />} />
            </Routes>
          </BrowserRouter>
        </VisibilityProvider>
      </LanguageProvider>
    </TooltipProvider>
    </ThemeProvider>
  </QueryClientProvider>
);

export default App;



================================================
FILE: src/index.css
================================================
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Google Fonts Poppins design system */

@layer base {
  :root {
    /* Light theme color palette */
    --background: 0 0% 100%; /* #FFFFFF */
    --foreground: 0 0% 12%; /* #1F1F1F */

    --card: 214 44% 96%; /* #F0F4F9 - Surface Container */
    --card-foreground: 0 0% 12%;

    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 12%;

    /* Primary blue from Google Fonts */
    --primary: 202 100% 23%; /* #004a75 - Updated to match tab color */
    --primary-foreground: 0 0% 100%;

    /* Secondary colors */
    --secondary: 120 3% 88%; /* #E1E3E1 - UI Elements */
    --secondary-foreground: 0 0% 12%;

    --muted: 214 44% 96%; /* Surface Container */
    --muted-foreground: 120 1% 46%; /* #747775 - Secondary text */

    /* Accent - Primary Container */
    --accent: 213 100% 91%; /* #D3E3FD */
    --accent-foreground: 214 82% 43%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 100%;

    /* 
     * To change the border color, modify the HSL values below.
     * HSL stands for Hue, Saturation, and Lightness.
     * Hue (0-360): The color itself (e.g., 0 is red, 120 is green, 240 is blue).
     * Saturation (0%-100%): The intensity of the color.
     * Lightness (0%-100%): The brightness of the color.
     */
    --border: 214 20% 80%; /* Softer blue-gray border */
    --input: 214 15% 92%; /* Lighter input background */
    --ring: 202 100% 23%; /* #004a75 - Primary blue */

    --radius: 0.5rem;

    --sidebar-background: 0 0% 100%;
    --sidebar-foreground: 0 0% 12%;
    --sidebar-primary: 202 100% 23%; /* #004a75 */
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 213 100% 91%;
    --sidebar-accent-foreground: 214 82% 43%;
    --sidebar-border: 120 3% 88%;
    --sidebar-ring: 202 100% 23%; /* #004a75 */

    /* Semantic colors for status indicators */
    --success: 142 71% 45%; /* #22C55E - Green */
    --success-foreground: 0 0% 100%;
    --warning: 38 92% 50%; /* #F59E0B - Yellow/Amber */
    --warning-foreground: 0 0% 100%;
    --error: 0 84% 60%; /* #EF4444 - Red */
    --error-foreground: 0 0% 100%;
    --info: 199 89% 48%; /* #0EA5E9 - Sky Blue */
    --info-foreground: 0 0% 100%;

    /* Display gradients */
    --gradient-light-start: 157 100% 97%; /* from-emerald-50 */
    --gradient-light-middle: 0 0% 100%; /* via-white */
    --gradient-light-end: 214 100% 97%; /* to-blue-50 */
    --gradient-dark-start: 222 47% 11%; /* from-slate-900 */
    --gradient-dark-middle: 217 33% 17%; /* via-slate-800 */
    --gradient-dark-end: 222 47% 11%; /* to-slate-900 */

    /* Tab colors from Google */
    --tab-active-bg: 202 100% 23%; /* #004a77 */
    --tab-active-fg: 200 100% 75%; /* #7fcfff */
  }

  .dark {
    /* Dark theme color palette */
    --background: 0 0% 12%; /* #1F1F1F */
    --foreground: 0 0% 89%; /* #E3E3E3 */
    --card: 0 0% 11.4%; /* #1d1d1d - Custom dark header/navbar */
    --card-foreground: 0 0% 89%;
    --popover: 0 0% 12%;
    --popover-foreground: 0 0% 89%;
    --primary: 200 100% 75%; /* #7fcfff - Lighter version of #004a75 for dark mode */
    --primary-foreground: 0 0% 12%;
    --secondary: 120 2% 27%; /* #444746 - UI Elements */
    --secondary-foreground: 0 0% 89%;
    --muted: 0 0% 12%; /* Surface Container */
    --muted-foreground: 120 2% 56%; /* #8E918F - Secondary text */
    --accent: 217 100% 31%; /* #0842A0 - Primary Container */
    --accent-foreground: 213 100% 82%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 89%;
    /*
     * To change the border color and transparency, modify the HSLA values below.
     * The first three values are HSL (Hue, Saturation, Lightness).
     * The fourth value is Alpha (0-1), which controls transparency.
     * 0 is fully transparent, 1 is fully opaque.
     */
    --border: 214 15% 35%; /* Softer blue-gray border for dark mode */
    --input: 214 10% 20%; /* Darker input background */
    --ring: 200 100% 75%; /* #7fcfff - Matching primary */
    --sidebar-background: 0 0% 12%;
    --sidebar-foreground: 0 0% 89%;
    --sidebar-primary: 200 100% 75%; /* #7fcfff */
    --sidebar-primary-foreground: 0 0% 12%;
    --sidebar-accent: 217 100% 31%;
    --sidebar-accent-foreground: 200 100% 75%; /* #7fcfff */
    --sidebar-border: 120 2% 27%;
    --sidebar-ring: 200 100% 75%; /* #7fcfff */

    /* Semantic colors for status indicators - Dark mode */
    --success: 142 71% 45%; /* Keep consistent */
    --success-foreground: 0 0% 100%;
    --warning: 38 92% 50%; /* Keep consistent */
    --warning-foreground: 0 0% 12%;
    --error: 0 84% 60%; /* Keep consistent */
    --error-foreground: 0 0% 100%;
    --info: 199 89% 48%; /* Keep consistent */
    --info-foreground: 0 0% 100%;

    /* Tab colors from Google - Dark mode */
    --tab-active-bg: 202 100% 23%; /* #004a77 - Keep same for consistency */
    --tab-active-fg: 200 100% 75%; /* #7fcfff - Keep same for consistency */
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground font-sans;
    background-attachment: fixed;
  }
}

@layer utilities {
  .translation-box {
    @apply bg-card/10 backdrop-blur-sm border border-border/30 rounded-2xl;
    box-shadow: 0 8px 32px 0 hsl(var(--primary) / 0.1);
  }
  
  /* Global border opacity overrides */
  .border {
    border-color: hsl(var(--border) / 0.5);
  }
  
  .border-border\/50 {
    border-color: hsl(var(--border) / 0.5);
  }
  
  .divide-border > :not([hidden]) ~ :not([hidden]) {
    border-color: hsl(var(--border) / 0.2);
  }
  
  /* Global card and container styles */
  [class*="card"] {
    @apply border-border/50 bg-transparent transition-all duration-300;
  }
  
  /* Card hover states - only for interactive cards */
  .cursor-pointer[class*="card"]:hover,
  .group[class*="card"]:hover {
    @apply border-primary/30 shadow-lg;
  }
  
  /* Input and select styles */
  input, select, textarea, [role="combobox"] {
    @apply border-border/50 bg-background/60 backdrop-blur-sm transition-colors;
  }
  
  /* Focus states */
  input:focus, select:focus, textarea:focus, [role="combobox"]:focus-within {
    @apply border-primary/50;
  }
  
  /* Button hover transitions */
  button {
    @apply transition-all duration-200;
  }
  
  /* Main content spacing */
  main > *:first-child {
    margin-top: 0;
  }
  
  /* Table borders */
  table {
    @apply border-border/50;
  }
  
  th, td {
    @apply border-border/30;
  }
  
  /* Dialog and popover backgrounds */
  [role="dialog"], [data-radix-popper-content-wrapper] {
    @apply backdrop-blur-md;
  }
  
  /* Removed - using inline styles for better control */
  
  
  .translation-container {
    @apply border-0 rounded-2xl relative;
    font-size: clamp(1.25rem, 2.5vw, 3.25rem);
    scroll-behavior: smooth;
  }
  
  .dark .translation-container {
    @apply bg-gray-800/30;
  }

.text-fade-out-at-top {
  /* This gradient uses 'em' units to create a mask relative to font size. */
  mask-image: linear-gradient(
    to top,
    /* 1. The Safe Zone (bottom part is solid black/visible). */
    /*    Starts solid at the bottom (0) and stays solid for 3em (approx. 2 lines). */
    black 0,
    black 3em,

    /* 2. The Fade Zone. */
    /*    Fades from solid black to transparent between 3em and 4.5em from the bottom. */
    /*    This creates a fade that is about one line (1.5em) tall. */
    transparent 100%
  );

  /* Add the vendor prefix for compatibility */
  -webkit-mask-image: linear-gradient(
    to top,
    black 0,
    black 3em,
    transparent 100%
  );
}

  /* Display-specific utilities */
  .bg-gradient-display-light {
    background: linear-gradient(to bottom right, 
      hsl(var(--gradient-light-start)), 
      hsl(var(--gradient-light-middle)), 
      hsl(var(--gradient-light-end))
    );
  }

  .bg-gradient-display-dark {
    background: linear-gradient(to bottom right, 
      hsl(var(--gradient-dark-start)), 
      hsl(var(--gradient-dark-middle)), 
      hsl(var(--gradient-dark-end))
    );
  }

  .text-shadow-light {
    text-shadow: 0 0 30px hsl(var(--foreground) / 0.1);
  }

  .text-shadow-dark {
    text-shadow: 0 0 30px hsl(var(--background) / 0.3), 0 0 60px hsl(var(--background) / 0.1);
  }

  .text-shadow-emphasis-light {
    text-shadow: 0 0 40px hsl(var(--foreground) / 0.2), 0 0 80px hsl(var(--foreground) / 0.1);
  }

  .text-shadow-emphasis-dark {
    text-shadow: 0 0 40px hsl(var(--background) / 0.2), 0 0 80px hsl(var(--background) / 0.1);
  }
}

.translation-text {
  @apply text-foreground leading-relaxed;
  word-wrap: break-word;
  hyphens: auto;
  max-width: 65ch;
  margin-left: auto;
  margin-right: auto;
}

.dark .translation-text {
  @apply text-gray-100;
}
  
  .scrollbar-hide {
    /* Hide scrollbar for Chrome, Safari and Opera */
    &::-webkit-scrollbar {
      display: none;
    }
    
    /* Hide scrollbar for IE, Edge and Firefox */
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .translation-line-active {
    @apply bg-primary/5 rounded-lg px-2 py-1 transition-all duration-500 ease-out;
    box-shadow: 0 0 20px hsl(var(--primary) / 0.1);
  }
  
  .dark .translation-line-active {
    @apply bg-primary/10;
    box-shadow: 0 0 20px hsl(var(--primary) / 0.2);
  }

  /* RTL Support */
  .rtl {
    direction: rtl;
  }

  .rtl .text-right {
    text-align: left;
  }

  .rtl .text-left {
    text-align: right;
  }

  /* Arabic font improvements */
  .rtl * {
    font-family: 'Noto Sans Arabic', system-ui, sans-serif;
  }

  /* LiveKit Components Custom Styling */
  .livekit-room {
    --lk-bg: transparent !important;
    --lk-bg2: hsl(var(--card) / 0.3) !important;
    --lk-bg3: hsl(var(--card) / 0.5) !important;
    --lk-border-color: hsl(var(--border) / 0.3) !important;
    --lk-text-color: hsl(var(--foreground)) !important;
    --lk-brand-color: hsl(var(--primary)) !important;
    --lk-brand-color2: hsl(var(--primary) / 0.8) !important;
  }

  /* Override default LiveKit button styles */
  .lk-button {
    @apply transition-all duration-200 !important;
    background: hsl(var(--card) / 0.5) !important;
    backdrop-filter: blur(8px) !important;
    border: 1px solid hsl(var(--border) / 0.3) !important;
  }

  .lk-button:hover {
    background: hsl(var(--card) / 0.8) !important;
    border-color: hsl(var(--border) / 0.5) !important;
  }

  /* MediaDeviceMenu specific overrides */
  .lk-device-menu {
    background: hsl(var(--card) / 0.95) !important;
    backdrop-filter: blur(12px) !important;
    border: 1px solid hsl(var(--border) / 0.3) !important;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1) !important;
  }

  .lk-device-menu__item {
    @apply transition-colors duration-150 !important;
  }

  .lk-device-menu__item:hover {
    background: hsl(var(--accent) / 0.5) !important;
  }

  /* TrackToggle button states */
  .lk-button[data-lk-source="microphone"][data-lk-muted="false"] {
    background: hsl(var(--primary)) !important;
    color: hsl(var(--primary-foreground)) !important;
    border-color: hsl(var(--primary)) !important;
  }

  .lk-button[data-lk-source="microphone"][data-lk-muted="true"] {
    background: hsl(var(--muted) / 0.5) !important;
    color: hsl(var(--muted-foreground)) !important;
  }

  /* Disconnect button specific styling */
  .lk-disconnect-button {
    background: hsl(var(--destructive) / 0.1) !important;
    color: hsl(var(--destructive)) !important;
    border: 1px solid hsl(var(--destructive) / 0.2) !important;
  }

  .lk-disconnect-button:hover {
    background: hsl(var(--destructive) / 0.2) !important;
    border-color: hsl(var(--destructive) / 0.3) !important;
  }

  /* Typing cursor animation */
  @keyframes blink-cursor {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }

  .animate-blink {
    animation: blink-cursor 1s infinite;
  }

  /* Live activity card animations */
  @keyframes card-enter {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  .animate-card-enter {
    animation: card-enter 0.3s ease-out;
  }

  .animate-fade-in {
    animation: fade-in 0.5s ease-out;
  }

  /* Elegant pulsing animation for live status */
  @keyframes pulse-subtle {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.85;
    }
  }

  @keyframes pulse-glow {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
      opacity: 1;
    }
    50% {
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0);
      opacity: 0.9;
    }
  }

  .animate-pulse-subtle {
    animation: pulse-subtle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .animate-pulse-glow {
    animation: pulse-glow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }


================================================
FILE: src/main.tsx
================================================
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById("root")!).render(<App />);



================================================
FILE: src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: src/app/globals.css
================================================
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;

  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;

  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;

  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;

  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;

  --muted: 210 40% 96.1%;
  --muted-foreground: 215.4 16.3% 46.9%;

  --accent: 210 40% 96.1%;
  --accent-foreground: 222.2 47.4% 11.2%;

  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;

  --border: 43 7.4% 66.1%;
  --input: 214.3 31.8% 91.4%;
  --ring: 222.2 84% 4.9%;

  --radius: 0.5rem;
}

.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;

  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;

  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;

  --primary: 210 40% 98%;
  --primary-foreground: 222.2 47.4% 11.2%;

  --secondary: 217.2 32.6% 17.5%;
  --secondary-foreground: 210 40% 98%;

  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;

  --accent: 217.2 32.6% 17.5%;
  --accent-foreground: 210 40% 98%;

  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 210 40% 98%;

  --border: 43 7.4% 66.1% / 0.37;
  --input: 217.2 32.6% 17.5%;
  --ring: 212.7 26.8% 83.9%;
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================
FILE: src/components/BroadcastChannelMonitor.tsx
================================================
import { useState, useEffect } from 'react';
import { broadcastChannelManager, ConnectionState } from '@/lib/broadcastChannelManager';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { RefreshCw, Radio, Users, Clock } from 'lucide-react';
import { cn } from '@/lib/utils';

interface ChannelStats {
  totalChannels: number;
  totalListeners: number;
  channels: {
    name: string;
    listeners: number;
    state: ConnectionState;
    idleTime: number;
  }[];
}

/**
 * Development-only component to monitor broadcast channel connections
 * Provides real-time visibility into channel management
 */
export const BroadcastChannelMonitor = () => {
  const [stats, setStats] = useState<ChannelStats>({
    totalChannels: 0,
    totalListeners: 0,
    channels: []
  });
  const [isCollapsed, setIsCollapsed] = useState(true);

  // Update stats every second
  useEffect(() => {
    const updateStats = () => {
      const currentStats = broadcastChannelManager.getStats();
      setStats(currentStats);
    };

    // Initial update
    updateStats();

    // Set up interval
    const interval = setInterval(updateStats, 1000);

    return () => clearInterval(interval);
  }, []);

  // Format idle time
  const formatIdleTime = (ms: number) => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
  };

  // Get state color
  const getStateColor = (state: ConnectionState) => {
    switch (state) {
      case ConnectionState.CONNECTED:
        return 'bg-green-500';
      case ConnectionState.CONNECTING:
        return 'bg-yellow-500';
      case ConnectionState.RECONNECTING:
        return 'bg-orange-500';
      case ConnectionState.FAILED:
        return 'bg-red-500';
      case ConnectionState.DISCONNECTED:
        return 'bg-gray-500';
      default:
        return 'bg-gray-400';
    }
  };

  // Get state badge variant
  const getStateBadgeVariant = (state: ConnectionState) => {
    switch (state) {
      case ConnectionState.CONNECTED:
        return 'default';
      case ConnectionState.CONNECTING:
      case ConnectionState.RECONNECTING:
        return 'secondary';
      case ConnectionState.FAILED:
        return 'destructive';
      case ConnectionState.DISCONNECTED:
        return 'outline';
      default:
        return 'outline';
    }
  };

  // Only render in development
  if (process.env.NODE_ENV !== 'development') {
    return null;
  }

  if (isCollapsed) {
    return (
      <div className="fixed bottom-4 right-4 z-50">
        <Button
          onClick={() => setIsCollapsed(false)}
          size="sm"
          className="shadow-lg"
        >
          <Radio className="h-4 w-4 mr-2" />
          Channels ({stats.totalChannels})
        </Button>
      </div>
    );
  }

  return (
    <Card className="fixed bottom-4 right-4 w-96 max-h-[600px] z-50 shadow-xl">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <CardTitle className="text-sm font-medium flex items-center gap-2">
            <Radio className="h-4 w-4" />
            Broadcast Channel Monitor
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setIsCollapsed(true)}
            >
              Minimize
            </Button>
          </div>
        </div>
        
        <div className="flex items-center gap-4 mt-2 text-xs text-muted-foreground">
          <div className="flex items-center gap-1">
            <Radio className="h-3 w-3" />
            <span>{stats.totalChannels} channels</span>
          </div>
          <div className="flex items-center gap-1">
            <Users className="h-3 w-3" />
            <span>{stats.totalListeners} listeners</span>
          </div>
          {broadcastChannelManager.isNearLimit() && (
            <Badge variant="destructive" className="text-xs">
              Near Limit
            </Badge>
          )}
        </div>
      </CardHeader>
      
      <CardContent className="pb-3 max-h-[450px] overflow-y-auto">
        {stats.channels.length === 0 ? (
          <div className="text-center py-8 text-muted-foreground text-sm">
            No active broadcast channels
          </div>
        ) : (
          <div className="space-y-2">
            {stats.channels.map((channel) => (
              <div
                key={channel.name}
                className="border rounded-lg p-3 space-y-2 text-sm"
              >
                <div className="flex items-center justify-between">
                  <div className="font-medium text-xs truncate flex-1 mr-2">
                    {channel.name}
                  </div>
                  <Badge
                    variant={getStateBadgeVariant(channel.state)}
                    className="text-xs"
                  >
                    {channel.state}
                  </Badge>
                </div>
                
                <div className="flex items-center justify-between text-xs text-muted-foreground">
                  <div className="flex items-center gap-3">
                    <div className="flex items-center gap-1">
                      <Users className="h-3 w-3" />
                      <span>{channel.listeners} listeners</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <Clock className="h-3 w-3" />
                      <span>Idle: {formatIdleTime(channel.idleTime)}</span>
                    </div>
                  </div>
                  <div className={cn(
                    "w-2 h-2 rounded-full animate-pulse",
                    getStateColor(channel.state)
                  )} />
                </div>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
};


================================================
FILE: src/components/ConversationAuthRoute.tsx
================================================
import { ReactNode } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';
import { Loader2 } from 'lucide-react';

interface ConversationAuthRouteProps {
  children: ReactNode;
}

const ConversationAuthRoute = ({ children }: ConversationAuthRouteProps) => {
  const { user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!user) {
    // Preserve the full path including query parameters for redirect after login
    const redirectUrl = location.pathname + location.search;
    return <Navigate to={`/auth?redirect=${encodeURIComponent(redirectUrl)}`} replace />;
  }

  return <>{children}</>;
};

export default ConversationAuthRoute;


================================================
FILE: src/components/ErrorBoundary.tsx
================================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
    errorInfo: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error, errorInfo: null };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    });
  }

  private handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-[60vh] flex items-center justify-center p-4">
          <Card className="max-w-lg w-full">
            <CardHeader>
              <div className="flex items-center gap-2">
                <AlertTriangle className="h-6 w-6 text-destructive" />
                <CardTitle>Something went wrong</CardTitle>
              </div>
              <CardDescription>
                An unexpected error occurred. Please try refreshing the page.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {process.env.NODE_ENV === 'development' && this.state.error && (
                <div className="rounded-lg bg-muted p-4 text-sm font-mono">
                  <p className="font-semibold text-destructive mb-2">
                    {this.state.error.toString()}
                  </p>
                  {this.state.errorInfo && (
                    <pre className="text-xs text-muted-foreground overflow-auto">
                      {this.state.errorInfo.componentStack}
                    </pre>
                  )}
                </div>
              )}
              <div className="flex gap-2">
                <Button onClick={() => window.location.reload()} className="flex-1">
                  <RefreshCw className="mr-2 h-4 w-4" />
                  Refresh Page
                </Button>
                <Button variant="outline" onClick={this.handleReset} className="flex-1">
                  Try Again
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


================================================
FILE: src/components/HostControlFooterV3.tsx
================================================
import React, { useState, useEffect, useRef } from 'react';
import { LiveKitRoom, RoomAudioRenderer } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { cn } from '@/lib/utils';
import { Mic, Loader2, Radio, PhoneOff, AlertCircle, ChevronUp, ChevronDown } from 'lucide-react';
// Import conversation-specific components for decoupled architecture
import { ConversationMicToggle } from '@/features/conversation/components/ConversationMicToggle';
import { ConversationMediaDeviceMenu } from '@/features/conversation/components/ConversationMediaDeviceMenu';
import { ConversationDisconnectButton } from '@/features/conversation/components/ConversationDisconnectButton';
import { ConversationParticipantInfo } from '@/features/conversation/components/ConversationParticipantInfo';
import { motion, AnimatePresence } from 'framer-motion';
import { Button } from '@/components/ui/button';
import { LiveKitCleanupHandler } from '@/features/livekit/components/LiveKitCleanupHandler';

interface HostControlFooterProps {
  token: string | null;
  serverUrl: string;
  loading: boolean;
  error: string | null;
  roomName: string | null;
  roomTitle: string | null;
  onConnect: () => void;
  onDisconnect: () => void;
  isConnecting: boolean;
  sessionId?: string | null;
  roomId?: number;
}

// UI component that goes inside the LiveKitRoom
const ConnectedControls: React.FC = () => {
  const [isExpanded, setIsExpanded] = useState(true); // Default to expanded to show debug controls

  return (
    <div className="container mx-auto px-2 sm:px-4 py-3">
      <div className="flex items-center justify-between gap-2 sm:gap-4">
        {/* Left Section: Live Status (Always Visible) */}
        <div className="flex items-center gap-2 sm:gap-4">
          <motion.div
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            className="flex items-center gap-1 sm:gap-2"
          >
            <div className="relative">
              <div className="w-2 h-2 sm:w-3 sm:h-3 bg-red-500 rounded-full" />
              <div className="absolute inset-0 w-2 h-2 sm:w-3 sm:h-3 bg-red-500 rounded-full animate-ping" />
            </div>
            <span className="text-xs sm:text-sm font-bold text-red-500 uppercase">Live</span>
          </motion.div>
          
          {/* Hidden participant info */}
          <div className={cn("transition-all duration-200", isExpanded ? "opacity-100" : "opacity-0 w-0 overflow-hidden")}>
            <ConversationParticipantInfo variant="compact" />
          </div>
        </div>

        {/* Center Section: Debug Controls (Hidden/Shown) */}
        <div className="flex items-center gap-2 sm:gap-4">
          {/* Accordion Toggle */}
          <motion.button
            onClick={() => setIsExpanded(!isExpanded)}
            className="flex items-center gap-2 px-3 py-2 rounded-lg hover:bg-muted/50 transition-colors"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            <span className="text-sm text-muted-foreground">Debug Controls</span>
            {isExpanded ? (
              <ChevronDown className="w-4 h-4 text-muted-foreground" />
            ) : (
              <ChevronUp className="w-4 h-4 text-muted-foreground" />
            )}
          </motion.button>
          
          {/* Debug Controls - Always in DOM but visually hidden */}
          <div className={cn("flex items-center gap-2 sm:gap-4 transition-all duration-200", 
            isExpanded ? "opacity-100" : "opacity-0 w-0 overflow-hidden"
          )}>
            <ConversationMicToggle />
            <ConversationMediaDeviceMenu
              kind="audioinput"
              variant="compact"
              className="min-w-0 flex-1 sm:flex-initial"
            />
          </div>
        </div>

        {/* Right Section: End Button (Always Visible) */}
        <motion.div
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          className="shrink-0"
        >
          <ConversationDisconnectButton
            variant="destructive"
            icon="phone"
            customLabel="End"
            className="h-10 sm:h-12 px-3 sm:px-6 text-xs sm:text-base bg-gradient-to-r from-red-500/20 to-red-600/20 hover:from-red-500/30 hover:to-red-600/30 border-red-500/30 text-red-600 font-semibold"
          />
        </motion.div>
      </div>

      {/* Mobile: Show participant info below on small screens when expanded */}
      {isExpanded && (
        <div className="sm:hidden mt-2 pt-2 border-t border-border/30">
          <ConversationParticipantInfo variant="compact" />
        </div>
      )}
    </div>
  );
};

// Memoized LiveKit connection wrapper
const StableLiveKitConnection = React.memo<{
  token: string;
  serverUrl: string;
  onDisconnected: (reason?: any) => void;
  onConnected: () => void;
  onError: (error: any) => void;
  sessionId?: string | null;
  roomId?: number;
  children: React.ReactNode;
}>(({ token, serverUrl, onDisconnected, onConnected, onError, sessionId, roomId, children }) => {
  const renderCount = useRef(0);
  const hasConnectedRef = useRef(false);
  
  useEffect(() => {
    renderCount.current++;
    console.log(`[StableLiveKitConnection] Render #${renderCount.current}, token: ${token.substring(0, 20)}...`);
  });

  const handleConnected = () => {
    if (!hasConnectedRef.current) {
      console.log('[StableLiveKitConnection] Connected to LiveKit');
      hasConnectedRef.current = true;
      onConnected();
    }
  };

  const handleDisconnected = (reason?: any) => {
    console.log('[StableLiveKitConnection] Disconnected from LiveKit', reason);
    hasConnectedRef.current = false;
    onDisconnected(reason);
  };

  return (
    <LiveKitRoom
      video={false}
      audio={true}
      token={token}
      serverUrl={serverUrl}
      onDisconnected={handleDisconnected}
      onConnected={handleConnected}
      onError={onError}
      className="livekit-room"
      connect={true}
    >
      <RoomAudioRenderer />
      {sessionId && roomId && (
        <LiveKitCleanupHandler 
          sessionId={sessionId} 
          roomId={roomId} 
          onCleanupRequested={handleDisconnected}
        />
      )}
      {children}
    </LiveKitRoom>
  );
}, (prevProps, nextProps) => {
  // Only re-render if connection params change
  return prevProps.token === nextProps.token && 
         prevProps.serverUrl === nextProps.serverUrl &&
         prevProps.sessionId === nextProps.sessionId &&
         prevProps.roomId === nextProps.roomId;
});

StableLiveKitConnection.displayName = 'StableLiveKitConnection';

export const HostControlFooterV3: React.FC<HostControlFooterProps> = ({
  token,
  serverUrl,
  loading,
  error,
  roomName,
  roomTitle,
  onConnect,
  onDisconnect,
  isConnecting,
  sessionId,
  roomId
}) => {
  const footerVariants = {
    hidden: { y: '100%' },
    visible: { 
      y: 0,
      transition: {
        type: 'spring' as const,
        damping: 30,
        stiffness: 400,
        mass: 0.8
      }
    },
    exit: { 
      y: '100%',
      transition: {
        type: 'spring' as const,
        damping: 30,
        stiffness: 400,
        mass: 0.8
      }
    }
  };

  if (!token) {
    return (
      <motion.div
        className="fixed bottom-0 left-0 right-0 z-50"
        variants={footerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="!bg-card dark:!bg-[#181818] backdrop-blur-xl shadow-2xl">
          <div className="container mx-auto px-4 py-3">
            {/* Error Message */}
            {error && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                className="mb-3 p-3 bg-destructive/10 border border-destructive/20 rounded-md flex items-center gap-2 text-sm text-destructive"
              >
                <AlertCircle className="h-4 w-4 shrink-0" />
                {error}
              </motion.div>
            )}
            
            <div className="flex items-center justify-between gap-4">
              {/* Left Section: Status */}
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-primary/10 rounded-full flex items-center justify-center">
                  <Mic className="h-5 w-5 text-primary" />
                </div>
                <div className="hidden sm:block">
                  <p className="text-sm font-semibold">Ready to Broadcast</p>
                  <p className="text-xs text-muted-foreground">{roomTitle || 'Audio Session'}</p>
                </div>
              </div>

              {/* Center Section: Connect Button */}
              <Button
                onClick={onConnect}
                disabled={isConnecting || loading}
                size="lg"
                className="min-w-[200px] h-12 text-base font-semibold shadow-lg hover:shadow-xl transition-all"
              >
                {isConnecting || loading ? (
                  <>
                    <Loader2 className="mr-2 h-5 w-5 animate-spin" />
                    Connecting...
                  </>
                ) : (
                  <>
                    <Radio className="mr-2 h-5 w-5" />
                    Start Broadcasting
                  </>
                )}
              </Button>

              {/* Right Section: Empty for balance */}
              <div className="w-10" />
            </div>
          </div>
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className="fixed bottom-0 left-0 right-0 z-50"
      variants={footerVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="!bg-card dark:!bg-[#181818] backdrop-blur-xl shadow-2xl">
        <StableLiveKitConnection
          token={token}
          serverUrl={serverUrl}
          onDisconnected={(reason) => {
            console.log(`[HostControlFooterV3] LiveKit disconnected, reason:`, reason);
            onDisconnect();
          }}
          onConnected={() => {
            console.log(`[HostControlFooterV3] LiveKit connected successfully`);
          }}
          onError={(error) => {
            console.error(`[HostControlFooterV3] LiveKit error:`, error);
          }}
          sessionId={sessionId}
          roomId={roomId}
        >
          <ConnectedControls />
        </StableLiveKitConnection>
      </div>
    </motion.div>
  );
};


================================================
FILE: src/components/ImpersonationBanner.tsx
================================================
import { AlertTriangle, ArrowLeft } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useImpersonation } from '@/hooks/useImpersonation';
import { useAuth } from '@/hooks/useAuth';
import { useTranslation } from '@/hooks/useTranslation';

const ImpersonationBanner = () => {
  const { isImpersonating, endImpersonation } = useImpersonation();
  const { user } = useAuth();
  const { t } = useTranslation();

  if (!isImpersonating) return null;

  return (
    <div className="bg-warning/10 border-b border-warning/20 px-4 py-3">
      <div className="container mx-auto flex items-center justify-between">
        <div className="flex items-center gap-3">
          <AlertTriangle className="h-5 w-5 text-warning" />
          <div>
            <p className="text-sm font-medium text-warning-foreground">
              {t('impersonation.impersonating')} <strong>{user?.email}</strong>
            </p>
            <p className="text-xs text-muted-foreground">
              {t('impersonation.actionsAsUser')}
            </p>
          </div>
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={endImpersonation}
          className="border-warning/20 hover:bg-warning/10"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          {t('impersonation.returnToSuperAdmin')}
        </Button>
      </div>
    </div>
  );
};

export default ImpersonationBanner;


================================================
FILE: src/components/ProtectedRoute.tsx
================================================
import { ReactNode } from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';
import { Loader2 } from 'lucide-react';

interface ProtectedRouteProps {
  children: ReactNode;
}

const ProtectedRoute = ({ children }: ProtectedRouteProps) => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/auth" replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;


================================================
FILE: src/components/RealtimeConnectionMonitor.tsx
================================================
import React, { useEffect, useState } from 'react';
import { supabase } from '../integrations/supabase/client';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Alert, AlertDescription, AlertTitle } from './ui/alert';
import { RefreshCw, Wifi, WifiOff } from 'lucide-react';
import { Button } from './ui/button';
import { connectionLogger } from '../lib/realtimeConnectionLogger';

interface ConnectionInfo {
  id: string;
  type: 'auth' | 'database' | 'realtime' | 'storage';
  source: string;
  createdAt: Date;
  status: 'active' | 'idle' | 'closed';
  subscriptions?: string[];
}

export const RealtimeConnectionMonitor: React.FC = () => {
  const [connections, setConnections] = useState<ConnectionInfo[]>([]);
  const [activeChannels, setActiveChannels] = useState<number>(0);
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
  const [isMonitoring, setIsMonitoring] = useState(true);

  useEffect(() => {
    if (!isMonitoring) return;

    // Track all Supabase channels
    const trackConnections = () => {
      const channels = (supabase as any).realtime?.channels || [];
      const connectionInfo: ConnectionInfo[] = [];
      
      // Get summary from connection logger
      const loggerSummary = connectionLogger.getSummary();
      
      // Log to console for debugging
      console.log('[Connection Monitor] Active channels:', channels.length);
      console.log('[Connection Monitor] Logger Summary:', loggerSummary);
      console.log('[Connection Monitor] Channel details:', channels);
      
      channels.forEach((channel: any, index: number) => {
        const info: ConnectionInfo = {
          id: `channel-${index}`,
          type: 'realtime',
          source: channel.topic || 'unknown',
          createdAt: new Date(),
          status: channel.state === 'joined' ? 'active' : 'idle',
          subscriptions: channel.bindings?.map((b: any) => b.event) || []
        };
        connectionInfo.push(info);
        
        // Log individual channel info
        console.log(`[Channel ${index}]:`, {
          topic: channel.topic,
          state: channel.state,
          bindings: channel.bindings?.length || 0,
          presence: channel.presence?.state || 'none'
        });
      });
      
      setConnections(connectionInfo);
      setActiveChannels(channels.length);
      setLastUpdated(new Date());
      
      // Also log to local storage for persistence
      localStorage.setItem('realtime-connections-log', JSON.stringify({
        timestamp: new Date().toISOString(),
        connectionCount: channels.length,
        connections: connectionInfo,
        loggerSummary: loggerSummary
      }));
    };

    // Initial tracking
    trackConnections();
    
    // Track connections every 5 seconds
    const interval = setInterval(trackConnections, 5000);
    
    return () => {
      clearInterval(interval);
    };
  }, [isMonitoring]);

  const refreshConnections = () => {
    setLastUpdated(new Date());
    // Force re-render
    setIsMonitoring(false);
    setTimeout(() => setIsMonitoring(true), 100);
  };

  const getPotentialIssues = () => {
    const issues = [];
    if (activeChannels > 10) {
      issues.push('High number of active channels detected');
    }
    const idleConnections = connections.filter(c => c.status === 'idle').length;
    if (idleConnections > 5) {
      issues.push(`${idleConnections} idle connections that should be cleaned up`);
    }
    return issues;
  };

  const issues = getPotentialIssues();

  return (
    <Card className="w-full max-w-4xl mx-auto">
      <CardHeader>
        <div className="flex justify-between items-center">
          <CardTitle className="flex items-center gap-2">
            <Wifi className="h-5 w-5" />
            Realtime Connection Monitor
          </CardTitle>
          <Button onClick={refreshConnections} size="sm" variant="outline">
            <RefreshCw className="h-4 w-4 mr-2" />
            Refresh
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-3 gap-4">
          <div className="text-center p-4 bg-muted rounded">
            <div className="text-2xl font-bold">{activeChannels}</div>
            <div className="text-sm text-muted-foreground">Active Channels</div>
          </div>
          <div className="text-center p-4 bg-muted rounded">
            <div className="text-2xl font-bold">{connections.filter(c => c.status === 'active').length}</div>
            <div className="text-sm text-muted-foreground">Active Connections</div>
          </div>
          <div className="text-center p-4 bg-muted rounded">
            <div className="text-2xl font-bold">{connections.filter(c => c.status === 'idle').length}</div>
            <div className="text-sm text-muted-foreground">Idle Connections</div>
          </div>
        </div>

        {issues.length > 0 && (
          <Alert variant="destructive">
            <AlertTitle>Potential Connection Issues</AlertTitle>
            <AlertDescription>
              <ul className="list-disc list-inside">
                {issues.map((issue, idx) => (
                  <li key={idx}>{issue}</li>
                ))}
              </ul>
            </AlertDescription>
          </Alert>
        )}

        <div className="space-y-2">
          <h3 className="font-semibold">Active Connections:</h3>
          {connections.length === 0 ? (
            <div className="text-muted-foreground flex items-center gap-2">
              <WifiOff className="h-4 w-4" />
              No active connections detected
            </div>
          ) : (
            <div className="space-y-2">
              {connections.map((conn) => (
                <div key={conn.id} className="p-3 border rounded text-sm">
                  <div className="flex justify-between items-start">
                    <div>
                      <div className="font-medium">Source: {conn.source}</div>
                      <div className="text-muted-foreground">
                        Type: {conn.type} | Status: {conn.status}
                      </div>
                      {conn.subscriptions && conn.subscriptions.length > 0 && (
                        <div className="text-xs mt-1">
                          Subscriptions: {conn.subscriptions.join(', ')}
                        </div>
                      )}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {conn.createdAt.toLocaleTimeString()}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        <div className="text-xs text-muted-foreground text-right">
          Last updated: {lastUpdated.toLocaleTimeString()}
        </div>
        
        <Alert>
          <AlertDescription>
            Check browser console for detailed connection logs. Connection data is also saved to localStorage.
          </AlertDescription>
        </Alert>

        <div className="mt-4 space-y-2">
          <h3 className="font-semibold">Connection Sources by File:</h3>
          <div className="text-sm space-y-1">
            {Object.entries(connectionLogger.getSummary().channelsBySource || {}).map(([source, count]) => (
              <div key={source} className="flex justify-between items-center p-2 bg-muted rounded">
                <span className="font-mono text-xs">{source}</span>
                <span className="font-bold">{count} active</span>
              </div>
            ))}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};


================================================
FILE: src/components/SupabaseChannelMonitor.tsx
================================================
import { useEffect, useState } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { connectionManager } from '@/lib/supabaseConnectionManager';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { AlertCircle, CheckCircle2, RefreshCw, Trash2 } from 'lucide-react';
import { ScrollArea } from '@/components/ui/scroll-area';

interface ChannelInfo {
  topic: string;
  state: string;
  subscriptionCount: number;
  presenceCount: number;
}

export const SupabaseChannelMonitor = () => {
  const [channels, setChannels] = useState<ChannelInfo[]>([]);
  const [isVisible, setIsVisible] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);

  const updateChannelInfo = () => {
    // Get stats from connection manager
    const managerStats = connectionManager.getStats();
    
    // Also get raw Supabase channels for comparison
    const realtimeClient = (supabase as any).realtime;
    if (!realtimeClient || !realtimeClient.channels) {
      // Just use manager stats
      const channelInfo: ChannelInfo[] = managerStats.channels.map(ch => ({
        topic: ch.name,
        state: ch.state,
        subscriptionCount: ch.subscriptions,
        presenceCount: 0,
      }));
      setChannels(channelInfo);
      return;
    }

    const channelInfo: ChannelInfo[] = [];
    
    // Combine manager stats with raw channel data
    realtimeClient.channels.forEach((channel: any) => {
      const managerChannel = managerStats.channels.find(ch => ch.name === channel.topic);
      channelInfo.push({
        topic: channel.topic,
        state: channel.state,
        subscriptionCount: managerChannel?.subscriptions || channel.bindings?.length || 0,
        presenceCount: Object.keys(channel.presence?.state || {}).length,
      });
    });

    setChannels(channelInfo);
  };

  useEffect(() => {
    // Only show in development
    if (process.env.NODE_ENV === 'development') {
      setIsVisible(true);
      updateChannelInfo();

      // Update every second
      const interval = setInterval(updateChannelInfo, 1000);
      return () => clearInterval(interval);
    }
  }, []);

  if (!isVisible) return null;

  const totalChannels = channels.length;
  const activeChannels = channels.filter(c => c.state === 'joined').length;
  const hasIssues = totalChannels > 10 || channels.some(c => c.subscriptionCount > 5);

  const handleClearAll = async () => {
    const realtimeClient = (supabase as any).realtime;
    if (!realtimeClient || !realtimeClient.channels) return;

    // Clear all channels
    const channelArray = Array.from(realtimeClient.channels.values());
    for (const channel of channelArray) {
      await supabase.removeChannel(channel);
    }
    
    updateChannelInfo();
  };

  if (isMinimized) {
    return (
      <div className="fixed bottom-4 right-4 z-50">
        <Button
          onClick={() => setIsMinimized(false)}
          variant={hasIssues ? "destructive" : "default"}
          size="sm"
          className="shadow-lg"
        >
          Channels: {totalChannels} {hasIssues && <AlertCircle className="ml-2 h-4 w-4" />}
        </Button>
      </div>
    );
  }

  return (
    <div className="fixed bottom-4 right-4 z-50 w-96">
      <Card className={`shadow-lg ${hasIssues ? 'border-red-500' : 'border-green-500'}`}>
        <CardHeader className="pb-3">
          <CardTitle className="text-sm flex items-center justify-between">
            <span className="flex items-center gap-2">
              Supabase Channels
              {hasIssues ? (
                <AlertCircle className="h-4 w-4 text-red-500" />
              ) : (
                <CheckCircle2 className="h-4 w-4 text-green-500" />
              )}
            </span>
            <div className="flex gap-1">
              <Button
                size="sm"
                variant="ghost"
                onClick={updateChannelInfo}
                className="h-6 w-6 p-0"
              >
                <RefreshCw className="h-3 w-3" />
              </Button>
              <Button
                size="sm"
                variant="ghost"
                onClick={handleClearAll}
                className="h-6 w-6 p-0"
                disabled={totalChannels === 0}
              >
                <Trash2 className="h-3 w-3" />
              </Button>
              <Button
                size="sm"
                variant="ghost"
                onClick={() => setIsMinimized(true)}
                className="h-6 w-6 p-0"
              >
                -
              </Button>
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          <div className="grid grid-cols-2 gap-2 text-sm">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Total:</span>
              <Badge variant={hasIssues ? 'destructive' : 'default'}>
                {totalChannels}
              </Badge>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Active:</span>
              <Badge variant="secondary">{activeChannels}</Badge>
            </div>
          </div>

          {channels.length > 0 && (
            <ScrollArea className="h-48 rounded border">
              <div className="p-2 space-y-1">
                {channels.map((channel, index) => (
                  <div
                    key={index}
                    className="text-xs p-2 rounded bg-muted/50 space-y-1"
                  >
                    <div className="font-mono truncate">{channel.topic}</div>
                    <div className="flex gap-2 text-muted-foreground">
                      <span>State: {channel.state}</span>
                      <span>Subs: {channel.subscriptionCount}</span>
                      {channel.presenceCount > 0 && (
                        <span>Presence: {channel.presenceCount}</span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>
          )}

          {hasIssues && (
            <div className="text-xs text-red-500 space-y-1">
              <p>⚠️ Potential issues detected:</p>
              {totalChannels > 10 && <p>• Too many channels ({totalChannels})</p>}
              {channels.some(c => c.subscriptionCount > 5) && (
                <p>• Some channels have many subscriptions</p>
              )}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};


================================================
FILE: src/components/layout/GlobalHeader.tsx
================================================
import { ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { LogOut, Menu } from 'lucide-react';
import { ThemeToggle } from '@/components/ui/theme-toggle';
import { LanguageToggle } from '@/components/ui/language-toggle';
import { useTranslation } from '@/hooks/useTranslation';
import { useLanguage } from '@/contexts/LanguageContext';
import { supabase } from '@/integrations/supabase/client';
import { useNavigate } from 'react-router-dom';

interface GlobalHeaderProps {
  title: string;
  subtitle?: string;
  icon: ReactNode;
  onMenuClick?: () => void;
  showMenuButton?: boolean;
}

export const GlobalHeader = ({ 
  title, 
  subtitle, 
  icon, 
  onMenuClick,
  showMenuButton = true
}: GlobalHeaderProps) => {
  const { t } = useTranslation();
  const { isRTL } = useLanguage();
  const navigate = useNavigate();

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    navigate('/auth');
  };

  return (
    <header className="!bg-card dark:!bg-[#181818] sticky top-0 z-30 h-[72px] flex items-center">
      <div className="px-4 sm:px-6 lg:px-24 flex items-center justify-between w-full">
        <div className="flex items-center gap-2 sm:gap-3 min-w-0 flex-1">
          {/* Mobile Menu Toggle */}
          {showMenuButton && (
            <Button
              variant="ghost"
              size="icon"
              className="h-9 w-9 lg:hidden"
              onClick={onMenuClick}
            >
              <Menu className="h-5 w-5" />
              <span className="sr-only">Toggle menu</span>
            </Button>
          )}
          
          {/* Icon */}
          <div className="h-6 w-6 sm:h-7 sm:w-7 text-primary flex-shrink-0">
            {icon}
          </div>
          
          {/* Title and Subtitle */}
          <div className="min-w-0 flex-1 flex items-baseline gap-2">
            <h1 className="text-lg sm:text-xl font-bold font-poppins text-foreground" style={{ letterSpacing: '-0.058em' }}>
              {title}
            </h1>
            {subtitle && (
              <>
                <span className="text-muted-foreground hidden sm:inline">·</span>
                <p className="text-xs sm:text-sm text-muted-foreground hidden sm:block">
                  {subtitle}
                </p>
              </>
            )}
          </div>
        </div>
        
        {/* Actions */}
        <div className="flex items-center gap-1 sm:gap-2 flex-shrink-0">
          <LanguageToggle />
          <ThemeToggle />
          <Button 
            variant="outline" 
            onClick={handleSignOut}
            size="sm"
            className="h-8 sm:h-9 text-xs sm:text-sm !bg-card dark:!bg-[#181818] border-0"
          >
            <LogOut className={`h-3 w-3 sm:h-4 sm:w-4 ${isRTL ? 'ml-1 sm:ml-2' : 'mr-1 sm:mr-2'}`} />
            <span className="hidden sm:inline">{t('auth.signOut')}</span>
          </Button>
        </div>
      </div>
    </header>
  );
};


================================================
FILE: src/components/layout/SidebarNav.module.css
================================================
/* CSS Variables for Google Fonts-inspired dark theme */
:root {
  --sidebar-bg: #1f1f1f;
  --sidebar-border: #2a2a2a;
  --text-primary: #e8eaed;
  --text-secondary: #9aa0a6;
  --accent-blue: #1a73e8;
  --accent-blue-hover: #1765cc;
  --hover-bg: rgba(232, 234, 237, 0.08);
  --active-bg: #8ab4f8;
  --active-text: #1f1f1f;
}

.sidebar {
  position: sticky;
  top: 0;
  left: 0;
  height: 100vh;
  width: 280px;
  background-color: var(--sidebar-bg);
  border-right: 1px solid var(--sidebar-border);
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 40;
}

.navContainer {
  padding: 24px 16px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.navItem {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 12px 16px;
  border-radius: 100px;
  text-decoration: none;
  color: var(--text-secondary);
  font-size: 14px;
  font-weight: 500;
  line-height: 20px;
  transition: all 0.2s ease;
  position: relative;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.navItem:hover:not(.active) {
  background-color: var(--hover-bg);
  color: var(--text-primary);
}

.navItem.active {
  background-color: var(--active-bg);
  color: var(--active-text);
  font-weight: 600;
}

.navItem.active:hover {
  background-color: var(--active-bg);
}

.icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  stroke-width: 2;
}

.navItem:not(.active) .icon {
  opacity: 0.7;
}

.label {
  flex: 1;
  letter-spacing: 0.01em;
}

/* Smooth scrollbar styling */
.sidebar::-webkit-scrollbar {
  width: 8px;
}

.sidebar::-webkit-scrollbar-track {
  background: transparent;
}

.sidebar::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
  background-color: rgba(255, 255, 255, 0.3);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .sidebar {
    width: 240px;
  }
  
  .navContainer {
    padding: 16px 12px;
  }
  
  .navItem {
    padding: 10px 14px;
    font-size: 13px;
  }
  
  .icon {
    width: 18px;
    height: 18px;
  }
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.navItem {
  animation: fadeIn 0.3s ease-out;
  animation-fill-mode: both;
}

.navItem:nth-child(1) { animation-delay: 0.05s; }
.navItem:nth-child(2) { animation-delay: 0.1s; }
.navItem:nth-child(3) { animation-delay: 0.15s; }
.navItem:nth-child(4) { animation-delay: 0.2s; }
.navItem:nth-child(5) { animation-delay: 0.25s; }
.navItem:nth-child(6) { animation-delay: 0.3s; }
.navItem:nth-child(7) { animation-delay: 0.35s; }
.navItem:nth-child(8) { animation-delay: 0.4s; }


================================================
FILE: src/components/layout/SidebarNav.tsx
================================================
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import * as Icons from 'lucide-react';
import { cn } from '@/lib/utils';
import { motion } from 'framer-motion';

export interface NavItem {
  path: string;
  icon: string;
  label: string;
}

interface SidebarNavProps {
  items: NavItem[];
  activePath?: string;
  onNavigate?: () => void;
}

const SidebarNav: React.FC<SidebarNavProps> = ({ items, activePath, onNavigate }) => {
  const location = useLocation();
  const currentPath = activePath || location.pathname;

  const getIcon = (iconName: string) => {
    const Icon = Icons[iconName as keyof typeof Icons];
    return Icon ? <Icon className="h-6 w-6 flex-shrink-0" /> : null;
  };

  const handleClick = () => {
    if (onNavigate) {
      onNavigate();
    }
  };

  // Separate settings item from other items
  const settingsItem = items.find(item => item.icon === 'Settings');
  const mainItems = items.filter(item => item.icon !== 'Settings');

  const renderNavItem = (item: NavItem, index: number) => {
    const isActive = currentPath === item.path || 
                    (item.path !== '/' && item.path !== '/dashboard' && currentPath.startsWith(item.path));
    
    return (
      <motion.div
        key={item.path}
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ delay: index * 0.03 }}
      >
        <Link
          to={item.path}
          onClick={handleClick}
          className={cn(
            "flex flex-col items-center justify-center gap-1 p-3 rounded-lg transition-all duration-200",
            "hover:bg-accent hover:text-accent-foreground",
            isActive && "bg-primary text-primary-foreground hover:bg-primary/90 hover:text-primary-foreground",
            !isActive && "text-muted-foreground"
          )}
        >
          {getIcon(item.icon)}
          <span className="text-[10px] font-medium text-center leading-tight max-w-[60px] break-words lowercase">
            {item.label}
          </span>
        </Link>
      </motion.div>
    );
  };

  return (
    <nav className="sticky top-0 left-0 h-screen w-20 !bg-card dark:!bg-[#181818] overflow-y-auto overflow-x-hidden z-40 flex flex-col relative">
      {/* Logo/Brand - matches header height */}
      <div className="h-[72px] flex items-center justify-center px-2">
        <h2 className="text-sm font-bold font-poppins text-foreground lowercase" style={{ letterSpacing: '-0.03em' }}>
          bayaan.ai
        </h2>
      </div>
      
      {/* Main Navigation Items */}
      <div className="flex-1 py-4 px-2">
        <div className="space-y-2">
          {mainItems.map((item, index) => renderNavItem(item, index))}
        </div>
      </div>
      
      {/* Settings at the bottom */}
      {settingsItem && (
        <div className="px-2 pb-4">
          {renderNavItem(settingsItem, mainItems.length)}
        </div>
      )}
      
      {/* Custom scrollbar styling */}
      <style>{`
        nav::-webkit-scrollbar {
          width: 4px;
        }
        nav::-webkit-scrollbar-track {
          background: transparent;
        }
        nav::-webkit-scrollbar-thumb {
          background-color: rgba(0, 0, 0, 0.2);
          border-radius: 2px;
        }
        nav::-webkit-scrollbar-thumb:hover {
          background-color: rgba(0, 0, 0, 0.3);
        }
        .dark nav::-webkit-scrollbar-thumb {
          background-color: rgba(255, 255, 255, 0.2);
        }
        .dark nav::-webkit-scrollbar-thumb:hover {
          background-color: rgba(255, 255, 255, 0.3);
        }
      `}</style>
    </nav>
  );
};

export default SidebarNav;


================================================
FILE: src/components/shared/ConfirmDialog.tsx
================================================
import React from 'react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { Loader2 } from 'lucide-react';

interface ConfirmDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description?: string;
  confirmLabel?: string;
  cancelLabel?: string;
  variant?: 'default' | 'destructive';
  loading?: boolean;
  onConfirm: () => void | Promise<void>;
  onCancel?: () => void;
}

export function ConfirmDialog({
  open,
  onOpenChange,
  title,
  description,
  confirmLabel = 'Confirm',
  cancelLabel = 'Cancel',
  variant = 'default',
  loading = false,
  onConfirm,
  onCancel,
}: ConfirmDialogProps) {
  const handleConfirm = async () => {
    await onConfirm();
    if (!loading) {
      onOpenChange(false);
    }
  };

  const handleCancel = () => {
    onCancel?.();
    onOpenChange(false);
  };

  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{title}</AlertDialogTitle>
          {description && (
            <AlertDialogDescription>{description}</AlertDialogDescription>
          )}
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel onClick={handleCancel} disabled={loading}>
            {cancelLabel}
          </AlertDialogCancel>
          <Button
            variant={variant}
            onClick={handleConfirm}
            disabled={loading}
          >
            {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {confirmLabel}
          </Button>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}


================================================
FILE: src/components/shared/DataTable.tsx
================================================
import { useState, useMemo } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
  ArrowUpDown,
  ArrowUp,
  ArrowDown,
  MoreHorizontal,
  Search,
} from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';

export interface DataTableColumn<T> {
  key: string;
  header: string;
  accessor: (item: T) => React.ReactNode;
  sortable?: boolean;
  searchable?: boolean;
  width?: string;
}

export interface DataTableAction<T> {
  label: string;
  icon?: React.ReactNode;
  onClick: (item: T) => void;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  show?: (item: T) => boolean;
}

interface DataTableProps<T> {
  data: T[];
  columns: DataTableColumn<T>[];
  actions?: DataTableAction<T>[];
  searchPlaceholder?: string;
  pageSize?: number;
  pageSizeOptions?: number[];
  loading?: boolean;
  emptyMessage?: string;
  onRowClick?: (item: T) => void;
  getRowKey: (item: T) => string | number;
  className?: string;
}

export function DataTable<T>({
  data,
  columns,
  actions,
  searchPlaceholder,
  pageSize = 10,
  pageSizeOptions = [10, 20, 50, 100],
  loading = false,
  emptyMessage,
  onRowClick,
  getRowKey,
  className,
}: DataTableProps<T>) {
  const { t } = useTranslation();
  const [searchQuery, setSearchQuery] = useState('');
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(pageSize);

  // Filter data based on search
  const filteredData = useMemo(() => {
    if (!searchQuery) return data;
    
    return data.filter((item) => {
      return columns.some((column) => {
        if (!column.searchable) return false;
        const value = column.accessor(item);
        if (typeof value === 'string') {
          return value.toLowerCase().includes(searchQuery.toLowerCase());
        }
        return false;
      });
    });
  }, [data, searchQuery, columns]);

  // Sort data
  const sortedData = useMemo(() => {
    if (!sortColumn) return filteredData;
    
    const column = columns.find((col) => col.key === sortColumn);
    if (!column || !column.sortable) return filteredData;

    return [...filteredData].sort((a, b) => {
      const aValue = column.accessor(a);
      const bValue = column.accessor(b);
      
      if (aValue === null || aValue === undefined) return 1;
      if (bValue === null || bValue === undefined) return -1;
      
      let comparison = 0;
      if (typeof aValue === 'string' && typeof bValue === 'string') {
        comparison = aValue.localeCompare(bValue);
      } else if (typeof aValue === 'number' && typeof bValue === 'number') {
        comparison = aValue - bValue;
      } else {
        comparison = String(aValue).localeCompare(String(bValue));
      }
      
      return sortDirection === 'asc' ? comparison : -comparison;
    });
  }, [filteredData, sortColumn, sortDirection, columns]);

  // Paginate data
  const paginatedData = useMemo(() => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    return sortedData.slice(startIndex, endIndex);
  }, [sortedData, currentPage, itemsPerPage]);

  const totalPages = Math.ceil(sortedData.length / itemsPerPage);

  const handleSort = (columnKey: string) => {
    if (sortColumn === columnKey) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortColumn(columnKey);
      setSortDirection('asc');
    }
  };

  const handlePageChange = (newPage: number) => {
    setCurrentPage(Math.max(1, Math.min(newPage, totalPages)));
  };

  const handlePageSizeChange = (newSize: string) => {
    setItemsPerPage(Number(newSize));
    setCurrentPage(1);
  };

  const getSortIcon = (columnKey: string) => {
    if (sortColumn !== columnKey) {
      return <ArrowUpDown className="ml-2 h-4 w-4" />;
    }
    return sortDirection === 'asc' 
      ? <ArrowUp className="ml-2 h-4 w-4" />
      : <ArrowDown className="ml-2 h-4 w-4" />;
  };

  return (
    <div className={className}>
      {/* Search Bar */}
      {columns.some((col) => col.searchable) && (
        <div className="mb-4">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder={searchPlaceholder || t('common.search')}
              value={searchQuery}
              onChange={(e) => {
                setSearchQuery(e.target.value);
                setCurrentPage(1);
              }}
              className="pl-10"
            />
          </div>
        </div>
      )}

      {/* Table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              {columns.map((column) => (
                <TableHead
                  key={column.key}
                  style={{ width: column.width }}
                  className={column.sortable ? 'cursor-pointer select-none' : ''}
                  onClick={() => column.sortable && handleSort(column.key)}
                >
                  <div className="flex items-center">
                    {column.header}
                    {column.sortable && getSortIcon(column.key)}
                  </div>
                </TableHead>
              ))}
              {actions && actions.length > 0 && (
                <TableHead className="text-right">{t('common.actions')}</TableHead>
              )}
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={columns.length + (actions ? 1 : 0)} className="text-center py-8">
                  <div className="text-muted-foreground">{t('common.loading')}</div>
                </TableCell>
              </TableRow>
            ) : paginatedData.length === 0 ? (
              <TableRow>
                <TableCell colSpan={columns.length + (actions ? 1 : 0)} className="text-center py-8">
                  <div className="text-muted-foreground">
                    {emptyMessage || t('common.noDataFound')}
                  </div>
                </TableCell>
              </TableRow>
            ) : (
              paginatedData.map((item) => (
                <TableRow
                  key={getRowKey(item)}
                  className={onRowClick ? 'cursor-pointer hover:bg-muted/50' : ''}
                  onClick={() => onRowClick?.(item)}
                >
                  {columns.map((column) => (
                    <TableCell key={column.key}>{column.accessor(item)}</TableCell>
                  ))}
                  {actions && actions.length > 0 && (
                    <TableCell className="text-right">
                      {actions.length <= 2 ? (
                        <div className="flex items-center justify-end gap-2">
                          {actions.map((action, index) => {
                            if (action.show && !action.show(item)) return null;
                            return (
                              <Button
                                key={index}
                                variant={action.variant || 'ghost'}
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  action.onClick(item);
                                }}
                              >
                                {action.icon}
                                {!action.icon && action.label}
                              </Button>
                            );
                          })}
                        </div>
                      ) : (
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="sm">
                              <MoreHorizontal className="h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            {actions.map((action, index) => {
                              if (action.show && !action.show(item)) return null;
                              return (
                                <DropdownMenuItem
                                  key={index}
                                  onClick={() => action.onClick(item)}
                                  className={action.variant === 'destructive' ? 'text-destructive' : ''}
                                >
                                  {action.icon && <span className="mr-2">{action.icon}</span>}
                                  {action.label}
                                </DropdownMenuItem>
                              );
                            })}
                          </DropdownMenuContent>
                        </DropdownMenu>
                      )}
                    </TableCell>
                  )}
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between py-4">
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">
              {t('common.rowsPerPage')}:
            </span>
            <Select value={String(itemsPerPage)} onValueChange={handlePageSizeChange}>
              <SelectTrigger className="h-8 w-[70px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {pageSizeOptions.map((size) => (
                  <SelectItem key={size} value={String(size)}>
                    {size}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <span className="text-sm text-muted-foreground">
              {t('common.showingXofY')
                .replace('{start}', String((currentPage - 1) * itemsPerPage + 1))
                .replace('{end}', String(Math.min(currentPage * itemsPerPage, sortedData.length)))
                .replace('{total}', String(sortedData.length))}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(1)}
              disabled={currentPage === 1}
            >
              <ChevronsLeft className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(currentPage - 1)}
              disabled={currentPage === 1}
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <span className="text-sm">
              {t('common.pageXofY')
                .replace('{current}', String(currentPage))
                .replace('{total}', String(totalPages))}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(currentPage + 1)}
              disabled={currentPage === totalPages}
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(totalPages)}
              disabled={currentPage === totalPages}
            >
              <ChevronsRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}


================================================
FILE: src/components/shared/EmptyState.tsx
================================================
import React from 'react';
import { LucideIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

interface EmptyStateProps {
  icon?: LucideIcon;
  title: string;
  description?: string;
  action?: {
    label: string;
    onClick: () => void;
    icon?: React.ReactNode;
  };
  secondaryAction?: {
    label: string;
    onClick: () => void;
  };
  className?: string;
  iconClassName?: string;
}

export function EmptyState({
  icon: Icon,
  title,
  description,
  action,
  secondaryAction,
  className,
  iconClassName,
}: EmptyStateProps) {
  return (
    <div className={cn('flex flex-col items-center justify-center py-12 text-center', className)}>
      {Icon && (
        <Icon className={cn('h-12 w-12 text-muted-foreground mb-4', iconClassName)} />
      )}
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      {description && (
        <p className="text-muted-foreground max-w-sm mb-6">{description}</p>
      )}
      {(action || secondaryAction) && (
        <div className="flex flex-col sm:flex-row gap-2">
          {action && (
            <Button onClick={action.onClick}>
              {action.icon && <span className="mr-2">{action.icon}</span>}
              {action.label}
            </Button>
          )}
          {secondaryAction && (
            <Button variant="outline" onClick={secondaryAction.onClick}>
              {secondaryAction.label}
            </Button>
          )}
        </div>
      )}
    </div>
  );
}


================================================
FILE: src/components/shared/FormDrawer.tsx
================================================
import React from 'react';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { Button } from '@/components/ui/button';
import { Loader2, X } from 'lucide-react';
import { cn } from '@/lib/utils';

interface FormDrawerProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description?: string;
  children: React.ReactNode;
  onSubmit?: () => void | Promise<void>;
  onCancel?: () => void;
  submitLabel?: string;
  cancelLabel?: string;
  loading?: boolean;
  side?: 'left' | 'right' | 'top' | 'bottom';
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  showFooter?: boolean;
  className?: string;
}

const sizeClasses = {
  sm: 'sm:max-w-sm',
  md: 'sm:max-w-md',
  lg: 'sm:max-w-lg',
  xl: 'sm:max-w-xl',
  full: 'sm:max-w-full',
};

export function FormDrawer({
  open,
  onOpenChange,
  title,
  description,
  children,
  onSubmit,
  onCancel,
  submitLabel = 'Save',
  cancelLabel = 'Cancel',
  loading = false,
  side = 'right',
  size = 'md',
  showFooter = true,
  className,
}: FormDrawerProps) {
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (onSubmit) {
      await onSubmit();
      if (!loading) {
        onOpenChange(false);
      }
    }
  };

  const handleCancel = () => {
    onCancel?.();
    onOpenChange(false);
  };

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent 
        side={side} 
        className={cn(
          'flex flex-col',
          side === 'left' || side === 'right' ? sizeClasses[size] : '',
          className
        )}
      >
        <SheetHeader>
          <SheetTitle>{title}</SheetTitle>
          {description && (
            <SheetDescription>{description}</SheetDescription>
          )}
        </SheetHeader>
        
        <form onSubmit={handleSubmit} className="flex-1 flex flex-col">
          <div className="flex-1 overflow-y-auto py-4">
            {children}
          </div>
          
          {showFooter && (
            <SheetFooter className="mt-auto pt-4 border-t">
              <Button
                type="button"
                variant="outline"
                onClick={handleCancel}
                disabled={loading}
              >
                {cancelLabel}
              </Button>
              {onSubmit && (
                <Button type="submit" disabled={loading}>
                  {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                  {submitLabel}
                </Button>
              )}
            </SheetFooter>
          )}
        </form>
      </SheetContent>
    </Sheet>
  );
}


================================================
FILE: src/components/shared/PageHeader.tsx
================================================
import React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useNavigate, Link } from 'react-router-dom';
import { cn } from '@/lib/utils';

interface BreadcrumbItem {
  label: string;
  href?: string;
}

interface PageHeaderProps {
  title: string;
  description?: string;
  breadcrumbs?: BreadcrumbItem[];
  showBackButton?: boolean;
  actions?: React.ReactNode;
  className?: string;
}

export function PageHeader({
  title,
  description,
  breadcrumbs,
  showBackButton = false,
  actions,
  className,
}: PageHeaderProps) {
  const navigate = useNavigate();

  return (
    <div className={cn('space-y-2', className)}>
      {/* Breadcrumbs */}
      {breadcrumbs && breadcrumbs.length > 0 && (
        <nav className="flex items-center space-x-1 text-sm text-muted-foreground">
          {breadcrumbs.map((crumb, index) => (
            <React.Fragment key={index}>
              {index > 0 && <ChevronRight className="h-4 w-4" />}
              {crumb.href ? (
                <Link
                  to={crumb.href}
                  className="hover:text-foreground transition-colors"
                >
                  {crumb.label}
                </Link>
              ) : (
                <span className="text-foreground font-medium">{crumb.label}</span>
              )}
            </React.Fragment>
          ))}
        </nav>
      )}

      {/* Header Content */}
      <div className="flex items-start justify-between">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            {showBackButton && (
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={() => navigate(-1)}
              >
                <ChevronLeft className="h-4 w-4" />
              </Button>
            )}
            <h1 className="text-2xl font-bold tracking-tight">{title}</h1>
          </div>
          {description && (
            <p className="text-muted-foreground">{description}</p>
          )}
        </div>
        {actions && (
          <div className="flex items-center gap-2">{actions}</div>
        )}
      </div>
    </div>
  );
}


================================================
FILE: src/components/ui/alert-dialog.tsx
================================================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



================================================
FILE: src/components/ui/alert.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }



================================================
FILE: src/components/ui/avatar.tsx
================================================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: src/components/ui/badge.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }



================================================
FILE: src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 lowercase",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================
FILE: src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
FILE: src/components/ui/checkbox.tsx
================================================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }



================================================
FILE: src/components/ui/command.tsx
================================================
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}



================================================
FILE: src/components/ui/dialog.tsx
================================================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}



================================================
FILE: src/components/ui/dropdown-menu.tsx
================================================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border !bg-card dark:!bg-[#181818] p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border !bg-card dark:!bg-[#181818] p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}



================================================
FILE: src/components/ui/empty-state.tsx
================================================
import { LucideIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

interface EmptyStateProps {
  icon: LucideIcon;
  title: string;
  description: string;
  action?: {
    label: string;
    onClick: () => void;
    variant?: 'default' | 'secondary' | 'outline' | 'ghost' | 'link' | 'destructive';
  };
  className?: string;
}

export function EmptyState({ 
  icon: Icon, 
  title, 
  description, 
  action,
  className 
}: EmptyStateProps) {
  return (
    <div className={cn(
      "flex flex-col items-center justify-center py-12 px-4 text-center",
      className
    )}>
      <div className="rounded-full bg-muted p-3 mb-4">
        <Icon className="h-8 w-8 text-muted-foreground" />
      </div>
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      <p className="text-muted-foreground mb-6 max-w-sm">{description}</p>
      {action && (
        <Button 
          variant={action.variant || 'default'} 
          onClick={action.onClick}
        >
          {action.label}
        </Button>
      )}
    </div>
  );
}


================================================
FILE: src/components/ui/form.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



================================================
FILE: src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



================================================
FILE: src/components/ui/language-select-simple.tsx
================================================
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, SelectGroup, SelectLabel, SelectSeparator } from '@/components/ui/select';
import { SPEECHMATICS_LANGUAGES, COMMON_LANGUAGES, getLanguageByCode } from '@/config/languages';
import { Badge } from '@/components/ui/badge';

interface LanguageSelectSimpleProps {
  value?: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
}

export function LanguageSelectSimple({
  value,
  onChange,
  placeholder = 'Select language...',
  disabled = false
}: LanguageSelectSimpleProps) {
  const selectedLanguage = value ? getLanguageByCode(value) : null;
  
  // Get common languages for quick access
  const commonLanguagesList = COMMON_LANGUAGES.map(code => getLanguageByCode(code)).filter(Boolean);
  
  // Get all other languages (excluding common ones)
  const otherLanguages = SPEECHMATICS_LANGUAGES.filter(
    lang => !COMMON_LANGUAGES.includes(lang.code)
  );

  return (
    <Select value={value} onValueChange={onChange} disabled={disabled}>
      <SelectTrigger className="w-full">
        <SelectValue placeholder={placeholder}>
          {selectedLanguage && (
            <div className="flex items-center gap-2">
              <span className="text-lg">{selectedLanguage.flag}</span>
              <span>
                {selectedLanguage.name}
                {selectedLanguage.code !== 'auto' && (
                  <span className="text-muted-foreground ml-1">
                    ({selectedLanguage.code})
                  </span>
                )}
              </span>
            </div>
          )}
        </SelectValue>
      </SelectTrigger>
      <SelectContent className="max-h-[400px]">
        <SelectGroup>
          <SelectLabel>Common Languages</SelectLabel>
          {commonLanguagesList.map((language) => language && (
            <SelectItem key={language.code} value={language.code}>
              <div className="flex items-center gap-2">
                <span className="text-lg">{language.flag}</span>
                <span>{language.name}</span>
                <span className="text-muted-foreground text-xs ml-1">
                  ({language.nativeName})
                </span>
                {language.rtl && (
                  <Badge variant="outline" className="text-xs ml-2">
                    RTL
                  </Badge>
                )}
              </div>
            </SelectItem>
          ))}
        </SelectGroup>
        
        <SelectSeparator />
        
        <SelectGroup>
          <SelectLabel>All Languages</SelectLabel>
          {otherLanguages.map((language) => (
            <SelectItem key={language.code} value={language.code}>
              <div className="flex items-center gap-2">
                <span className="text-lg">{language.flag}</span>
                <span>{language.name}</span>
                <span className="text-muted-foreground text-xs ml-1">
                  ({language.nativeName})
                </span>
                {language.code === 'auto' && (
                  <Badge className="text-xs ml-2">
                    Auto-detect
                  </Badge>
                )}
                {language.rtl && (
                  <Badge variant="outline" className="text-xs ml-2">
                    RTL
                  </Badge>
                )}
              </div>
            </SelectItem>
          ))}
        </SelectGroup>
      </SelectContent>
    </Select>
  );
}


================================================
FILE: src/components/ui/language-selector-inline.tsx
================================================
import { useState, useRef, useEffect } from 'react';
import { Check, ChevronsUpDown, Search, Globe } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { SPEECHMATICS_LANGUAGES, COMMON_LANGUAGES, getLanguageByCode, searchLanguages } from '@/config/languages';

interface LanguageSelectorInlineProps {
  value?: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
  disabled?: boolean;
}

export function LanguageSelectorInline({
  value,
  onChange,
  placeholder = 'Select language...',
  className,
  disabled = false
}: LanguageSelectorInlineProps) {
  const [open, setOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const dropdownRef = useRef<HTMLDivElement>(null);
  const selectedLanguage = value ? getLanguageByCode(value) : null;

  // Get common languages for quick access (exclude 'auto')
  const commonLanguagesList = COMMON_LANGUAGES
    .map(code => getLanguageByCode(code))
    .filter(Boolean)
    .filter(lang => lang!.code !== 'auto');
  
  // Filter languages based on search (exclude 'auto')
  const allLanguagesWithoutAuto = SPEECHMATICS_LANGUAGES.filter(lang => lang.code !== 'auto');
  const filteredLanguages = searchQuery 
    ? searchLanguages(searchQuery).filter(lang => lang.code !== 'auto')
    : allLanguagesWithoutAuto;

  const handleSelect = (languageCode: string) => {
    onChange(languageCode);
    setOpen(false);
    setSearchQuery('');
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setOpen(false);
      }
    };

    if (open) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [open]);

  return (
    <div className="relative" ref={dropdownRef}>
      <Button
        type="button"
        variant="outline"
        role="combobox"
        aria-expanded={open}
        onClick={() => setOpen(!open)}
        className={cn(
          "w-full justify-between",
          !value && "text-muted-foreground",
          className
        )}
        disabled={disabled}
      >
        <div className="flex items-center gap-2 truncate">
          {selectedLanguage ? (
            <>
              <span className="text-lg">{selectedLanguage.flag}</span>
              <span className="truncate">
                {selectedLanguage.name}
                {selectedLanguage.code !== 'auto' && (
                  <span className="text-muted-foreground ml-1">
                    ({selectedLanguage.nativeName})
                  </span>
                )}
              </span>
            </>
          ) : (
            <>
              <Globe className="h-4 w-4" />
              <span>{placeholder}</span>
            </>
          )}
        </div>
        <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
      </Button>

      {open && (
        <div className="absolute top-full left-0 right-0 mt-2 w-full bg-background border rounded-md shadow-lg z-[10000]">
          <div className="flex items-center border-b px-3 py-2">
            <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
            <Input
              placeholder="Search languages..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="flex-1 border-0 bg-transparent p-0 text-sm outline-none placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0"
              onClick={(e) => e.stopPropagation()}
            />
          </div>
          
          <div className="max-h-[300px] overflow-y-auto p-1">
            {!searchQuery && commonLanguagesList.length > 0 && (
              <>
                <div className="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                  Common Languages
                </div>
                {commonLanguagesList.map((language) => language && (
                  <div
                    key={language.code}
                    className={cn(
                      "relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground",
                      value === language.code && "bg-accent"
                    )}
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSelect(language.code);
                    }}
                  >
                    <Check
                      className={cn(
                        "mr-2 h-4 w-4",
                        value === language.code ? "opacity-100" : "opacity-0"
                      )}
                    />
                    <span className="text-lg mr-2">{language.flag}</span>
                    <div className="flex-1">
                      <div className="flex items-center gap-2">
                        <span>{language.name}</span>
                        {language.rtl && (
                          <Badge variant="outline" className="text-xs">
                            RTL
                          </Badge>
                        )}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        {language.nativeName} • {language.code}
                      </div>
                    </div>
                  </div>
                ))}
                <div className="my-1 h-px bg-border" />
              </>
            )}
            
            <div className="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
              {searchQuery ? "Search Results" : "All Languages"}
            </div>
            
            {filteredLanguages.length === 0 ? (
              <div className="px-2 py-6 text-center text-sm text-muted-foreground">
                No language found.
              </div>
            ) : (
              filteredLanguages.map((language) => (
                <div
                  key={language.code}
                  className={cn(
                    "relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground",
                    value === language.code && "bg-accent"
                  )}
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSelect(language.code);
                  }}
                >
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      value === language.code ? "opacity-100" : "opacity-0"
                    )}
                  />
                  <span className="text-lg mr-2">{language.flag}</span>
                  <div className="flex-1">
                    <div className="flex items-center gap-2">
                      <span>{language.name}</span>
                      {language.rtl && (
                        <Badge variant="outline" className="text-xs">
                          RTL
                        </Badge>
                      )}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {language.code !== 'auto' && `${language.nativeName} • `}{language.code}
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
}


================================================
FILE: src/components/ui/language-selector.tsx
================================================
import { useState } from 'react';
import { Check, ChevronsUpDown, Search, Globe } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Input } from '@/components/ui/input';
import { SPEECHMATICS_LANGUAGES, COMMON_LANGUAGES, getLanguageByCode, searchLanguages } from '@/config/languages';

interface LanguageSelectorProps {
  value?: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
  disabled?: boolean;
}

export function LanguageSelector({
  value,
  onChange,
  placeholder = 'Select language...',
  className,
  disabled = false
}: LanguageSelectorProps) {
  const [open, setOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const selectedLanguage = value ? getLanguageByCode(value) : null;

  // Get common languages for quick access (exclude 'auto')
  const commonLanguagesList = COMMON_LANGUAGES
    .map(code => getLanguageByCode(code))
    .filter(Boolean)
    .filter(lang => lang!.code !== 'auto');
  
  // Filter languages based on search (exclude 'auto')
  const allLanguagesWithoutAuto = SPEECHMATICS_LANGUAGES.filter(lang => lang.code !== 'auto');
  const filteredLanguages = searchQuery 
    ? searchLanguages(searchQuery).filter(lang => lang.code !== 'auto')
    : allLanguagesWithoutAuto;

  const handleSelect = (languageCode: string) => {
    onChange(languageCode);
    setOpen(false);
    setSearchQuery('');
  };

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className={cn(
            "w-full justify-between",
            !value && "text-muted-foreground",
            className
          )}
          disabled={disabled}
        >
          <div className="flex items-center gap-2 truncate">
            {selectedLanguage ? (
              <>
                <span className="text-lg">{selectedLanguage.flag}</span>
                <span className="truncate">
                  {selectedLanguage.name}
                  {selectedLanguage.code !== 'auto' && (
                    <span className="text-muted-foreground ml-1">
                      ({selectedLanguage.nativeName})
                    </span>
                  )}
                </span>
              </>
            ) : (
              <>
                <Globe className="h-4 w-4" />
                <span>{placeholder}</span>
              </>
            )}
          </div>
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent 
        className="w-[400px] p-0" 
        align="start" 
        sideOffset={5}
        onOpenAutoFocus={(e) => e.preventDefault()}>
        <div className="flex items-center border-b px-3 py-2">
          <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
          <Input
            placeholder="Search languages..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="flex-1 border-0 bg-transparent p-0 text-sm outline-none placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0"
          />
        </div>
        
        <ScrollArea className="h-[400px]">
          <div className="p-1">
            {!searchQuery && commonLanguagesList.length > 0 && (
              <>
                <div className="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                  Common Languages
                </div>
                {commonLanguagesList.map((language) => language && (
                  <div
                    key={language.code}
                    className={cn(
                      "relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground",
                      value === language.code && "bg-accent"
                    )}
                    onClick={() => handleSelect(language.code)}
                  >
                    <Check
                      className={cn(
                        "mr-2 h-4 w-4",
                        value === language.code ? "opacity-100" : "opacity-0"
                      )}
                    />
                    <span className="text-lg mr-2">{language.flag}</span>
                    <div className="flex-1">
                      <div className="flex items-center gap-2">
                        <span>{language.name}</span>
                        {language.rtl && (
                          <Badge variant="outline" className="text-xs">
                            RTL
                          </Badge>
                        )}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        {language.nativeName} • {language.code}
                      </div>
                    </div>
                  </div>
                ))}
                <div className="my-1 h-px bg-border" />
              </>
            )}
            
            <div className="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
              {searchQuery ? "Search Results" : "All Languages"}
            </div>
            
            {filteredLanguages.length === 0 ? (
              <div className="px-2 py-6 text-center text-sm text-muted-foreground">
                No language found.
              </div>
            ) : (
              filteredLanguages.map((language) => (
                <div
                  key={language.code}
                  className={cn(
                    "relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground",
                    value === language.code && "bg-accent"
                  )}
                  onClick={() => handleSelect(language.code)}
                >
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      value === language.code ? "opacity-100" : "opacity-0"
                    )}
                  />
                  <span className="text-lg mr-2">{language.flag}</span>
                  <div className="flex-1">
                    <div className="flex items-center gap-2">
                      <span>{language.name}</span>
                      {language.rtl && (
                        <Badge variant="outline" className="text-xs">
                          RTL
                        </Badge>
                      )}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {language.code !== 'auto' && `${language.nativeName} • `}{language.code}
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        </ScrollArea>
      </PopoverContent>
    </Popover>
  );
}


================================================
FILE: src/components/ui/language-toggle.tsx
================================================
import { Globe, ChevronDown } from "lucide-react"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { useLanguage } from "@/contexts/LanguageContext"
import { useTranslation } from "@/hooks/useTranslation"

export function LanguageToggle() {
  const { language, setLanguage } = useLanguage()
  const { t } = useTranslation()

  const languages = [
    { code: 'en' as const, name: t('languages.en'), flag: 'EN' },
    { code: 'ar' as const, name: t('languages.ar'), flag: 'AR' },
    { code: 'nl' as const, name: t('languages.nl'), flag: 'NL' },
  ]

  const currentLanguage = languages.find(lang => lang.code === language)

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="outline"
          size="sm"
          className="min-w-[80px] justify-between !bg-card dark:!bg-[#181818] border-0"
        >
          <div className="flex items-center gap-1">
            <Globe className="h-4 w-4" />
            <span className="text-xs font-medium">
              {currentLanguage?.flag}
            </span>
          </div>
          <ChevronDown className="h-3 w-3" />
          <span className="sr-only">Select language</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent 
        align="end" 
        className="w-48 !bg-card dark:!bg-[#181818] border border-border shadow-lg z-50"
      >
        {languages.map((lang) => (
          <DropdownMenuItem
            key={lang.code}
            onClick={() => setLanguage(lang.code)}
            className={`cursor-pointer hover:bg-muted/50 ${
              language === lang.code ? 'bg-muted text-primary font-medium' : ''
            }`}
          >
            <div className="flex items-center justify-between w-full">
              <span>{lang.name}</span>
              <span className="text-xs text-muted-foreground">{lang.flag}</span>
            </div>
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  )
}


================================================
FILE: src/components/ui/loading-skeleton.tsx
================================================
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent, CardHeader } from '@/components/ui/card';

interface LoadingSkeletonProps {
  variant?: 'table' | 'card' | 'stats' | 'list';
  rows?: number;
  columns?: number;
}

export function LoadingSkeleton({ variant = 'table', rows = 5, columns = 4 }: LoadingSkeletonProps) {
  if (variant === 'stats') {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {Array.from({ length: 4 }).map((_, i) => (
          <Card key={i}>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <Skeleton className="h-4 w-[100px]" />
              <Skeleton className="h-4 w-4 rounded-full" />
            </CardHeader>
            <CardContent>
              <Skeleton className="h-8 w-[60px] mb-2" />
              <Skeleton className="h-3 w-[120px]" />
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (variant === 'card') {
    return (
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-[200px] mb-2" />
          <Skeleton className="h-4 w-[300px]" />
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {Array.from({ length: rows }).map((_, i) => (
              <Skeleton key={i} className="h-4 w-full" />
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }

  if (variant === 'list') {
    return (
      <div className="space-y-4">
        {Array.from({ length: rows }).map((_, i) => (
          <div key={i} className="flex items-center space-x-4">
            <Skeleton className="h-12 w-12 rounded-full" />
            <div className="space-y-2 flex-1">
              <Skeleton className="h-4 w-[200px]" />
              <Skeleton className="h-3 w-[150px]" />
            </div>
            <Skeleton className="h-8 w-[80px]" />
          </div>
        ))}
      </div>
    );
  }

  // Default table skeleton
  return (
    <div className="space-y-4">
      <div className="rounded-md border">
        <div className="border-b bg-muted/50 p-4">
          <div className="flex items-center gap-4">
            {Array.from({ length: columns }).map((_, i) => (
              <Skeleton key={i} className="h-4 w-[100px]" />
            ))}
          </div>
        </div>
        <div className="divide-y">
          {Array.from({ length: rows }).map((_, rowIndex) => (
            <div key={rowIndex} className="p-4">
              <div className="flex items-center gap-4">
                {Array.from({ length: columns }).map((_, colIndex) => (
                  <Skeleton 
                    key={colIndex} 
                    className={`h-4 ${colIndex === 0 ? 'w-[150px]' : 'w-[100px]'}`} 
                  />
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


================================================
FILE: src/components/ui/native-language-select.tsx
================================================
import { SPEECHMATICS_LANGUAGES, COMMON_LANGUAGES, getLanguageByCode } from '@/config/languages';

interface NativeLanguageSelectProps {
  value?: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  className?: string;
}

export function NativeLanguageSelect({
  value,
  onChange,
  placeholder = 'Select language...',
  disabled = false,
  className = ''
}: NativeLanguageSelectProps) {
  const selectedLanguage = value ? getLanguageByCode(value) : null;
  
  // Get common languages for quick access
  const commonLanguagesList = COMMON_LANGUAGES.map(code => getLanguageByCode(code)).filter(Boolean);
  
  // Get all other languages (excluding common ones)
  const otherLanguages = SPEECHMATICS_LANGUAGES.filter(
    lang => !COMMON_LANGUAGES.includes(lang.code)
  );

  return (
    <select
      value={value || ''}
      onChange={(e) => onChange(e.target.value)}
      disabled={disabled}
      className={`flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${className}`}
    >
      <option value="" disabled>
        {placeholder}
      </option>
      
      <optgroup label="Common Languages">
        {commonLanguagesList.map((language) => language && (
          <option key={language.code} value={language.code}>
            {language.flag} {language.name} ({language.nativeName})
          </option>
        ))}
      </optgroup>
      
      <optgroup label="All Languages">
        {otherLanguages.map((language) => (
          <option key={language.code} value={language.code}>
            {language.flag} {language.name} ({language.nativeName})
          </option>
        ))}
      </optgroup>
    </select>
  );
}


================================================
FILE: src/components/ui/pagination.tsx
================================================
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}



================================================
FILE: src/components/ui/popover.tsx
================================================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-[9999] w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }



================================================
FILE: src/components/ui/progress.tsx
================================================
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }


================================================
FILE: src/components/ui/scroll-area.tsx
================================================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }



================================================
FILE: src/components/ui/secure-toggle.tsx
================================================
import * as React from 'react';
import { cn } from '@/lib/utils';
import { Switch } from '@/components/ui/switch';
import { Loader2 } from 'lucide-react';

export interface SecureToggleProps {
  icon: React.ElementType;
  label: string;
  checked: boolean;
  onCheckedChange: (checked: boolean) => void;
  isLoading?: boolean;
  disabled?: boolean;
  className?: string;
  color?: string;
}

export function SecureToggle({
  icon: Icon,
  label,
  checked,
  onCheckedChange,
  isLoading = false,
  disabled = false,
  className,
  color = 'data-[state=checked]:bg-primary',
}: SecureToggleProps) {
  return (
    <div className={cn("flex items-center gap-2", className)}>
      <Icon className="h-3.5 w-3.5 text-muted-foreground" />
      <span className="text-xs text-muted-foreground">{label}</span>
      <div className="relative">
        <Switch
          checked={checked}
          onCheckedChange={onCheckedChange}
          disabled={disabled || isLoading}
          className={cn("transition-all duration-200 ease-in-out", color)}
        />
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center">
            <Loader2 className="h-3 w-3 animate-spin text-muted-foreground" />
          </div>
        )}
      </div>
    </div>
  );
}


================================================
FILE: src/components/ui/select.tsx
================================================
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-[100] max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}



================================================
FILE: src/components/ui/separator.tsx
================================================
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }



================================================
FILE: src/components/ui/sheet.tsx
================================================
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
  VariantProps<typeof sheetVariants> { }

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet, SheetClose,
  SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger
}




================================================
FILE: src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: src/components/ui/slider.tsx
================================================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }



================================================
FILE: src/components/ui/sonner.tsx
================================================
import { useTheme } from "next-themes"
import { Toaster as Sonner, toast } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster, toast }



================================================
FILE: src/components/ui/styled-headers.tsx
================================================
import React from 'react';
import { cn } from '@/lib/utils';

interface StyledHeaderProps {
  children: React.ReactNode;
  className?: string;
  variant?: 'h1' | 'h2' | 'h3' | 'h4';
}

/**
 * Styled header components with Poppins font and consistent letter-spacing
 * Matches the landing page styling
 */

export const StyledH1: React.FC<StyledHeaderProps> = ({ children, className }) => (
  <h1 
    className={cn(
      "text-3xl md:text-4xl lg:text-5xl font-bold font-poppins lowercase",
      className
    )}
    style={{ letterSpacing: '-0.058em' }}
  >
    {children}
  </h1>
);

export const StyledH2: React.FC<StyledHeaderProps> = ({ children, className }) => (
  <h2 
    className={cn(
      "text-2xl md:text-3xl font-bold font-poppins lowercase",
      className
    )}
    style={{ letterSpacing: '-0.058em' }}
  >
    {children}
  </h2>
);

export const StyledH3: React.FC<StyledHeaderProps> = ({ children, className }) => (
  <h3 
    className={cn(
      "text-xl md:text-2xl font-bold font-poppins lowercase",
      className
    )}
    style={{ letterSpacing: '-0.058em' }}
  >
    {children}
  </h3>
);

export const StyledH4: React.FC<StyledHeaderProps> = ({ children, className }) => (
  <h4 
    className={cn(
      "text-lg font-bold font-poppins lowercase",
      className
    )}
    style={{ letterSpacing: '-0.058em' }}
  >
    {children}
  </h4>
);

// Utility component that selects the right header based on variant
export const StyledHeader: React.FC<StyledHeaderProps> = ({ 
  children, 
  className, 
  variant = 'h1' 
}) => {
  switch (variant) {
    case 'h1':
      return <StyledH1 className={className}>{children}</StyledH1>;
    case 'h2':
      return <StyledH2 className={className}>{children}</StyledH2>;
    case 'h3':
      return <StyledH3 className={className}>{children}</StyledH3>;
    case 'h4':
      return <StyledH4 className={className}>{children}</StyledH4>;
    default:
      return <StyledH1 className={className}>{children}</StyledH1>;
  }
};


================================================
FILE: src/components/ui/switch.tsx
================================================
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



================================================
FILE: src/components/ui/table.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: src/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-t-none rounded-b-full p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-t-none rounded-b-full px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }



================================================
FILE: src/components/ui/theme-toggle.tsx
================================================
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      className="!bg-card dark:!bg-[#181818] border-0"
    >
      <Sun className="h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}


================================================
FILE: src/components/ui/toast.tsx
================================================
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-4 right-4 z-[100] flex max-h-screen flex-col gap-2 sm:max-w-[320px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-3 pr-6 shadow-md transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-right-full data-[state=open]:scale-95",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-0.5 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-destructive-foreground/70 group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive group-[.destructive]:focus:ring-offset-destructive",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-3 w-3" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-xs font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-xs opacity-80", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}



================================================
FILE: src/components/ui/toaster.tsx
================================================
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}



================================================
FILE: src/components/ui/toggle.tsx
================================================
[Empty file]


================================================
FILE: src/components/ui/tooltip.tsx
================================================
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: src/components/ui/use-toast.ts
================================================
import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };



================================================
FILE: src/config/languages.ts
================================================
export interface Language {
  code: string;
  name: string;
  nativeName: string;
  flag?: string;
  rtl?: boolean;
}

export const SPEECHMATICS_LANGUAGES: Language[] = [
  { code: 'auto', name: 'Automatic Detection', nativeName: 'Auto', flag: '🌐' },
  { code: 'ar', name: 'Arabic', nativeName: 'العربية', flag: '🇸🇦', rtl: true },
  { code: 'ba', name: 'Bashkir', nativeName: 'Башҡорт', flag: '🇷🇺' },
  { code: 'eu', name: 'Basque', nativeName: 'Euskara', flag: '🇪🇸' },
  { code: 'be', name: 'Belarusian', nativeName: 'Беларуская', flag: '🇧🇾' },
  { code: 'bn', name: 'Bengali', nativeName: 'বাংলা', flag: '🇧🇩' },
  { code: 'bg', name: 'Bulgarian', nativeName: 'Български', flag: '🇧🇬' },
  { code: 'yue', name: 'Cantonese', nativeName: '廣東話', flag: '🇭🇰' },
  { code: 'ca', name: 'Catalan', nativeName: 'Català', flag: '🇪🇸' },
  { code: 'hr', name: 'Croatian', nativeName: 'Hrvatski', flag: '🇭🇷' },
  { code: 'cs', name: 'Czech', nativeName: 'Čeština', flag: '🇨🇿' },
  { code: 'da', name: 'Danish', nativeName: 'Dansk', flag: '🇩🇰' },
  { code: 'nl', name: 'Dutch', nativeName: 'Nederlands', flag: '🇳🇱' },
  { code: 'en', name: 'English', nativeName: 'English', flag: '🇬🇧' },
  { code: 'eo', name: 'Esperanto', nativeName: 'Esperanto', flag: '🌍' },
  { code: 'et', name: 'Estonian', nativeName: 'Eesti', flag: '🇪🇪' },
  { code: 'fi', name: 'Finnish', nativeName: 'Suomi', flag: '🇫🇮' },
  { code: 'fr', name: 'French', nativeName: 'Français', flag: '🇫🇷' },
  { code: 'gl', name: 'Galician', nativeName: 'Galego', flag: '🇪🇸' },
  { code: 'de', name: 'German', nativeName: 'Deutsch', flag: '🇩🇪' },
  { code: 'el', name: 'Greek', nativeName: 'Ελληνικά', flag: '🇬🇷' },
  { code: 'he', name: 'Hebrew', nativeName: 'עברית', flag: '🇮🇱', rtl: true },
  { code: 'hi', name: 'Hindi', nativeName: 'हिन्दी', flag: '🇮🇳' },
  { code: 'hu', name: 'Hungarian', nativeName: 'Magyar', flag: '🇭🇺' },
  { code: 'id', name: 'Indonesian', nativeName: 'Bahasa Indonesia', flag: '🇮🇩' },
  { code: 'ia', name: 'Interlingua', nativeName: 'Interlingua', flag: '🌍' },
  { code: 'ga', name: 'Irish', nativeName: 'Gaeilge', flag: '🇮🇪' },
  { code: 'it', name: 'Italian', nativeName: 'Italiano', flag: '🇮🇹' },
  { code: 'ja', name: 'Japanese', nativeName: '日本語', flag: '🇯🇵' },
  { code: 'ko', name: 'Korean', nativeName: '한국어', flag: '🇰🇷' },
  { code: 'lv', name: 'Latvian', nativeName: 'Latviešu', flag: '🇱🇻' },
  { code: 'lt', name: 'Lithuanian', nativeName: 'Lietuvių', flag: '🇱🇹' },
  { code: 'ms', name: 'Malay', nativeName: 'Bahasa Melayu', flag: '🇲🇾' },
  { code: 'en_ms', name: 'Malay & English', nativeName: 'Melayu & English', flag: '🇲🇾' },
  { code: 'mt', name: 'Maltese', nativeName: 'Malti', flag: '🇲🇹' },
  { code: 'cmn', name: 'Mandarin', nativeName: '普通话', flag: '🇨🇳' },
  { code: 'cmn_en', name: 'Mandarin & English', nativeName: '中英双语', flag: '🇨🇳' },
  { code: 'mr', name: 'Marathi', nativeName: 'मराठी', flag: '🇮🇳' },
  { code: 'mn', name: 'Mongolian', nativeName: 'Монгол', flag: '🇲🇳' },
  { code: 'no', name: 'Norwegian', nativeName: 'Norsk', flag: '🇳🇴' },
  { code: 'fa', name: 'Persian', nativeName: 'فارسی', flag: '🇮🇷', rtl: true },
  { code: 'pl', name: 'Polish', nativeName: 'Polski', flag: '🇵🇱' },
  { code: 'pt', name: 'Portuguese', nativeName: 'Português', flag: '🇵🇹' },
  { code: 'ro', name: 'Romanian', nativeName: 'Română', flag: '🇷🇴' },
  { code: 'ru', name: 'Russian', nativeName: 'Русский', flag: '🇷🇺' },
  { code: 'sk', name: 'Slovakian', nativeName: 'Slovenčina', flag: '🇸🇰' },
  { code: 'sl', name: 'Slovenian', nativeName: 'Slovenščina', flag: '🇸🇮' },
  { code: 'es', name: 'Spanish', nativeName: 'Español', flag: '🇪🇸' },
  { code: 'es_en', name: 'Spanish & English', nativeName: 'Español & English', flag: '🇪🇸' },
  { code: 'sw', name: 'Swahili', nativeName: 'Kiswahili', flag: '🇰🇪' },
  { code: 'sv', name: 'Swedish', nativeName: 'Svenska', flag: '🇸🇪' },
  { code: 'tl', name: 'Tagalog (Filipino)', nativeName: 'Tagalog', flag: '🇵🇭' },
  { code: 'ta', name: 'Tamil', nativeName: 'தமிழ்', flag: '🇮🇳' },
  { code: 'en_ta', name: 'Tamil & English', nativeName: 'தமிழ் & English', flag: '🇮🇳' },
  { code: 'th', name: 'Thai', nativeName: 'ไทย', flag: '🇹🇭' },
  { code: 'tr', name: 'Turkish', nativeName: 'Türkçe', flag: '🇹🇷' },
  { code: 'uk', name: 'Ukrainian', nativeName: 'Українська', flag: '🇺🇦' },
  { code: 'ur', name: 'Urdu', nativeName: 'اردو', flag: '🇵🇰', rtl: true },
  { code: 'ug', name: 'Uyghur', nativeName: 'ئۇيغۇرچە', flag: '🇨🇳', rtl: true },
  { code: 'vi', name: 'Vietnamese', nativeName: 'Tiếng Việt', flag: '🇻🇳' },
  { code: 'cy', name: 'Welsh', nativeName: 'Cymraeg', flag: '🏴󐁧󐁢󐁷󐁬󐁳󐁿' }
];

// Helper function to get language by code
export const getLanguageByCode = (code: string): Language | undefined => {
  return SPEECHMATICS_LANGUAGES.find(lang => lang.code === code);
};

// Helper function to search languages
export const searchLanguages = (query: string): Language[] => {
  const lowerQuery = query.toLowerCase();
  return SPEECHMATICS_LANGUAGES.filter(lang => 
    lang.name.toLowerCase().includes(lowerQuery) ||
    lang.nativeName.toLowerCase().includes(lowerQuery) ||
    lang.code.toLowerCase().includes(lowerQuery)
  );
};

// Common languages for quick access (shown at top)
export const COMMON_LANGUAGES = ['ar', 'en', 'fr', 'de', 'es', 'tr', 'ur', 'bn', 'id', 'ms'];


================================================
FILE: src/config/navigation.ts
================================================
import { NavItem } from '@/components/layout/SidebarNav';

export const getSuperAdminNavItems = (t: any): NavItem[] => [
  { path: '/dashboard', icon: 'LayoutDashboard', label: t('dashboard.overview') },
  { path: '/dashboard/mosques', icon: 'Building', label: t('dashboard.mosques') },
  { path: '/dashboard/users', icon: 'Users', label: t('dashboard.users') },
  { path: '/dashboard/rooms', icon: 'Video', label: t('dashboard.rooms') },
  { path: '/dashboard/sessions', icon: 'History', label: t('dashboard.sessions') },
  { path: '/dashboard/prompts', icon: 'MessageSquare', label: t('dashboard.prompts') },
  { path: '/dashboard/conversation', icon: 'MessageCircle', label: 'Conversation Mode' },
  { path: '/dashboard/remote', icon: 'Radio', label: 'Remote Control' },
  { path: '/dashboard/billing', icon: 'CreditCard', label: t('dashboard.billing') },
  { path: '/dashboard/settings', icon: 'Settings', label: t('dashboard.settings') },
];

export const getMosqueAdminNavItems = (t: any): NavItem[] => [
  { path: '/dashboard', icon: 'LayoutDashboard', label: t('dashboard.overview') },
  { path: '/history', icon: 'History', label: t('dashboard.history') },
  { path: '/dashboard/conversation', icon: 'MessageCircle', label: 'Conversation Mode' },
  { path: '/dashboard/remote', icon: 'Radio', label: 'Remote Control' },
  { path: '/dashboard/billing', icon: 'CreditCard', label: t('dashboard.billing') },
  { path: '/dashboard/settings', icon: 'Settings', label: t('dashboard.settings') },
];

export const getNavItems = (isSuperAdmin: boolean, t: any): NavItem[] => {
  return isSuperAdmin ? getSuperAdminNavItems(t) : getMosqueAdminNavItems(t);
};


================================================
FILE: src/contexts/LanguageContext.tsx
================================================
import React, { createContext, useContext, useState, useEffect } from 'react';

interface LanguageContextType {
  language: 'en' | 'ar' | 'nl';
  setLanguage: (language: 'en' | 'ar' | 'nl') => void;
  isRTL: boolean;
}

const LanguageContext = createContext<LanguageContextType>({
  language: 'en',
  setLanguage: () => {},
  isRTL: false,
});

export const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
};

interface LanguageProviderProps {
  children: React.ReactNode;
}

export const LanguageProvider: React.FC<LanguageProviderProps> = ({ children }) => {
  const [language, setLanguageState] = useState<'en' | 'ar' | 'nl'>(() => {
    const stored = localStorage.getItem('language');
    return (stored === 'ar' || stored === 'nl') ? stored : 'en';
  });

  const setLanguage = (newLanguage: 'en' | 'ar' | 'nl') => {
    setLanguageState(newLanguage);
    localStorage.setItem('language', newLanguage);
    
    // Update document direction and class
    document.documentElement.dir = newLanguage === 'ar' ? 'rtl' : 'ltr';
    document.documentElement.classList.toggle('rtl', newLanguage === 'ar');
  };

  useEffect(() => {
    // Set initial direction
    document.documentElement.dir = language === 'ar' ? 'rtl' : 'ltr';
    document.documentElement.classList.toggle('rtl', language === 'ar');
  }, [language]);

  const isRTL = language === 'ar';

  return (
    <LanguageContext.Provider value={{ language, setLanguage, isRTL }}>
      {children}
    </LanguageContext.Provider>
  );
};


================================================
FILE: src/contexts/VisibilityContext.tsx
================================================
import React, { createContext, useContext, useState, useEffect } from 'react';

interface VisibilityContextType {
  isVisible: boolean;
  isInitialLoad: boolean;
}

const VisibilityContext = createContext<VisibilityContextType>({
  isVisible: true,
  isInitialLoad: true,
});

export const useVisibility = () => {
  const context = useContext(VisibilityContext);
  if (!context) {
    throw new Error('useVisibility must be used within a VisibilityProvider');
  }
  return context;
};

interface VisibilityProviderProps {
  children: React.ReactNode;
}

export const VisibilityProvider: React.FC<VisibilityProviderProps> = ({ children }) => {
  const [isVisible, setIsVisible] = useState(!document.hidden);
  const [isInitialLoad, setIsInitialLoad] = useState(true);

  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    const handleVisibilityChange = () => {
      const newVisibility = !document.hidden;
      setIsVisible(newVisibility);
      
      // Mark as no longer initial load after first visibility change
      if (isInitialLoad) {
        timeoutId = setTimeout(() => {
          setIsInitialLoad(false);
        }, 100);
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Initial load complete after component mount
    const initialTimeout = setTimeout(() => {
      setIsInitialLoad(false);
    }, 500);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      if (timeoutId) clearTimeout(timeoutId);
      clearTimeout(initialTimeout);
    };
  }, [isInitialLoad]);

  return (
    <VisibilityContext.Provider value={{ isVisible, isInitialLoad }}>
      {children}
    </VisibilityContext.Provider>
  );
};


================================================
FILE: src/features/auth/components/UserCreationDialog.tsx
================================================
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2, Info } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import { createUserWithAuth } from '../services/adminUserService';

type Mosque = Tables<'Mosque'>;

const userCreationSchema = z.object({
  email: z.string().email('Invalid email address'),
  fullName: z.string().min(2, 'Name must be at least 2 characters'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  mosqueName: z.string().min(1, 'Please select a mosque'),
  role: z.enum(['Admin', 'User']),
});

type UserCreationData = z.infer<typeof userCreationSchema>;

interface UserCreationDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  mosques: Mosque[];
  onSuccess?: () => void;
}

export default function UserCreationDialog({ 
  open, 
  onOpenChange, 
  mosques,
  onSuccess 
}: UserCreationDialogProps) {
  const { toast } = useToast();
  const { t } = useTranslation();
  const [isCreating, setIsCreating] = useState(false);

  const form = useForm<UserCreationData>({
    resolver: zodResolver(userCreationSchema),
    defaultValues: {
      email: '',
      fullName: '',
      password: '',
      mosqueName: '',
      role: 'User',
    },
  });


  const onSubmit = async (data: UserCreationData) => {
    setIsCreating(true);
    
    try {
      // Find the selected mosque
      const selectedMosque = mosques.find(m => m.name === data.mosqueName);
      if (!selectedMosque) {
        throw new Error('Selected mosque not found');
      }

      // Use the service to create user with auth
      const result = await createUserWithAuth({
        email: data.email,
        password: data.password,
        full_name: data.fullName,
        mosque_id: selectedMosque.id,
        role: data.role
      });
      
      toast({
        title: t('common.success'),
        description: result.message || 'User created successfully. They can now log in with their credentials.',
      });

      // Reset form
      form.reset();
      
      if (onSuccess) {
        onSuccess();
      }
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : 'Failed to create user',
        variant: 'destructive',
      });
    } finally {
      setIsCreating(false);
    }
  };

  const handleClose = () => {
    form.reset();
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>{t('userCreation.title')}</DialogTitle>
          <DialogDescription>
            {t('userCreation.description')}
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('common.email')}</FormLabel>
                    <FormControl>
                      <Input type="email" placeholder={t('userCreation.emailPlaceholder')} {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="fullName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('userCreation.fullNameLabel')}</FormLabel>
                    <FormControl>
                      <Input placeholder={t('userCreation.fullNamePlaceholder')} {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('userCreation.passwordLabel')}</FormLabel>
                    <FormControl>
                      <Input type="password" placeholder="••••••••" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="mosqueName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('common.mosque')}</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder={t('userCreation.selectMosquePlaceholder')} />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {mosques.map((mosque) => (
                          <SelectItem key={mosque.id} value={mosque.name}>
                            {mosque.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="role"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('common.role')}</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="Admin">{t('common.admin')}</SelectItem>
                        <SelectItem value="User">{t('common.user')}</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <DialogFooter>
                <Button
                  type="button"
                  variant="outline"
                  onClick={handleClose}
                  disabled={isCreating}
                >
                  {t('common.cancel')}
                </Button>
                <Button type="submit" disabled={isCreating}>
                  {isCreating ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      {t('userCreation.creatingButton')}
                    </>
                  ) : (
                    t('userCreation.createButton')
                  )}
                </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: src/features/auth/components/UserMosqueAssignment.tsx
================================================
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { Loader2, Users, Building, AlertCircle } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';

type User = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface UserWithMosque extends User {
  mosque?: Mosque;
}

export default function UserMosqueAssignment() {
  const { toast } = useToast();
  const { t } = useTranslation();
  const [users, setUsers] = useState<UserWithMosque[]>([]);
  const [mosques, setMosques] = useState<Mosque[]>([]);
  const [loading, setLoading] = useState(true);
  const [updating, setUpdating] = useState<string | null>(null);
  const [unassignedOnly, setUnassignedOnly] = useState(false);

  const fetchData = async () => {
    try {
      setLoading(true);

      // Fetch all users with their mosque data
      const { data: usersData, error: usersError } = await supabase
        .from('users')
        .select(`
          *,
          mosque:Mosque!users_mosque_id_fkey (
            id,
            name,
            Subdomain
          )
        `)
        .order('created_at', { ascending: false });

      if (usersError) throw usersError;

      // Fetch all mosques
      const { data: mosquesData, error: mosquesError } = await supabase
        .from('Mosque')
        .select('*')
        .eq('is_active', true)
        .order('name');

      if (mosquesError) throw mosquesError;

      setUsers(usersData || []);
      setMosques(mosquesData || []);
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : 'Failed to fetch data',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleAssignMosque = async (userId: string, mosqueId: number, role?: string) => {
    try {
      setUpdating(userId);

      const { error } = await supabase.rpc('assign_user_to_mosque', {
        p_user_id: userId,
        p_mosque_id: mosqueId,
        p_role: role || 'User'
      });

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: 'User mosque assignment updated successfully',
      });

      // Refresh the data
      await fetchData();
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : 'Failed to update assignment',
        variant: 'destructive',
      });
    } finally {
      setUpdating(null);
    }
  };

  const filteredUsers = unassignedOnly 
    ? users.filter(u => !u.mosque_id)
    : users;

  if (loading) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <Users className="h-5 w-5" />
              {t('userMosqueAssignment.title')}
            </CardTitle>
            <CardDescription>
              {t('userMosqueAssignment.description')}
            </CardDescription>
          </div>
          <Button
            variant={unassignedOnly ? "default" : "outline"}
            size="sm"
            onClick={() => setUnassignedOnly(!unassignedOnly)}
          >
            {unassignedOnly ? t('userMosqueAssignment.showAllUsers') : t('userMosqueAssignment.showUnassignedOnly')}
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {filteredUsers.length === 0 ? (
          <Alert>
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              {unassignedOnly 
                ? t('userMosqueAssignment.noUnassignedUsers')
                : t('userMosqueAssignment.noUsersFound')
              }
            </AlertDescription>
          </Alert>
        ) : (
          <div className="space-y-4">
            {filteredUsers.map((user) => (
              <div 
                key={user.id} 
                className="flex items-center justify-between p-4 border rounded-lg hover:bg-muted/50 transition-colors"
              >
                <div className="flex-1">
                  <div className="flex items-center gap-2">
                    <span className="font-medium">{user.full_name || user.email}</span>
                    {user.is_super_admin && (
                      <Badge variant="secondary" className="text-xs">{t('common.superAdmin')}</Badge>
                    )}
                    {user.Role === 'Admin' && !user.is_super_admin && (
                      <Badge variant="outline" className="text-xs">{t('common.admin')}</Badge>
                    )}
                  </div>
                  <p className="text-sm text-muted-foreground">{user.email}</p>
                  {user.mosque && (
                    <div className="flex items-center gap-1 mt-1">
                      <Building className="h-3 w-3 text-muted-foreground" />
                      <span className="text-sm text-muted-foreground">
                        {t('userMosqueAssignment.currently')}: {user.mosque.name}
                      </span>
                    </div>
                  )}
                  {!user.mosque_id && (
                    <Badge variant="destructive" className="mt-1 text-xs">
                      {t('userMosqueAssignment.noMosqueAssigned')}
                    </Badge>
                  )}
                </div>

                <div className="flex items-center gap-2">
                  <Select
                    value={user.mosque_id?.toString() || ''}
                    onValueChange={(value) => handleAssignMosque(user.id, parseInt(value), user.Role || 'User')}
                    disabled={updating === user.id || user.is_super_admin}
                  >
                    <SelectTrigger className="w-[200px]" disabled={updating === user.id || user.is_super_admin}>
                      {updating === user.id ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                      ) : (
                        <SelectValue placeholder={t('userMosqueAssignment.selectMosque')} />
                      )}
                    </SelectTrigger>
                    <SelectContent>
                      {mosques.map((mosque) => (
                        <SelectItem key={mosque.id} value={mosque.id.toString()}>
                          {mosque.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>

                  <Select
                    value={user.Role || t('common.user')}
                    onValueChange={(role) => handleAssignMosque(user.id, user.mosque_id || mosques[0]?.id, role)}
                    disabled={updating === user.id || user.is_super_admin}
                  >
                    <SelectTrigger className="w-[120px]" disabled={updating === user.id || user.is_super_admin}>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="User">{t('common.user')}</SelectItem>
                      <SelectItem value="Admin">{t('common.admin')}</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
}


================================================
FILE: src/features/auth/pages/AuthPage.tsx
================================================
import { useState, useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2 } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { ThemeToggle } from '@/components/ui/theme-toggle';
import { useTranslation } from '@/hooks/useTranslation';
import { StyledHeader } from '@/components/ui/styled-headers';

const AuthPage = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { t } = useTranslation();
  
  // Get redirect URL from query params
  const redirectUrl = searchParams.get('redirect') || '/dashboard';

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        setError(error.message);
      } else if (data.user) {
        navigate(redirectUrl);
      }
    } catch (err) {
      setError(t('auth.unexpectedError'));
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-auth-background flex items-center justify-center p-4 relative">
      {/* Theme Toggle */}
      <div className="absolute top-4 right-4">
        <ThemeToggle />
      </div>
      
      <div className="w-full max-w-md space-y-8">
        {/* Logo and Title */}
        <div className="text-center">
          <div className="mb-4">
            <h1 className="text-4xl font-bold font-poppins text-foreground" style={{ letterSpacing: '-0.058em' }}>
              bayaan.ai
            </h1>
            <p className="text-muted-foreground mt-2">
              {t('auth.adminPanel')}
            </p>
          </div>
        </div>

        {/* Login Card */}
        <Card className="bg-auth-card shadow-lg border-0">
          <CardHeader className="space-y-1 pb-6">
            <StyledHeader variant="h2" className="text-center">
              {t('auth.signIn')}
            </StyledHeader>
            <p className="text-center text-muted-foreground">
              {t('auth.signInPrompt')}
            </p>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleSignIn} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="email">{t('auth.emailLabel')}</Label>
                <Input
                  id="email"
                  type="email"
                  placeholder={t('auth.emailPlaceholder')}
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                  className="h-11"
                />
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="password">{t('auth.passwordLabel')}</Label>
                <Input
                  id="password"
                  type="password"
                  placeholder={t('auth.passwordPlaceholder')}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                  className="h-11"
                />
              </div>

              {error && (
                <Alert variant="destructive" className="py-2">
                  <AlertDescription className="text-sm">
                    {error}
                  </AlertDescription>
                </Alert>
              )}

              <Button
                type="submit"
                className="w-full h-11 mt-6"
                disabled={loading}
              >
                {loading ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    {t('auth.signingIn')}
                  </>
                ) : (
                  t('auth.signIn')
                )}
              </Button>
            </form>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default AuthPage;


================================================
FILE: src/features/auth/services/adminUserService.ts
================================================
import { supabase } from '@/integrations/supabase/client';

interface CreateUserData {
  email: string;
  password: string;
  full_name: string;
  mosque_id: number;
  role: 'Admin' | 'User';
}

/**
 * Creates a new user with both Auth and Database profile
 * This uses Supabase's auth.signUp with metadata to create users
 */
export async function createUserWithAuth(data: CreateUserData) {
  try {
    // First check if current user is authorized
    const { data: currentUser } = await supabase.auth.getUser();
    if (!currentUser?.user) {
      throw new Error('Not authenticated');
    }

    // Check if current user is super admin
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('is_super_admin, Role, mosque_id')
      .eq('id', currentUser.user.id)
      .single();

    if (userError || !userData) {
      throw new Error('User profile not found');
    }

    // Verify authorization
    const isAuthorized = userData.is_super_admin || 
      (userData.Role === 'Admin' && userData.mosque_id === data.mosque_id);

    if (!isAuthorized) {
      throw new Error('Only super admins or mosque admins can create users');
    }

    // Create the user using signUp with metadata
    // This will create both Auth user and trigger profile creation
    const { data: authData, error: signUpError } = await supabase.auth.signUp({
      email: data.email,
      password: data.password,
      options: {
        data: {
          full_name: data.full_name,
          mosque_id: data.mosque_id,
          role: data.role
        },
        emailRedirectTo: `${window.location.origin}/auth`
      }
    });

    if (signUpError) {
      throw signUpError;
    }

    if (!authData.user) {
      throw new Error('Failed to create user');
    }

    // The handle_new_user trigger should create the profile
    // But let's ensure it has the correct mosque assignment
    // Wait briefly for the trigger to execute
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Update the profile to ensure correct mosque assignment
    const { error: updateError } = await supabase
      .from('users')
      .update({
        mosque_id: data.mosque_id,
        Role: data.role,
        full_name: data.full_name,
        is_active: true
      })
      .eq('id', authData.user.id);

    if (updateError) {
      console.warn('Profile update warning:', updateError);
      // Don't throw - the user is created
    }

    return {
      success: true,
      user: authData.user,
      message: 'User created successfully. They will receive a confirmation email.'
    };

  } catch (error) {
    console.error('Create user error:', error);
    throw error;
  }
}

/**
 * Alternative: Create user profile first, then send invite
 * This is useful when you want to pre-create profiles
 */
export async function createUserProfileAndInvite(data: CreateUserData) {
  try {
    // Check authorization first
    const { data: currentUser } = await supabase.auth.getUser();
    if (!currentUser?.user) {
      throw new Error('Not authenticated');
    }

    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('is_super_admin, Role, mosque_id')
      .eq('id', currentUser.user.id)
      .single();

    if (userError || !userData) {
      throw new Error('User profile not found');
    }

    const isAuthorized = userData.is_super_admin || 
      (userData.Role === 'Admin' && userData.mosque_id === data.mosque_id);

    if (!isAuthorized) {
      throw new Error('Only super admins or mosque admins can create users');
    }

    // Use the database function to create a profile
    const { data: result, error: dbError } = await supabase.rpc('create_user_with_mosque', {
      p_email: data.email,
      p_full_name: data.full_name,
      p_mosque_id: data.mosque_id,
      p_role: data.role,
      p_password: data.password
    });

    if (dbError) {
      throw dbError;
    }

    // Now create the auth user
    const { data: authData, error: signUpError } = await supabase.auth.signUp({
      email: data.email,
      password: data.password,
      options: {
        data: {
          full_name: data.full_name,
          mosque_id: data.mosque_id,
          role: data.role
        }
      }
    });

    if (signUpError) {
      // If auth creation fails, we should note this
      console.error('Auth creation failed:', signUpError);
      return {
        success: false,
        message: `Profile created but auth setup failed. User needs manual auth creation: ${signUpError.message}`,
        needsManualAuth: true,
        profileId: result.user_id
      };
    }

    return {
      success: true,
      user: authData.user,
      message: 'User created successfully with both profile and authentication.'
    };

  } catch (error) {
    console.error('Create user error:', error);
    throw error;
  }
}


================================================
FILE: src/features/conversation/components/BaseConversationView.tsx
================================================
import React, { useRef, useEffect, useCallback, useState } from 'react';
import { cn } from '@/lib/utils';
import { AnimatePresence } from 'framer-motion';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import { supabase } from '@/integrations/supabase/client';
import { broadcastChannelManager } from '@/lib/broadcastChannelManager';

// Components
import { ConversationControlBar } from './controls/ConversationControlBar';
import { ConversationDisplay, ConversationDisplayHandle } from './display/ConversationDisplay';
import { SpeakerOverlay } from './display/SpeakerOverlay';
import { ConversationFooter } from './footer/ConversationFooter';
import { BroadcastReceiver } from '@/features/livekit/components/BroadcastReceiver';

// Hooks
import { useWindowCoordination } from '../hooks/useWindowCoordination';
import { useLiveKitConnection } from '../hooks/useLiveKitConnection';
import { useConversationSession } from '../hooks/useConversationSession';
import { useConversationState } from '../hooks/useConversationState';
import { useSecondaryWindowModifications } from '../hooks/useSecondaryWindowModifications';
import { usePushToTalk } from '../hooks/usePushToTalk';

// Types
import { ConversationRole } from '../types/conversation.types';

type Room = Tables<'rooms'>;

interface BaseConversationViewProps {
  room: Room;
  mosque_id: number;
  role: ConversationRole;
  opponentRoomId?: number;
  className?: string;
}

export const BaseConversationView: React.FC<BaseConversationViewProps> = ({ 
  room, 
  mosque_id, 
  role,
  opponentRoomId,
  className
}) => {
  const { toast } = useToast();
  const { t } = useTranslation();
  const displayRef = useRef<ConversationDisplayHandle>(null);
  const [opponentRoom, setOpponentRoom] = React.useState<Room | null>(null);
  const windowCoordinationRef = useRef<ReturnType<typeof useWindowCoordination>>();

  // Apply secondary window modifications if needed
  useSecondaryWindowModifications(role);

  // Use all our new hooks
  const {
    state,
    displaySettings,
    sentences,
    currentSentence,
    updateState,
    updateDisplaySettings,
    addOrUpdateSentence,
    updateSentenceTranslation,
    resetConversation,
    toggleFullscreen
  } = useConversationState();

  const {
    sessionId,
    isActive: isSessionActive,
    transcriptCount,
    startSession,
    endSession
  } = useConversationSession({
    room,
    mosqueId: mosque_id,
    enabled: state.isMonitoring
  });

  const {
    connectionConfig,
    isConnecting,
    error: livekitError,
    generateToken,
    disconnect: disconnectLiveKit
  } = useLiveKitConnection({ room, role });

  // Push-to-talk state for mic synchronization
  const { isMuted, toggleMic, isToggling } = usePushToTalk(role);
  
  // Dedicated state for overlay to ensure real-time updates
  const [overlayMuted, setOverlayMuted] = useState(isMuted);
  
  // Sync overlay state with push-to-talk changes
  useEffect(() => {
    setOverlayMuted(isMuted);
  }, [isMuted]);

  // Handle translation events
  const handleTranslation = useCallback((text: string, language: string, timestamp: string, messageData?: any) => {
    const translation = text.trim();
    
    // Update sentences for state tracking (backward compatibility)
    if (messageData?.sentence_id) {
      updateSentenceTranslation(messageData.sentence_id, translation);
    }
    
    // Add translation to display
    displayRef.current?.addTranslation(text, language, timestamp);
  }, [updateSentenceTranslation]);

  // Handle transcription events
  const handleTranscription = useCallback((text: string, language: string, timestamp: string, messageData?: any) => {
    const arabicText = text.trim();
    if (!arabicText) return;
    
    if (messageData?.sentence_id) {
      addOrUpdateSentence({
        id: messageData.sentence_id,
        transcription: arabicText,
        isComplete: messageData.is_complete || false,
        timestamp
      });
    }
  }, [addOrUpdateSentence]);
  
  // Empty callbacks for ignored events
  const emptyCallback = useCallback(() => {}, []);

  // Define all handler functions before using them in windowCoordination
  const handleGoLive = useCallback(async () => {
    console.log(`[${role}] handleGoLive called`);
    
    // Set monitoring state immediately for instant UI feedback
    updateState({
      isMonitoring: true,
      currentSessionId: 'pending'
    });
    
    // Clear sentences when starting new session
    displayRef.current?.resetTranslations();
    
    // Show toast immediately
    toast({
      title: t('mosqueAdmin.monitor.goLive'),
      description: "Conversation mode is now active",
    });
    
    // Do the async operations without blocking
    const newSessionId = await startSession();
    if (!newSessionId) {
      console.log(`[${role}] Failed to start session`);
      updateState({ isMonitoring: false, currentSessionId: null });
      return;
    }
    
    console.log(`[${role}] Session started:`, newSessionId);
    updateState({ currentSessionId: newSessionId });
    
    // Do these in parallel, not sequentially
    const promises = [];
    
    // Auto-generate token if room is configured
    if (room.Livekit_room_name) {
      promises.push(generateToken(newSessionId));
    }
    
    // If primary, broadcast to secondary
    if (role === 'primary') {
      promises.push(windowCoordinationRef.current?.broadcastGoLive());
    }
    
    // Wait for all in parallel
    await Promise.all(promises);
  }, [startSession, updateState, role, room.Livekit_room_name, generateToken, toast, t]);

  const handleStopMonitoring = useCallback(async () => {
    // Update UI immediately for instant feedback
    updateState({
      isMonitoring: false,
      currentSessionId: null
    });
    disconnectLiveKit();
    
    // Reset broadcast channel state to allow quick reconnection
    const channelName = `live-transcription-${room.id}-${mosque_id}`;
    broadcastChannelManager.resetChannelState(channelName);
    
    // Do async operations without blocking UI
    // Skip transcript wait for user-initiated stops to prevent UI lag
    endSession(true).catch(err => {
      console.error('Session cleanup error:', err);
    });
    
    // If primary, broadcast to secondary immediately
    if (role === 'primary') {
      windowCoordinationRef.current?.broadcastStop();
    }
  }, [endSession, updateState, disconnectLiveKit, role, room.id, mosque_id]);

  const handleConnect = useCallback(async () => {
    console.log(`[${role}] Start Broadcasting clicked`);
    await generateToken(sessionId || undefined);
    updateState({ isBroadcasting: true });
    
    // If primary, broadcast to secondary
    if (role === 'primary') {
      await windowCoordinationRef.current?.broadcastStartBroadcast();
    }
  }, [generateToken, sessionId, role, updateState]);

  const handleHostDisconnect = useCallback(async () => {
    console.log(`[${role}] Host disconnect called`);
    
    // Also stop monitoring when ending the call
    if (state.isMonitoring) {
      await handleStopMonitoring();
    }
    
    disconnectLiveKit();
    updateState({ isBroadcasting: false });
    
    // Reset broadcast channel state to allow quick reconnection
    const channelName = `live-transcription-${room.id}-${mosque_id}`;
    broadcastChannelManager.resetChannelState(channelName);
    
    // If primary, broadcast to secondary immediately
    if (role === 'primary') {
      windowCoordinationRef.current?.broadcastEnd();
    }
    
    toast({
      title: "Audio broadcast ended",
      description: "You can start a new broadcast or leave the room",
    });
  }, [role, disconnectLiveKit, updateState, toast, room.id, mosque_id, state.isMonitoring, handleStopMonitoring]);

  // Window coordination with callbacks
  const windowCoordination = useWindowCoordination({
    roomId: room.id,
    role,
    enabled: true,
    onGoLiveCommand: useCallback(() => handleGoLive(), [handleGoLive]),
    onStopCommand: useCallback(() => handleStopMonitoring(), [handleStopMonitoring]),
    onEndCommand: useCallback(() => {
      // End command from other window - disconnect audio
      console.log(`[${role}] Received end command from other window`);
      handleHostDisconnect();
    }, [handleHostDisconnect, role]),
    onLeaveRoomCommand: useCallback(() => {
      window.location.href = `/dashboard/conversation/monitor?role=${role}`;
    }, [role]),
    onStartBroadcastCommand: useCallback(async () => {
      console.log(`[${role}] Received start broadcast command from other window`);
      await handleConnect();
    }, [handleConnect, role])
  });

  // Store window coordination ref
  useEffect(() => {
    windowCoordinationRef.current = windowCoordination;
  }, [windowCoordination]);

  // Fetch opponent room data when in listening mode
  useEffect(() => {
    const fetchOpponentRoom = async () => {
      if (!opponentRoomId || !displaySettings.isListeningMode) {
        setOpponentRoom(null);
        return;
      }

      try {
        const { data, error } = await supabase
          .from('rooms')
          .select('*')
          .eq('id', opponentRoomId)
          .single();

        if (error) throw error;
        setOpponentRoom(data);
      } catch (error) {
        console.error('Error fetching opponent room:', error);
        setOpponentRoom(null);
      }
    };

    fetchOpponentRoom();
  }, [opponentRoomId]);

  // Listen for fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      updateDisplaySettings({ isFullscreen: !!document.fullscreenElement });
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, [updateDisplaySettings]);

  const handleLeaveRoom = useCallback(() => {
    if (role === 'primary') {
      windowCoordinationRef.current?.broadcastLeaveRoom();
    }
    window.location.href = `/dashboard/conversation/monitor?role=${role}`;
  }, [role]);

  // Update state with LiveKit connection status
  useEffect(() => {
    updateState({
      error: livekitError,
      isConnecting
    });
  }, [livekitError, isConnecting, updateState]);

  return (
    <div className={cn(
      "conversation-live-monitor h-full flex flex-col",
      role === 'primary' ? 'primary-speaker' : 'secondary-speaker',
      className
    )}>
      {/* Control Bar */}
      <ConversationControlBar
        isMonitoring={state.isMonitoring}
        displaySettings={displaySettings}
        role={role}
        onGoLive={handleGoLive}
        onStopMonitoring={handleStopMonitoring}
        onLeaveRoom={handleLeaveRoom}
        onUpdateDisplaySettings={updateDisplaySettings}
      />

      {/* Broadcast Receivers - Always listening mode */}
      {/* Own room receiver for transcriptions only */}
      <BroadcastReceiver
        roomId={room.id}
        mosqueId={mosque_id}
        enabled={state.isMonitoring}
        onTranscription={handleTranscription}
        onTranslation={emptyCallback} // Ignore own translations
      />
      
      {/* Opponent room receiver for translations only */}
      {opponentRoomId && (
        <BroadcastReceiver
          roomId={opponentRoomId}
          mosqueId={mosque_id}
          enabled={state.isMonitoring}
          onTranscription={emptyCallback} // Ignore opponent transcriptions
          onTranslation={handleTranslation}
        />
      )}
      
      {/* Main Display */}
      <div className="flex-1 overflow-hidden relative">
        <ConversationDisplay
          ref={displayRef}
          sentences={sentences}
          currentSentence={currentSentence}
          transcriptionLanguage={room.transcription_language}  // Always show own transcriptions
          translationLanguage={opponentRoom ? opponentRoom.translation__language : room.translation__language}
          displaySettings={displaySettings}
        />
        
        {/* Speaker Status Overlay - Shows when unmuted (speaking) AND connected to LiveKit */}
        {connectionConfig.token && (
          <SpeakerOverlay
            role={role}
            isMuted={overlayMuted}
            isConnected={true}
            isToggling={isToggling}
            transcriptionLanguage={room.transcription_language}
            translationLanguage={room.translation__language}
            onToggleMic={toggleMic}
          />
        )}
      </div>
      
      {/* Fixed Footer Controls - Always render to maintain hooks order */}
      <ConversationFooter
        token={connectionConfig.token}
        serverUrl={connectionConfig.serverUrl}
        loading={false}
        error={state.error}
        roomName={room.Livekit_room_name}
        roomTitle={`${room.Title} - ${role === 'primary' ? 'Primary' : 'Secondary'} Speaker`}
        onConnect={handleConnect}
        onDisconnect={handleHostDisconnect}
        isConnecting={state.isConnecting}
        sessionId={sessionId}
        roomId={room.id}
        role={role}
        isVisible={state.isMonitoring}
      />
    </div>
  );
};


================================================
FILE: src/features/conversation/components/ConversationDisconnectButton.tsx
================================================
import React from 'react';
import { DisconnectButton as LiveKitDisconnectButton } from '@livekit/components-react';
import { PhoneOff, LogOut, X } from 'lucide-react';
import { cn } from '@/lib/utils';

interface ConversationDisconnectButtonProps extends React.ComponentProps<typeof LiveKitDisconnectButton> {
  variant?: 'default' | 'destructive' | 'outline' | 'ghost';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  icon?: 'phone' | 'logout' | 'x';
  showLabel?: boolean;
  customLabel?: string;
}

export const ConversationDisconnectButton = React.forwardRef<HTMLButtonElement, ConversationDisconnectButtonProps>(
  ({ 
    className, 
    variant = 'destructive', 
    size = 'default',
    icon = 'phone',
    showLabel = true,
    customLabel = 'End',
    children,
    ...props 
  }, ref) => {
    const baseStyles = cn(
      "inline-flex items-center justify-center gap-2",
      "rounded-lg font-medium",
      "transition-all duration-200",
      "focus:outline-none focus:ring-2 focus:ring-destructive/50 focus:ring-offset-2 focus:ring-offset-background",
      "disabled:opacity-50 disabled:cursor-not-allowed",
      "group"
    );

    const variantStyles = {
      default: cn(
        "bg-destructive text-destructive-foreground",
        "hover:bg-destructive/90",
        "shadow-sm hover:shadow-md"
      ),
      destructive: cn(
        "bg-destructive/10 text-destructive border border-destructive/20",
        "hover:bg-destructive/20 hover:border-destructive/30",
        "hover:shadow-sm"
      ),
      outline: cn(
        "border border-destructive/50 text-destructive",
        "hover:bg-destructive/10 hover:border-destructive"
      ),
      ghost: cn(
        "text-destructive",
        "hover:bg-destructive/10 hover:text-destructive"
      )
    };

    const sizeStyles = {
      default: "h-10 px-4 text-sm",
      sm: "h-9 px-3 text-sm",
      lg: "h-11 px-6 text-base",
      icon: "h-10 w-10 text-sm"
    };

    const iconSize = {
      default: "h-4 w-4",
      sm: "h-4 w-4",
      lg: "h-5 w-5",
      icon: "h-5 w-5"
    };

    const IconComponent = {
      phone: PhoneOff,
      logout: LogOut,
      x: X
    }[icon];

    return (
      <LiveKitDisconnectButton
        ref={ref}
        className={cn(
          baseStyles,
          variantStyles[variant],
          sizeStyles[size],
          className
        )}
        {...props}
      >
        {children || (
          <>
            <IconComponent className={cn(
              iconSize[size],
              "transition-transform duration-200",
              "group-hover:scale-110"
            )} />
            {showLabel && size !== 'icon' && (
              <span className="font-medium">{customLabel}</span>
            )}
          </>
        )}
      </LiveKitDisconnectButton>
    );
  }
);

ConversationDisconnectButton.displayName = 'ConversationDisconnectButton';


================================================
FILE: src/features/conversation/components/ConversationHeader.tsx
================================================
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useConversationTheme } from '../utils/conversationTheme';

interface ConversationHeaderProps {
  roomTitle: string;
  role: 'primary' | 'secondary';
  mosqueName?: string;
  transcriptionLanguage?: string;
  translationLanguage?: string;
}

export const ConversationHeader: React.FC<ConversationHeaderProps> = ({ 
  roomTitle, 
  role,
  mosqueName,
  transcriptionLanguage,
  translationLanguage
}) => {
  const { theme, colors, toggleTheme } = useConversationTheme();
  const roleIcon = role === 'primary' ? '🎙️' : '👤';
  const roleText = role === 'primary' ? 'Host' : 'Participant';
  
  return (
    <div 
      className="flex-shrink-0 border-b px-4 py-3" 
      style={{ 
        backgroundColor: colors.background, 
        borderColor: colors.border 
      }}
    >
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 min-w-0">
          <span className="text-lg">{roleIcon}</span>
          <h1 className="text-base font-medium truncate" style={{ color: colors.text }}>
            {roomTitle}
          </h1>
          <span 
            className="text-xs px-2 py-0.5 rounded-full whitespace-nowrap flex-shrink-0" 
            style={{ 
              backgroundColor: `${colors.accent}33`, 
              color: colors.accent 
            }}
          >
            {roleText}
          </span>
          {mosqueName && (
            <>
              <span className="text-xs" style={{ color: colors.mutedText2 }}>•</span>
              <span className="text-xs truncate hidden sm:block" style={{ color: colors.mutedText }}>
                {mosqueName}
              </span>
            </>
          )}
          {transcriptionLanguage && translationLanguage && (
            <>
              <span className="text-xs" style={{ color: colors.mutedText2 }}>•</span>
              <span className="text-xs whitespace-nowrap flex-shrink-0" style={{ color: colors.accent }}>
                {transcriptionLanguage.toUpperCase()} → {translationLanguage.toUpperCase()}
              </span>
            </>
          )}
        </div>
        
        <div className="flex items-center gap-3 flex-shrink-0">
          {/* Theme Toggle */}
          <button
            onClick={toggleTheme}
            className="p-1.5 rounded-md transition-all hover:scale-110"
            style={{ 
              backgroundColor: 'transparent', 
              color: colors.accent 
            }}
            title={theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode'}
          >
            {theme === 'light' ? <Moon className="h-4 w-4" /> : <Sun className="h-4 w-4" />}
          </button>
          
          {/* Live indicator */}
          <div className="flex items-center gap-1.5">
            <div className="w-1.5 h-1.5 rounded-full animate-pulse" style={{ backgroundColor: colors.accent }} />
            <span className="text-xs" style={{ color: colors.mutedText }}>
              Live
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ConversationHeader;


================================================
FILE: src/features/conversation/components/ConversationLiveMonitor.tsx
================================================
import React from 'react';
import { Tables } from '@/integrations/supabase/types';
import { BaseConversationView } from './BaseConversationView';
import { ConversationRole } from '../types/conversation.types';

type Room = Tables<'rooms'>;

interface ConversationLiveMonitorProps {
  room: Room;
  mosque_id: number;
  role?: ConversationRole;
  opponentRoomId?: number;
  className?: string;
}

/**
 * Refactored ConversationLiveMonitor that uses the new architecture
 * This is a drop-in replacement for the old ConversationLiveMonitor
 */
export const ConversationLiveMonitor: React.FC<ConversationLiveMonitorProps> = ({ 
  room, 
  mosque_id, 
  role = 'primary',
  opponentRoomId,
  className
}) => {
  return (
    <BaseConversationView
      room={room}
      mosque_id={mosque_id}
      role={role}
      opponentRoomId={opponentRoomId}
      className={className}
    />
  );
};

export default ConversationLiveMonitor;


================================================
FILE: src/features/conversation/components/ConversationMediaDeviceMenu.tsx
================================================
import React, { useState, useEffect } from 'react';
import { useMediaDeviceSelect, useMediaDevices } from '@livekit/components-react';
import { Settings2, ChevronDown, Mic, Check } from 'lucide-react';
import { cn } from '@/lib/utils';
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { motion, AnimatePresence } from 'framer-motion';
import { useConversationTheme } from '../utils/conversationTheme';
import { useTranslation } from '@/hooks/useTranslation';

interface ConversationMediaDeviceMenuProps {
  kind: MediaDeviceKind;
  className?: string;
  variant?: 'default' | 'compact';
}

export const ConversationMediaDeviceMenu: React.FC<ConversationMediaDeviceMenuProps> = ({
  kind,
  className,
  variant = 'default'
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [nativeDevices, setNativeDevices] = useState<MediaDeviceInfo[]>([]);
  const { colors } = useConversationTheme();
  const { t } = useTranslation();
  
  // Still use LiveKit hooks for integration
  const livekitDevices = useMediaDevices({ kind });
  const { activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({ kind });
  
  // Fetch devices natively to get proper labels
  useEffect(() => {
    const fetchDevices = async () => {
      try {
        // First request permission if needed
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop());
        
        // Then enumerate devices
        const allDevices = await navigator.mediaDevices.enumerateDevices();
        const audioDevices = allDevices.filter(d => d.kind === kind);
        setNativeDevices(audioDevices);
        } catch (err) {
        }
    };
    
    fetchDevices();
    
    // Listen for device changes
    navigator.mediaDevices.addEventListener('devicechange', fetchDevices);
    return () => {
      navigator.mediaDevices.removeEventListener('devicechange', fetchDevices);
    };
  }, [kind]);
  
  // Use native devices if they have labels, otherwise fall back to LiveKit devices
  const devices = nativeDevices.length > 0 && nativeDevices[0].label ? nativeDevices : livekitDevices;
  
  // Debug logging
  useEffect(() => {
    // Debug logging removed
  }, [devices, activeDeviceId, nativeDevices]);
  
  // Find the currently active device
  const activeDevice = devices.find(device => device.deviceId === activeDeviceId) || 
                      devices.find(device => device.deviceId === 'default') ||
                      devices[0];
  
  // Get display name from active device
  const displayName = activeDevice?.label || 'Select microphone';
  
  // Additional debug
  useEffect(() => {
    }, [displayName, activeDevice]);
  
  // Extract actual device name from label
  const getCleanDeviceName = (label: string) => {
    if (!label || label.trim() === '') {
      return 'Unknown Device';
    }
    
    // Extract text from within parentheses if present
    const parenthesesMatch = label.match(/\(([^)]+)\)/);
    if (parenthesesMatch && parenthesesMatch[1]) {
      return parenthesesMatch[1].trim();
    }
    
    // If no parentheses, try to clean up common prefixes
    const cleaned = label
      .replace(/^(Default - |Communications - |Microphone Array - )/, '')
      .replace(/^Microfoonmatrix - /, '') // Remove Dutch prefix
      .replace(/^Microphone - /, '')
      .replace(/\s+/g, ' ')
      .trim();
    
    return cleaned || label; // Fallback to original if cleaning results in empty string
  };

  // Handle dropdown open/close
  const handleDropdownOpen = (open: boolean) => {
    setIsOpen(open);
  };
  
  // Auto-select first device if none selected
  useEffect(() => {
    if (!activeDeviceId && devices.length > 0) {
      setActiveMediaDevice(devices[0].deviceId);
    }
  }, [devices, activeDeviceId, setActiveMediaDevice]);

  const handleDeviceSelect = (deviceId: string) => {
    setActiveMediaDevice(deviceId);
    setIsOpen(false);
  };

  const buttonStyles = cn(
    "relative inline-flex items-center justify-center gap-2",
    "backdrop-blur-sm",
    "border rounded-lg",
    "text-sm font-medium",
    "transition-all duration-200",
    "focus:outline-none",
    variant === 'compact' ? "h-10 w-10" : "h-10 w-10", // Square button, icon only
    className
  );

  return (
    <DropdownMenu.Root open={isOpen} onOpenChange={handleDropdownOpen}>
      <DropdownMenu.Trigger asChild>
        <button
          className={buttonStyles}
          style={{
            backgroundColor: colors.cardBg,
            borderColor: colors.border,
            color: colors.text
          }}
          onMouseEnter={(e) => {
            e.currentTarget.style.backgroundColor = colors.hover;
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.backgroundColor = colors.cardBg;
          }}
          title={getCleanDeviceName(displayName)} // Tooltip on hover
        >
          <div className="relative">
            <Mic className="h-5 w-5" style={{ color: colors.accent }} />
            {/* Small indicator if not default device */}
            {activeDevice && !activeDevice.label?.includes('Default') && (
              <div className="absolute -top-1 -right-1 w-2 h-2 rounded-full bg-blue-500" />
            )}
          </div>
        </button>
      </DropdownMenu.Trigger>

      <AnimatePresence>
        {isOpen && (
          <DropdownMenu.Portal forceMount>
            <DropdownMenu.Content asChild>
              <motion.div
                className={cn(
                  "z-50 min-w-[200px] sm:min-w-[240px] max-w-[280px] sm:max-w-[320px]",
                  "backdrop-blur-xl",
                  "border rounded-lg shadow-xl",
                  "p-1 mt-2",
                  "max-h-[60vh] overflow-y-auto"
                )}
                style={{
                  backgroundColor: colors.dropdownBg,
                  borderColor: colors.dropdownBorder,
                  color: colors.text
                }}
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.15 }}
                align="start"
                sideOffset={5}
              >
                {devices.length === 0 ? (
                  <div className="px-3 py-2 text-sm text-center" style={{ color: colors.mutedText }}>
                    No microphones found
                  </div>
                ) : (
                  <>
                    {/* Current device header */}
                    <div className="px-3 py-2 mb-1 border-b" style={{ borderColor: colors.border }}>
                      <div className="text-xs uppercase tracking-wider" style={{ color: colors.mutedText }}>{t('mediaDeviceMenu.currentDevice')}</div>
                      <div className="text-sm font-medium mt-1" style={{ color: colors.accent }}>
                        {getCleanDeviceName(displayName)}
                      </div>
                    </div>
                    {/* Device list */}
                    {devices.map((device, index) => {
                    const isActive = device.deviceId === activeDeviceId;
                    const cleanName = getCleanDeviceName(device.label || `${t('mediaDeviceMenu.device')} ${index + 1}`);
                    
                    return (
                      <DropdownMenu.Item key={device.deviceId} asChild>
                        <motion.button
                          className={cn(
                            "flex items-center gap-2 w-full px-3 py-2 rounded-md",
                            "text-sm font-medium transition-colors",
                            "focus:outline-none"
                          )}
                          style={{
                            backgroundColor: isActive ? colors.selectedBg : 'transparent',
                            color: isActive ? colors.accent : colors.text
                          }}
                          onMouseEnter={(e) => {
                            if (!isActive) {
                              e.currentTarget.style.backgroundColor = colors.hover;
                            }
                          }}
                          onMouseLeave={(e) => {
                            if (!isActive) {
                              e.currentTarget.style.backgroundColor = 'transparent';
                            }
                          }}
                          onClick={() => handleDeviceSelect(device.deviceId)}
                          whileHover={{ x: 2 }}
                          whileTap={{ scale: 0.98 }}
                        >
                          <div className="flex items-center gap-2 flex-1">
                            <div 
                              className="w-2 h-2 rounded-full"
                              style={{ 
                                backgroundColor: isActive ? colors.accent : colors.mutedText 
                              }}
                            />
                            <span className="truncate">{cleanName}</span>
                          </div>
                          {isActive && (
                            <Check className="h-4 w-4 shrink-0" style={{ color: colors.accent }} />
                          )}
                        </motion.button>
                      </DropdownMenu.Item>
                    );
                  })}
                  </>
                )}
                
                {/* Device info section */}
                <div className="mt-1 pt-1 border-t border-border/30">
                  <div className="px-3 py-2 text-xs text-muted-foreground/90">
                    <div className="flex items-center gap-1">
                      <Settings2 className="h-3 w-3" />
                      <span className="text-inherit">{t('mediaDeviceMenu.devicesAvailable', { count: devices.length })}</span>
                    </div>
                  </div>
                </div>
              </motion.div>
            </DropdownMenu.Content>
          </DropdownMenu.Portal>
        )}
      </AnimatePresence>
    </DropdownMenu.Root>
  );
};


================================================
FILE: src/features/conversation/components/ConversationMicToggle.tsx
================================================
import React from 'react';
import { useTrackToggle } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';

interface ConversationMicToggleProps {
  className?: string;
  showLabel?: boolean;
}

export const ConversationMicToggle: React.FC<ConversationMicToggleProps> = ({ 
  className, 
  showLabel = false
}) => {
  const { buttonProps, enabled } = useTrackToggle({ source: Track.Source.Microphone });

  return (
    <motion.button
      {...buttonProps}
      className={cn(
        "relative h-12 w-12 rounded-full",
        "bg-gradient-to-br",
        enabled 
          ? "from-emerald-500/20 to-emerald-600/20 hover:from-emerald-500/30 hover:to-emerald-600/30" 
          : "from-red-500/20 to-red-600/20 hover:from-red-500/30 hover:to-red-600/30",
        "backdrop-blur-xl border",
        enabled ? "border-emerald-500/30" : "border-red-500/30",
        "transition-all duration-300",
        "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background",
        enabled ? "focus:ring-emerald-500/50" : "focus:ring-red-500/50",
        "group overflow-hidden",
        className
      )}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      {/* Background pulse animation */}
      <AnimatePresence>
        {enabled && (
          <motion.div
            className="absolute inset-0 rounded-full bg-emerald-500/20"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1.5, opacity: 0 }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeOut"
            }}
          />
        )}
      </AnimatePresence>

      {/* Icon container */}
      <div className="relative z-10 flex items-center justify-center h-full">
        <AnimatePresence mode="wait">
          {enabled ? (
            <motion.div
              key="mic-on"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic On Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-emerald-600"
              >
                <path
                  d="M12 2C10.34 2 9 3.34 9 5V11C9 12.66 10.34 14 12 14C13.66 14 15 12.66 15 11V5C15 3.34 13.66 2 12 2Z"
                  fill="currentColor"
                  className="animate-pulse"
                />
                <path
                  d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                {/* Sound waves */}
                <motion.path
                  d="M5.5 9C5.5 9 6 8 6 11C6 14 5.5 13 5.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: -2 }}
                  animate={{ opacity: [0, 1, 0], x: [-2, 0, -2] }}
                  transition={{ duration: 1.5, repeat: Infinity }}
                />
                <motion.path
                  d="M18.5 9C18.5 9 18 8 18 11C18 14 18.5 13 18.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: 2 }}
                  animate={{ opacity: [0, 1, 0], x: [2, 0, 2] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: 0.75 }}
                />
              </svg>
            </motion.div>
          ) : (
            <motion.div
              key="mic-off"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic Off Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-red-600"
              >
                <path
                  d="M15 11V5C15 3.34 13.66 2 12 2C10.34 2 9 3.34 9 5V9.17L15 15.17V11Z"
                  fill="currentColor"
                />
                <path
                  d="M19 11H17C17 11.35 16.97 11.69 16.91 12.02L18.93 14.04C18.98 13.7 19 13.36 19 13V11Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                <path
                  d="M4.71 3.29C4.32 2.9 3.68 2.9 3.29 3.29C2.9 3.68 2.9 4.32 3.29 4.71L9 10.41V11C9 12.66 10.34 14 12 14C12.23 14 12.44 13.96 12.65 13.9L14.31 15.56C13.63 15.84 12.84 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C14.09 17.78 15.11 17.41 16 16.88L19.29 20.17C19.68 20.56 20.32 20.56 20.71 20.17C21.1 19.78 21.1 19.14 20.71 18.75L4.71 3.29Z"
                  fill="currentColor"
                />
                {/* Slash line */}
                <motion.line
                  x1="4"
                  y1="4"
                  x2="20"
                  y2="20"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  initial={{ pathLength: 0 }}
                  animate={{ pathLength: 1 }}
                  transition={{ duration: 0.3 }}
                />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Status indicator dot */}
      <div className={cn(
        "absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-background",
        enabled ? "bg-emerald-500" : "bg-red-500"
      )}>
        {enabled && (
          <div className="absolute inset-0 bg-emerald-500 rounded-full animate-ping" />
        )}
      </div>

      {showLabel && (
        <span className="sr-only">
          {enabled ? 'Mute microphone' : 'Unmute microphone'}
        </span>
      )}
    </motion.button>
  );
};


================================================
FILE: src/features/conversation/components/ConversationParticipantInfo.tsx
================================================
import React from 'react';
import { useParticipants, useTracks } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { Users, Mic, MicOff, Headphones } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useConversationTheme } from '../utils/conversationTheme';
import { useTranslation } from '@/hooks/useTranslation';

interface ConversationParticipantInfoProps {
  variant?: 'default' | 'compact' | 'detailed';
  className?: string;
  showLabels?: boolean;
}

export const ConversationParticipantInfo: React.FC<ConversationParticipantInfoProps> = ({
  variant = 'default',
  className,
  showLabels = false
}) => {
  const participants = useParticipants();
  const tracks = useTracks([Track.Source.Microphone]);
  const activeMics = tracks.filter(track => track.publication.isMuted === false).length;
  const { colors } = useConversationTheme();
  const { t } = useTranslation();

  const containerStyles = cn(
    "inline-flex items-center",
    "backdrop-blur-sm",
    "border rounded-lg",
    "transition-all duration-200",
    variant === 'compact' ? 'gap-3 px-3 py-1.5' : 'gap-4 px-4 py-2',
    className
  );

  const statStyles = cn(
    "flex items-center gap-1.5",
    "transition-colors duration-200"
  );

  const iconStyles = cn(
    variant === 'compact' ? 'h-3.5 w-3.5' : 'h-4 w-4'
  );

  const valueStyles = cn(
    "font-semibold tabular-nums",
    variant === 'compact' ? 'text-sm' : 'text-base'
  );

  const labelStyles = cn(
    "ml-1",
    variant === 'compact' ? 'text-xs' : 'text-sm'
  );

  if (variant === 'detailed') {
    return (
      <div 
        className={cn(
          "flex flex-col gap-3 p-4",
          "backdrop-blur-sm",
          "border rounded-lg",
          className
        )}
        style={{
          backgroundColor: colors.cardBg,
          borderColor: colors.border
        }}
      >
        <div className="flex items-center justify-between">
          <div className={statStyles}>
            <Users className="h-5 w-5" style={{ color: colors.primaryRole }} />
            <span className="text-lg font-semibold" style={{ color: colors.text }}>{participants.length}</span>
            <span className="text-sm" style={{ color: colors.mutedText }}>{t('participantInfo.participants')}</span>
          </div>
        </div>
        <div className="flex items-center justify-between">
          <div className={statStyles}>
            <Mic className="h-5 w-5" style={{ color: colors.success }} />
            <span className="text-lg font-semibold" style={{ color: colors.text }}>{activeMics}</span>
            <span className="text-sm" style={{ color: colors.mutedText }}>{t('participantInfo.activeMics')}</span>
          </div>
        </div>
        <div className="flex items-center justify-between">
          <div className={statStyles}>
            <Headphones className="h-5 w-5" style={{ color: colors.accent }} />
            <span className="text-lg font-semibold" style={{ color: colors.text }}>{participants.length - activeMics}</span>
            <span className="text-sm" style={{ color: colors.mutedText }}>{t('participantInfo.listening')}</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div 
      className={containerStyles}
      style={{
        backgroundColor: colors.cardBg,
        borderColor: colors.border
      }}
    >
      <div className={statStyles}>
        <Users className={iconStyles} style={{ color: colors.primaryRole }} />
        <span className={valueStyles} style={{ color: colors.text }}>{participants.length}</span>
        {showLabels && <span className={labelStyles} style={{ color: colors.mutedText }}>{t('participantInfo.users')}</span>}
      </div>
      
      <div className="h-4 w-px" style={{ backgroundColor: colors.border }} />
      
      <div className={statStyles}>
        <div className="relative">
          <Mic className={iconStyles} style={{ color: activeMics > 0 ? colors.success : colors.mutedText }} />
          {activeMics > 0 && (
            <div className="absolute -top-1 -right-1 h-2 w-2 rounded-full animate-pulse" style={{ backgroundColor: colors.success }} />
          )}
        </div>
        <span className={valueStyles} style={{ color: colors.text }}>{activeMics}</span>
        {showLabels && <span className={labelStyles} style={{ color: colors.mutedText }}>{t('participantInfo.mics')}</span>}
      </div>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/ConversationPushToTalkToggle.tsx
================================================
import React from 'react';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';
import { ConversationRole } from '../types/conversation.types';
import { usePushToTalk } from '../hooks/usePushToTalk';

interface ConversationPushToTalkToggleProps {
  role: ConversationRole;
  className?: string;
  showLabel?: boolean;
}

export const ConversationPushToTalkToggle: React.FC<ConversationPushToTalkToggleProps> = ({ 
  role,
  className, 
  showLabel = false
}) => {
  const { isMuted, isEnabled, toggleMic } = usePushToTalk(role);

  return (
    <motion.button
      onClick={toggleMic}
      className={cn(
        "relative h-12 w-12 rounded-full",
        "bg-gradient-to-br",
        isEnabled 
          ? "from-emerald-500/20 to-emerald-600/20 hover:from-emerald-500/30 hover:to-emerald-600/30" 
          : "from-red-500/20 to-red-600/20 hover:from-red-500/30 hover:to-red-600/30",
        "backdrop-blur-xl border",
        isEnabled ? "border-emerald-500/30" : "border-red-500/30",
        "transition-all duration-300",
        "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background",
        isEnabled ? "focus:ring-emerald-500/50" : "focus:ring-red-500/50",
        "group overflow-hidden",
        className
      )}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      {/* Background pulse animation */}
      <AnimatePresence>
        {isEnabled && (
          <motion.div
            className="absolute inset-0 rounded-full bg-emerald-500/20"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1.5, opacity: 0 }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeOut"
            }}
          />
        )}
      </AnimatePresence>

      {/* Icon container */}
      <div className="relative z-10 flex items-center justify-center h-full">
        <AnimatePresence mode="wait">
          {isEnabled ? (
            <motion.div
              key="mic-on"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic On Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-emerald-600"
              >
                <path
                  d="M12 2C10.34 2 9 3.34 9 5V11C9 12.66 10.34 14 12 14C13.66 14 15 12.66 15 11V5C15 3.34 13.66 2 12 2Z"
                  fill="currentColor"
                  className="animate-pulse"
                />
                <path
                  d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                {/* Sound waves */}
                <motion.path
                  d="M5.5 9C5.5 9 6 8 6 11C6 14 5.5 13 5.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: -2 }}
                  animate={{ opacity: [0, 1, 0], x: [-2, 0, -2] }}
                  transition={{ duration: 1.5, repeat: Infinity }}
                />
                <motion.path
                  d="M18.5 9C18.5 9 18 8 18 11C18 14 18.5 13 18.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: 2 }}
                  animate={{ opacity: [0, 1, 0], x: [2, 0, 2] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: 0.75 }}
                />
              </svg>
            </motion.div>
          ) : (
            <motion.div
              key="mic-off"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic Off Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-red-600"
              >
                <path
                  d="M15 11V5C15 3.34 13.66 2 12 2C10.34 2 9 3.34 9 5V9.17L15 15.17V11Z"
                  fill="currentColor"
                />
                <path
                  d="M19 11H17C17 11.35 16.97 11.69 16.91 12.02L18.93 14.04C18.98 13.7 19 13.36 19 13V11Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                <path
                  d="M4.71 3.29C4.32 2.9 3.68 2.9 3.29 3.29C2.9 3.68 2.9 4.32 3.29 4.71L9 10.41V11C9 12.66 10.34 14 12 14C12.23 14 12.44 13.96 12.65 13.9L14.31 15.56C13.63 15.84 12.84 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C14.09 17.78 15.11 17.41 16 16.88L19.29 20.17C19.68 20.56 20.32 20.56 20.71 20.17C21.1 19.78 21.1 19.14 20.71 18.75L4.71 3.29Z"
                  fill="currentColor"
                />
                {/* Slash line */}
                <motion.line
                  x1="4"
                  y1="4"
                  x2="20"
                  y2="20"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  initial={{ pathLength: 0 }}
                  animate={{ pathLength: 1 }}
                  transition={{ duration: 0.3 }}
                />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Status indicator dot */}
      <div className={cn(
        "absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-background",
        isEnabled ? "bg-emerald-500" : "bg-red-500"
      )}>
        {isEnabled && (
          <div className="absolute inset-0 bg-emerald-500 rounded-full animate-ping" />
        )}
      </div>

      {/* Role indicator */}
      <div className={cn(
        "absolute top-0 left-0 px-1.5 py-0.5 text-[10px] font-medium rounded-full",
        "bg-background/80 backdrop-blur-md border",
        role === 'primary' ? "text-blue-600 border-blue-500/30" : "text-purple-600 border-purple-500/30"
      )}>
        {role === 'primary' ? 'P' : 'S'}
      </div>

      {showLabel && (
        <span className="sr-only">
          {isEnabled ? 'Mute microphone' : 'Unmute microphone'} ({role})
        </span>
      )}
    </motion.button>
  );
};


================================================
FILE: src/features/conversation/components/ConversationRoomSelector.tsx
================================================
import React, { useState, useEffect } from 'react';
import { Tables } from '@/integrations/supabase/types';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { toast } from 'sonner';
import { Loader2, ChevronDown } from 'lucide-react';
import { useConversationTheme } from '../utils/conversationTheme';
import { useTranslation } from '@/hooks/useTranslation';

type Room = Tables<'rooms'>;

interface ConversationRoomSelectorProps {
  role: 'primary' | 'secondary';
  onRoomSelected: (primaryRoomId: string, secondaryRoomId: string) => void;
}

export const ConversationRoomSelector: React.FC<ConversationRoomSelectorProps> = ({ 
  role, 
  onRoomSelected 
}) => {
  const { user } = useAuth();
  const [rooms, setRooms] = useState<Room[]>([]);
  const [primaryRoom, setPrimaryRoom] = useState<Room | null>(null);
  const [secondaryRoom, setSecondaryRoom] = useState<Room | null>(null);
  const [loading, setLoading] = useState(true);
  const [userProfile, setUserProfile] = useState<any>(null);
  const [primaryDropdownOpen, setPrimaryDropdownOpen] = useState(false);
  const [secondaryDropdownOpen, setSecondaryDropdownOpen] = useState(false);
  
  // Use theme colors from context
  const { colors } = useConversationTheme();
  const { t } = useTranslation();

  useEffect(() => {
    fetchUserProfile();
  }, [user]);

  // Close dropdowns when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      if (!target.closest('#primary-room') && !target.closest('.primary-dropdown')) {
        setPrimaryDropdownOpen(false);
      }
      if (!target.closest('#secondary-room') && !target.closest('.secondary-dropdown')) {
        setSecondaryDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  useEffect(() => {
    if (userProfile !== null) {
      fetchRooms();
      // Set up broadcast listener for secondary
      if (role === 'secondary') {
        setupBroadcastListener();
      }
    }
  }, [userProfile, role]);

  const fetchUserProfile = async () => {
    if (!user) return;
    
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .single();

      if (error) throw error;
      setUserProfile(data);
    } catch (error) {
      console.error('Error fetching user profile:', error);
    }
  };

  const fetchRooms = async () => {
    try {
      setLoading(true);
      let query = supabase
        .from('rooms')
        .select('*')
        .order('Title');

      // If not a super admin, filter by mosque_id
      if (!userProfile?.is_super_admin && userProfile?.mosque_id) {
        query = query.eq('mosque_id', userProfile.mosque_id);
      }

      const { data, error } = await query;

      if (error) throw error;
      setRooms(data || []);
    } catch (error) {
      console.error('Error fetching rooms:', error);
      toast.error('Failed to load rooms');
    } finally {
      setLoading(false);
    }
  };

  const setupBroadcastListener = () => {
    const channel = supabase.channel('conversation_room_selection')
      .on('broadcast', { event: 'room_selection' }, (payload: any) => {
        console.log('[Secondary] Received room selection:', payload);
        if (payload.payload?.primaryRoomId && payload.payload?.secondaryRoomId) {
          // Automatically trigger room loading on secondary
          onRoomSelected(payload.payload.primaryRoomId, payload.payload.secondaryRoomId);
        }
      })
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  };

  const handleStartConversation = async () => {
    if (!primaryRoom || !secondaryRoom) {
      toast.error('Please select both rooms');
      return;
    }

    // If primary, broadcast the selection to secondary
    if (role === 'primary') {
      const channel = supabase.channel('conversation_room_selection');
      await channel.send({
        type: 'broadcast',
        event: 'room_selection',
        payload: {
          primaryRoomId: primaryRoom.id,
          secondaryRoomId: secondaryRoom.id
        }
      });
    }

    // Trigger room loading
    onRoomSelected(primaryRoom.id, secondaryRoom.id);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <Loader2 className="h-8 w-8 animate-spin" style={{ color: colors.accent }} />
      </div>
    );
  }

  // Secondary speaker (participant) waits for primary's selection
  if (role === 'secondary') {
    return (
      <div className="flex items-center justify-center h-full p-8">
        <div 
          className="max-w-md w-full rounded-lg shadow-lg"
          style={{ 
            backgroundColor: colors.card,
            border: `1px solid ${colors.border}`
          }}
        >
          <div className="text-center p-6 border-b" style={{ borderColor: colors.border }}>
            <div 
              className="mx-auto mb-4 w-16 h-16 rounded-full flex items-center justify-center"
              style={{ backgroundColor: `${colors.secondaryRole}26` }}
            >
              <span className="text-2xl">👤</span>
            </div>
            <h2 className="text-xl font-semibold mb-2" style={{ color: colors.text }}>{t('conversationSelector.participantWaitingTitle')}</h2>
            <p style={{ color: colors.mutedText }}>
              {t('conversationSelector.participantWaitingDescription')}
            </p>
          </div>
          <div className="p-6">
            <div className="flex items-center justify-center py-8">
              <Loader2 className="h-8 w-8 animate-spin" style={{ color: colors.accent }} />
            </div>
            <p className="text-sm text-center" style={{ color: colors.mutedText }}>
              {t('conversationSelector.pleaseWait')}
            </p>
          </div>
        </div>
      </div>
    );
  }

  // Primary speaker (host) sees the selection UI
  return (
    <div className="flex items-center justify-center h-full p-8">
      <div 
        className="max-w-2xl w-full rounded-lg shadow-lg"
        style={{ 
          backgroundColor: colors.card,
          border: `1px solid ${colors.border}`
        }}
      >
        <div className="text-center p-6 border-b" style={{ borderColor: colors.border }}>
          <div 
            className="mx-auto mb-4 w-16 h-16 rounded-full flex items-center justify-center"
            style={{ backgroundColor: `${colors.primaryRole}26` }}
          >
            <span className="text-2xl">🎙️</span>
          </div>
          <h2 className="text-xl font-semibold mb-2" style={{ color: colors.text }}>{t('conversationSelector.hostControlTitle')}</h2>
          <p style={{ color: colors.mutedText }}>
            {t('conversationSelector.hostControlDescription')}
          </p>
        </div>
        <div className="p-6 space-y-6">
          <div className="grid gap-6 md:grid-cols-2">
            <div className="space-y-2">
              <label htmlFor="primary-room" className="text-sm font-medium" style={{ color: colors.text }}>
                🎙️ {t('conversationSelector.hostLanguageRoom')}
              </label>
              <p className="text-xs mb-1" style={{ color: colors.mutedText }}>
                {t('conversationSelector.hostRoomDescription')}
              </p>
              <div className="relative">
                <button
                  id="primary-room"
                  onClick={() => setPrimaryDropdownOpen(!primaryDropdownOpen)}
                  className="w-full px-3 py-2 text-left rounded-md transition-colors flex items-center justify-between"
                  style={{ 
                    backgroundColor: colors.inputBg,
                    border: `1px solid ${colors.dropdownBorder}`,
                    color: primaryRoom ? colors.text : colors.mutedText
                  }}
                >
                  <span>{primaryRoom?.Title || t('conversationSelector.selectHostRoom')}</span>
                  <ChevronDown className="h-4 w-4" style={{ color: colors.mutedText }} />
                </button>
                {primaryDropdownOpen && (
                  <div 
                    className="primary-dropdown absolute z-10 w-full mt-1 rounded-md shadow-lg overflow-hidden"
                    style={{ 
                      backgroundColor: colors.dropdownBg,
                      border: `1px solid ${colors.dropdownBorder}`
                    }}
                  >
                    <div className="max-h-60 overflow-auto">
                      {rooms.map((room) => (
                        <button
                          key={room.id}
                          onClick={() => {
                            setPrimaryRoom(room);
                            setPrimaryDropdownOpen(false);
                          }}
                          className="w-full px-3 py-2 text-left hover:transition-colors"
                          style={{ 
                            color: colors.text,
                            backgroundColor: primaryRoom?.id === room.id ? colors.selectedBg : 'transparent'
                          }}
                          onMouseEnter={(e) => {
                            if (primaryRoom?.id !== room.id) {
                              e.currentTarget.style.backgroundColor = colors.hover;
                            }
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = primaryRoom?.id === room.id ? colors.selectedBg : 'transparent';
                          }}
                        >
                          {room.Title}
                        </button>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>

            <div className="space-y-2">
              <label htmlFor="secondary-room" className="text-sm font-medium" style={{ color: colors.text }}>
                👤 {t('conversationSelector.participantLanguageRoom')}
              </label>
              <p className="text-xs mb-1" style={{ color: colors.mutedText }}>
                {t('conversationSelector.participantRoomDescription')}
              </p>
              <div className="relative">
                <button
                  id="secondary-room"
                  onClick={() => primaryRoom && setSecondaryDropdownOpen(!secondaryDropdownOpen)}
                  disabled={!primaryRoom}
                  className="w-full px-3 py-2 text-left rounded-md transition-colors flex items-center justify-between disabled:opacity-50 disabled:cursor-not-allowed"
                  style={{ 
                    backgroundColor: colors.inputBg,
                    border: `1px solid ${colors.dropdownBorder}`,
                    color: secondaryRoom ? colors.text : colors.mutedText
                  }}
                >
                  <span>{secondaryRoom?.Title || t('conversationSelector.selectParticipantRoom')}</span>
                  <ChevronDown className="h-4 w-4" style={{ color: colors.mutedText }} />
                </button>
                {secondaryDropdownOpen && primaryRoom && (
                  <div 
                    className="secondary-dropdown absolute z-10 w-full mt-1 rounded-md shadow-lg overflow-hidden"
                    style={{ 
                      backgroundColor: colors.dropdownBg,
                      border: `1px solid ${colors.dropdownBorder}`
                    }}
                  >
                    <div className="max-h-60 overflow-auto">
                      {rooms
                        .filter(room => room.id !== primaryRoom?.id)
                        .map((room) => (
                          <button
                            key={room.id}
                            onClick={() => {
                              setSecondaryRoom(room);
                              setSecondaryDropdownOpen(false);
                            }}
                            className="w-full px-3 py-2 text-left hover:transition-colors"
                            style={{ 
                              color: colors.text,
                              backgroundColor: secondaryRoom?.id === room.id ? colors.selectedBg : 'transparent'
                            }}
                            onMouseEnter={(e) => {
                              if (secondaryRoom?.id !== room.id) {
                                e.currentTarget.style.backgroundColor = colors.hover;
                              }
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.backgroundColor = secondaryRoom?.id === room.id ? colors.selectedBg : 'transparent';
                            }}
                          >
                            {room.Title}
                          </button>
                        ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          <div className="flex justify-center pt-4">
            <button
              onClick={handleStartConversation}
              disabled={!primaryRoom || !secondaryRoom}
              className="px-6 py-3 rounded-md font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed"
              style={{
                backgroundColor: colors.buttonPrimary,
                color: colors.buttonPrimaryText,
              }}
              onMouseEnter={(e) => {
                if (!e.currentTarget.disabled) {
                  e.currentTarget.style.backgroundColor = colors.buttonHover;
                }
              }}
              onMouseLeave={(e) => {
                if (!e.currentTarget.disabled) {
                  e.currentTarget.style.backgroundColor = colors.buttonPrimary;
                }
              }}
            >
              {t('conversationSelector.startConversation')}
            </button>
          </div>
          
          {primaryRoom && secondaryRoom && (
            <div 
              className="mt-4 p-4 rounded-lg border"
              style={{ 
                backgroundColor: colors.hover,
                borderColor: colors.border
              }}
            >
              <p className="text-sm" style={{ color: colors.mutedText }}>
                <strong style={{ color: colors.text }}>{t('conversationSelector.selectedRooms')}:</strong><br />
                {t('conversationSelector.primary')}: {primaryRoom.Title}<br />
                {t('conversationSelector.secondary')}: {secondaryRoom.Title}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/ConversationSyncedMicToggle.tsx
================================================
import React, { useEffect, useCallback } from 'react';
import { useTrackToggle } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';
import { ConversationRole } from '../types/conversation.types';
import { pushToTalkService } from '../services/pushToTalkService';

interface ConversationSyncedMicToggleProps {
  role: ConversationRole;
  className?: string;
  showLabel?: boolean;
}

export const ConversationSyncedMicToggle: React.FC<ConversationSyncedMicToggleProps> = ({ 
  role,
  className, 
  showLabel = false
}) => {
  // Get LiveKit's actual mic control
  const { buttonProps, enabled, toggle } = useTrackToggle({ source: Track.Source.Microphone });

  // Track if we've done initial mute
  const hasInitialMuted = React.useRef(false);

  // Track state changes and handle auto-enable for secondary
  useEffect(() => {
    console.log(`[${role}] Mic state changed: enabled=${enabled}`);
    
    // Only mute once during initialization for secondary
    if (role === 'secondary' && enabled && !hasInitialMuted.current) {
      console.log(`[${role}] Initial auto-enable detected, muting...`);
      hasInitialMuted.current = true;
      toggle();
    }
  }, [enabled, role, toggle]);

  // Listen for toggle commands from other window
  useEffect(() => {
    const unsubscribe = pushToTalkService.subscribe(() => {
      console.log(`[${role}] Received push-to-talk toggle command`);
      // When we receive a toggle command, toggle the LiveKit mic
      toggle();
    });

    return () => {
      unsubscribe();
    };
  }, [toggle, role]);

  // Handle local click
  const handleClick = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    console.log(`[${role}] Mic toggle clicked, broadcasting via Supabase...`);
    // Toggle LiveKit mic
    toggle();
    // Broadcast to other window via Supabase
    pushToTalkService.toggleMic(role);
  }, [toggle, role]);

  return (
    <motion.button
      {...buttonProps}
      onClick={handleClick} // Override LiveKit's onClick
      className={cn(
        "relative h-12 w-12 rounded-full",
        "bg-gradient-to-br",
        enabled 
          ? "from-emerald-500/20 to-emerald-600/20 hover:from-emerald-500/30 hover:to-emerald-600/30" 
          : "from-red-500/20 to-red-600/20 hover:from-red-500/30 hover:to-red-600/30",
        "backdrop-blur-xl border",
        enabled ? "border-emerald-500/30" : "border-red-500/30",
        "transition-all duration-300",
        "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background",
        enabled ? "focus:ring-emerald-500/50" : "focus:ring-red-500/50",
        "group overflow-hidden",
        className
      )}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      {/* Background pulse animation */}
      <AnimatePresence>
        {enabled && (
          <motion.div
            className="absolute inset-0 rounded-full bg-emerald-500/20"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1.5, opacity: 0 }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeOut"
            }}
          />
        )}
      </AnimatePresence>

      {/* Icon container */}
      <div className="relative z-10 flex items-center justify-center h-full">
        <AnimatePresence mode="wait">
          {enabled ? (
            <motion.div
              key="mic-on"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic On Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-emerald-600"
              >
                <path
                  d="M12 2C10.34 2 9 3.34 9 5V11C9 12.66 10.34 14 12 14C13.66 14 15 12.66 15 11V5C15 3.34 13.66 2 12 2Z"
                  fill="currentColor"
                  className="animate-pulse"
                />
                <path
                  d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                {/* Sound waves */}
                <motion.path
                  d="M5.5 9C5.5 9 6 8 6 11C6 14 5.5 13 5.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: -2 }}
                  animate={{ opacity: [0, 1, 0], x: [-2, 0, -2] }}
                  transition={{ duration: 1.5, repeat: Infinity }}
                />
                <motion.path
                  d="M18.5 9C18.5 9 18 8 18 11C18 14 18.5 13 18.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: 2 }}
                  animate={{ opacity: [0, 1, 0], x: [2, 0, 2] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: 0.75 }}
                />
              </svg>
            </motion.div>
          ) : (
            <motion.div
              key="mic-off"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic Off Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-red-600"
              >
                <path
                  d="M15 11V5C15 3.34 13.66 2 12 2C10.34 2 9 3.34 9 5V9.17L15 15.17V11Z"
                  fill="currentColor"
                />
                <path
                  d="M19 11H17C17 11.35 16.97 11.69 16.91 12.02L18.93 14.04C18.98 13.7 19 13.36 19 13V11Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                <path
                  d="M4.71 3.29C4.32 2.9 3.68 2.9 3.29 3.29C2.9 3.68 2.9 4.32 3.29 4.71L9 10.41V11C9 12.66 10.34 14 12 14C12.23 14 12.44 13.96 12.65 13.9L14.31 15.56C13.63 15.84 12.84 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C14.09 17.78 15.11 17.41 16 16.88L19.29 20.17C19.68 20.56 20.32 20.56 20.71 20.17C21.1 19.78 21.1 19.14 20.71 18.75L4.71 3.29Z"
                  fill="currentColor"
                />
                {/* Slash line */}
                <motion.line
                  x1="4"
                  y1="4"
                  x2="20"
                  y2="20"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  initial={{ pathLength: 0 }}
                  animate={{ pathLength: 1 }}
                  transition={{ duration: 0.3 }}
                />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Status indicator dot */}
      <div className={cn(
        "absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-background",
        enabled ? "bg-emerald-500" : "bg-red-500"
      )}>
        {enabled && (
          <div className="absolute inset-0 bg-emerald-500 rounded-full animate-ping" />
        )}
      </div>

      {/* Role indicator */}
      <div className={cn(
        "absolute top-0 left-0 px-1.5 py-0.5 text-[10px] font-medium rounded-full",
        "bg-background/80 backdrop-blur-md border",
        role === 'primary' ? "text-blue-600 border-blue-500/30" : "text-purple-600 border-purple-500/30"
      )}>
        {role === 'primary' ? 'P' : 'S'}
      </div>

      {showLabel && (
        <span className="sr-only">
          {enabled ? 'Mute microphone' : 'Unmute microphone'} ({role})
        </span>
      )}
    </motion.button>
  );
};


================================================
FILE: src/features/conversation/components/ConversationUnifiedMicToggle.tsx
================================================
import React, { useEffect } from 'react';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';
import { useTrackToggle } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { ConversationRole } from '../types/conversation.types';
import { usePushToTalk } from '../hooks/usePushToTalk';

interface ConversationUnifiedMicToggleProps {
  role: ConversationRole;
  className?: string;
  showLabel?: boolean;
}

export const ConversationUnifiedMicToggle: React.FC<ConversationUnifiedMicToggleProps> = ({ 
  role,
  className, 
  showLabel = false
}) => {
  // Get LiveKit's actual mic control
  const { buttonProps, enabled: livekitEnabled, toggle: livekitToggle } = useTrackToggle({ source: Track.Source.Microphone });
  
  // Single source of truth - usePushToTalk hook for sync
  const { isMuted, toggleMic, isToggling } = usePushToTalk(role);
  
  // Sync LiveKit state with push-to-talk state
  useEffect(() => {
    // If states are out of sync, update LiveKit
    if (livekitEnabled === isMuted) {
      console.log(`[ConversationUnifiedMicToggle ${role}] Syncing LiveKit state: enabled=${livekitEnabled}, isMuted=${isMuted}`);
      livekitToggle();
    }
  }, [isMuted, livekitEnabled, livekitToggle, role]);
  
  // Use LiveKit's enabled state for display
  const enabled = livekitEnabled;

  return (
    <motion.button
      onClick={() => {
        // Toggle both LiveKit and push-to-talk
        livekitToggle();
        toggleMic();
      }}
      disabled={isToggling}
      className={cn(
        "relative h-12 w-12 rounded-full",
        "bg-gradient-to-br",
        enabled 
          ? "from-emerald-500/20 to-emerald-600/20 hover:from-emerald-500/30 hover:to-emerald-600/30" 
          : "from-red-500/20 to-red-600/20 hover:from-red-500/30 hover:to-red-600/30",
        "backdrop-blur-xl border",
        enabled ? "border-emerald-500/30" : "border-red-500/30",
        "transition-all duration-300",
        "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background",
        enabled ? "focus:ring-emerald-500/50" : "focus:ring-red-500/50",
        "group overflow-hidden",
        isToggling && "opacity-50 cursor-wait",
        className
      )}
      whileHover={{ scale: isToggling ? 1 : 1.05 }}
      whileTap={{ scale: isToggling ? 1 : 0.95 }}
    >
      {/* Background pulse animation */}
      <AnimatePresence>
        {enabled && !isToggling && (
          <motion.div
            className="absolute inset-0 rounded-full bg-emerald-500/20"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1.5, opacity: 0 }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeOut"
            }}
          />
        )}
      </AnimatePresence>

      {/* Icon container */}
      <div className="relative z-10 flex items-center justify-center h-full">
        <AnimatePresence mode="wait">
          {isToggling ? (
            <motion.div
              key="toggling"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Loading/Switching Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-gray-400 animate-spin"
              >
                <circle
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  strokeWidth="3"
                  strokeLinecap="round"
                  strokeDasharray="60"
                  strokeDashoffset="20"
                />
              </svg>
            </motion.div>
          ) : enabled ? (
            <motion.div
              key="mic-on"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic On Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-emerald-600"
              >
                <path
                  d="M12 2C10.34 2 9 3.34 9 5V11C9 12.66 10.34 14 12 14C13.66 14 15 12.66 15 11V5C15 3.34 13.66 2 12 2Z"
                  fill="currentColor"
                  className="animate-pulse"
                />
                <path
                  d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                {/* Sound waves */}
                <motion.path
                  d="M5.5 9C5.5 9 6 8 6 11C6 14 5.5 13 5.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: -2 }}
                  animate={{ opacity: [0, 1, 0], x: [-2, 0, -2] }}
                  transition={{ duration: 1.5, repeat: Infinity }}
                />
                <motion.path
                  d="M18.5 9C18.5 9 18 8 18 11C18 14 18.5 13 18.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: 2 }}
                  animate={{ opacity: [0, 1, 0], x: [2, 0, 2] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: 0.75 }}
                />
              </svg>
            </motion.div>
          ) : (
            <motion.div
              key="mic-off"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic Off Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-red-600"
              >
                <path
                  d="M15 11V5C15 3.34 13.66 2 12 2C10.34 2 9 3.34 9 5V9.17L15 15.17V11Z"
                  fill="currentColor"
                />
                <path
                  d="M19 11H17C17 11.35 16.97 11.69 16.91 12.02L18.93 14.04C18.98 13.7 19 13.36 19 13V11Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                <path
                  d="M4.71 3.29C4.32 2.9 3.68 2.9 3.29 3.29C2.9 3.68 2.9 4.32 3.29 4.71L9 10.41V11C9 12.66 10.34 14 12 14C12.23 14 12.44 13.96 12.65 13.9L14.31 15.56C13.63 15.84 12.84 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C14.09 17.78 15.11 17.41 16 16.88L19.29 20.17C19.68 20.56 20.32 20.56 20.71 20.17C21.1 19.78 21.1 19.14 20.71 18.75L4.71 3.29Z"
                  fill="currentColor"
                />
                {/* Slash line */}
                <motion.line
                  x1="4"
                  y1="4"
                  x2="20"
                  y2="20"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  initial={{ pathLength: 0 }}
                  animate={{ pathLength: 1 }}
                  transition={{ duration: 0.3 }}
                />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Status indicator dot */}
      <div className={cn(
        "absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-background",
        enabled ? "bg-emerald-500" : "bg-red-500"
      )}>
        {enabled && !isToggling && (
          <div className="absolute inset-0 bg-emerald-500 rounded-full animate-ping" />
        )}
      </div>


      {/* Toggling indicator */}
      {isToggling && (
        <div className="absolute inset-0 rounded-full flex items-center justify-center bg-black/20">
          <span className="text-xs font-medium text-white">Switching...</span>
        </div>
      )}

      {showLabel && (
        <span className="sr-only">
          {enabled ? 'Mute microphone' : 'Unmute microphone'} ({role})
        </span>
      )}
    </motion.button>
  );
};


================================================
FILE: src/features/conversation/components/controls/ConversationControlBar.tsx
================================================
import React from 'react';
import { Circle, Pause, LogOut, Type, Eye, EyeOff, ArrowDown } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { cn } from '@/lib/utils';
import { ConversationDisplaySettings } from '../../types/conversation.types';
import { useConversationTheme } from '../../utils/conversationTheme';

interface ConversationControlBarProps {
  isMonitoring: boolean;
  displaySettings: ConversationDisplaySettings;
  role: 'primary' | 'secondary';
  onGoLive: () => void;
  onStopMonitoring: () => void;
  onLeaveRoom: () => void;
  onUpdateDisplaySettings: (updates: Partial<ConversationDisplaySettings>) => void;
}

export const ConversationControlBar: React.FC<ConversationControlBarProps> = ({
  isMonitoring,
  displaySettings,
  role,
  onGoLive,
  onStopMonitoring,
  onLeaveRoom,
  onUpdateDisplaySettings
}) => {
  const { t } = useTranslation();
  const { colors } = useConversationTheme();

  return (
    <div 
      className="flex-shrink-0 border-b px-4 py-3" 
      style={{ 
        backgroundColor: colors.background, 
        borderColor: colors.border 
      }}
    >
      <div className="flex items-center justify-between">
        {/* Action buttons */}
        <div className="flex items-center gap-2">
          {!isMonitoring ? (
            <>
              <button 
                data-testid="go-live-button"
                onClick={onGoLive} 
                className="px-4 py-2 rounded-md font-medium transition-colors flex items-center gap-2"
                style={{ 
                  backgroundColor: colors.buttonPrimary, 
                  color: colors.buttonPrimaryText 
                }}
              >
                <Circle className="h-4 w-4 fill-current" style={{ color: colors.error }} />
                <span>{t('mosqueAdmin.monitor.goLive')}</span>
              </button>
              <button
                data-testid="leave-room-button"
                onClick={onLeaveRoom}
                className="px-4 py-2 rounded-md font-medium transition-colors border flex items-center gap-2"
                style={{ 
                  backgroundColor: colors.buttonSecondary, 
                  color: colors.buttonSecondaryText, 
                  borderColor: colors.dropdownBorder 
                }}
              >
                <LogOut className="h-4 w-4" />
                <span>{t('mosqueAdmin.monitor.leaveRoom')}</span>
              </button>
            </>
          ) : (
            <button 
              data-testid="stop-monitoring-button"
              onClick={onStopMonitoring} 
              className="px-4 py-2 rounded-md font-medium transition-colors border flex items-center gap-2"
              style={{ 
                backgroundColor: colors.buttonSecondary, 
                color: colors.buttonSecondaryText, 
                borderColor: colors.dropdownBorder 
              }}
            >
              <Pause className="h-4 w-4" />
              <span>{t('mosqueAdmin.rooms.stopMonitoring')}</span>
            </button>
          )}
        </div>
        
        {/* Display Toggle Controls - Always visible */}
        <div className="flex items-center gap-2">
          {/* Transcription Toggle */}
          <button
            onClick={() => onUpdateDisplaySettings({ 
              showTranscription: !displaySettings.showTranscription 
            })}
            className="p-1.5 rounded-md transition-colors"
            style={{ 
              backgroundColor: 'transparent', 
              color: colors.accent 
            }}
            title={displaySettings.showTranscription ? 'Hide transcription' : 'Show transcription'}
          >
            {displaySettings.showTranscription ? <Eye className="h-3.5 w-3.5" /> : <EyeOff className="h-3.5 w-3.5" />}
          </button>

          {/* Inverted Stacking Toggle */}
          <button
            onClick={() => onUpdateDisplaySettings({ 
              invertedStacking: !displaySettings.invertedStacking 
            })}
            className="p-1.5 rounded-md transition-colors"
            style={{ 
              backgroundColor: 'transparent', 
              color: colors.accent 
            }}
            title={displaySettings.invertedStacking ? 'Stack cards bottom-up' : 'Stack cards top-down'}
          >
            <ArrowDown className={cn("h-3.5 w-3.5 transition-transform", displaySettings.invertedStacking && "rotate-180")} />
          </button>

          {/* Compact Font Toggle */}
          <button
            onClick={() => onUpdateDisplaySettings({ 
              compactFont: !displaySettings.compactFont 
            })}
            className="p-1.5 rounded-md transition-colors flex items-center gap-1"
            style={{ 
              backgroundColor: 'transparent', 
              color: colors.accent 
            }}
            title={displaySettings.compactFont ? 'Regular font size' : 'Compact font size'}
          >
            <Type className="h-3.5 w-3.5" />
            <span className="text-xs hidden sm:inline">{displaySettings.compactFont ? 'S' : 'L'}</span>
          </button>
        </div>
      </div>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/controls/index.ts
================================================
export { ConversationControlBar } from './ConversationControlBar';


================================================
FILE: src/features/conversation/components/display/ConversationDisplay.tsx
================================================
import React, { useImperativeHandle, forwardRef } from 'react';
import { TranscriptionView } from './TranscriptionView';
import { TranslationCards } from './TranslationCards';
import { ConversationSentence, ConversationDisplaySettings } from '../../types/conversation.types';
import { useTranslation } from '@/hooks/useTranslation';
import { useConversationTheme } from '../../utils/conversationTheme';

interface ConversationDisplayProps {
  sentences: ConversationSentence[];
  currentSentence: {
    id: string;
    transcription: string;
    timestamp: string;
    isComplete?: boolean;
  } | null;
  transcriptionLanguage?: string;
  translationLanguage?: string;
  displaySettings: ConversationDisplaySettings;
}

export interface ConversationDisplayHandle {
  addTranslation: (text: string, language: string, timestamp: string) => void;
  resetTranslations: () => void;
}

export const ConversationDisplay = forwardRef<ConversationDisplayHandle, ConversationDisplayProps>(({
  sentences,
  currentSentence,
  transcriptionLanguage = 'ar',
  translationLanguage = 'en',
  displaySettings
}, ref) => {
  const { t } = useTranslation();
  const { theme, colors } = useConversationTheme();
  const [translationLines, setTranslationLines] = React.useState<Array<{
    id: string;
    text: string;
    timestamp: number;
  }>>([]);
  const [activeLineId, setActiveLineId] = React.useState<string | null>(null);

  // Expose methods to parent through ref
  useImperativeHandle(ref, () => ({
    addTranslation: (text: string, language: string, timestamp: string) => {
      const newLine = {
        id: `line-${timestamp}`,
        text: text,
        timestamp: new Date(timestamp).getTime(),
      };
      
      setTranslationLines(prev => {
        const updated = [...prev, newLine];
        // Keep only the last 15 lines for display
        const finalLines = updated.slice(-15);
        setActiveLineId(newLine.id);
        return finalLines;
      });
    },
    resetTranslations: () => {
      setTranslationLines([]);
      setActiveLineId(null);
    }
  }), []);

  const isDark = theme === 'dark';

  return (
    <div className="h-full flex flex-col" style={{ backgroundColor: colors.background }}>
      {/* Live Transcription Display */}
      {displaySettings.showTranscription && (
        <TranscriptionView
          sentences={sentences}
          currentSentence={currentSentence}
          transcriptionLanguage={transcriptionLanguage}
          isDark={isDark}
        />
      )}

      {/* Translation Cards */}
      <TranslationCards
        lines={translationLines}
        activeLineId={activeLineId}
        translationLanguage={translationLanguage}
        isDark={isDark}
        viewMode={displaySettings.viewMode}
        compactFont={displaySettings.compactFont}
        invertedStacking={displaySettings.invertedStacking}
      />
    </div>
  );
});

ConversationDisplay.displayName = 'ConversationDisplay';


================================================
FILE: src/features/conversation/components/display/index.ts
================================================
export { ConversationDisplay } from './ConversationDisplay';
export type { ConversationDisplayHandle } from './ConversationDisplay';
export { TranscriptionView } from './TranscriptionView';
export { TranslationCards } from './TranslationCards';
export { SpeakerOverlay } from './SpeakerOverlay';


================================================
FILE: src/features/conversation/components/display/SpeakerOverlay.tsx
================================================
import React from 'react';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';
import { Mic, MicOff } from 'lucide-react';
import { ConversationRole } from '../../types/conversation.types';
import { useConversationTheme } from '../../utils/conversationTheme';

interface SpeakerOverlayProps {
  role: ConversationRole;
  isMuted: boolean;
  isConnected: boolean;
  isToggling?: boolean;
  transcriptionLanguage?: string;
  translationLanguage?: string;
  className?: string;
  onToggleMic?: () => void;
}

export const SpeakerOverlay: React.FC<SpeakerOverlayProps> = ({
  role,
  isMuted,
  isConnected,
  isToggling = false,
  transcriptionLanguage,
  translationLanguage,
  className,
  onToggleMic
}) => {
  const { colors } = useConversationTheme();
  // In this system: UNMUTED = SPEAKING
  const isSpeaking = !isMuted;
  
  if (!isConnected || !isSpeaking) {
    return null;
  }
  
  // Map language codes to readable names
  const getLanguageName = (langCode?: string) => {
    const languages: Record<string, string> = {
      'en': 'English',
      'ar': 'Arabic',
      'nl': 'Dutch',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'zh': 'Chinese',
      'ja': 'Japanese',
      'ko': 'Korean'
    };
    return langCode ? languages[langCode] || langCode.toUpperCase() : 'the selected language';
  };

  return (
    <AnimatePresence>
      {isSpeaking && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
          className={cn(
            "absolute top-[58px] inset-x-0 bottom-0 z-20 backdrop-blur-sm flex items-center justify-center",
            className
          )}
          style={{
            backgroundColor: `${colors.overlayBg}D9`
          }}
        >
          <div 
            className="rounded-2xl p-8 shadow-2xl backdrop-blur-sm"
            style={{
              backgroundColor: colors.overlayBg,
              border: `1px solid ${colors.border}`
            }}
          >
            <div className="text-center space-y-4">
              <motion.div
                animate={{ scale: [1, 1.1, 1] }}
                transition={{ duration: 2, repeat: Infinity }}
                className="inline-flex items-center justify-center w-20 h-20 rounded-full shadow-lg"
                style={{
                  backgroundColor: `${colors.success}33`
                }}
              >
                <Mic className="w-10 h-10 drop-shadow-md" style={{ color: colors.success }} />
              </motion.div>
              <div className="space-y-2">
                <h2 className="text-2xl font-semibold drop-shadow-md" style={{ color: colors.text }}>
                  You are speaking ({getLanguageName(transcriptionLanguage)})
                </h2>
                <p className="text-sm drop-shadow-sm" style={{ color: colors.mutedText }}>
                  Your words are being translated to {getLanguageName(translationLanguage)}
                </p>
              </div>
              {onToggleMic && (
                <motion.div
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: 0.3 }}
                >
                  <button
                    onClick={onToggleMic}
                    disabled={isToggling}
                    className="mt-6 font-medium px-8 py-3 rounded-full shadow-lg hover:shadow-xl transition-all duration-200 flex items-center disabled:opacity-50 disabled:cursor-not-allowed"
                    style={{
                      backgroundColor: isToggling ? colors.mutedText : colors.success,
                      color: colors.buttonPrimaryText
                    }}
                    onMouseEnter={(e) => {
                      if (!isToggling) e.currentTarget.style.opacity = '0.9';
                    }}
                    onMouseLeave={(e) => {
                      if (!isToggling) e.currentTarget.style.opacity = '1';
                    }}
                  >
                    <MicOff className="w-5 h-5 mr-2" />
                    {isToggling ? 'Switching...' : 'Pass the Mic'}
                  </button>
                </motion.div>
              )}
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};


================================================
FILE: src/features/conversation/components/display/TranscriptionView.tsx
================================================
import React, { useRef, useEffect, useState } from 'react';
import { useTranslation } from '@/hooks/useTranslation';
import { ConversationSentence } from '../../types/conversation.types';
import { useConversationTheme } from '../../utils/conversationTheme';

interface TranscriptionViewProps {
  sentences: ConversationSentence[];
  currentSentence: {
    id: string;
    transcription: string;
    timestamp: string;
    isComplete?: boolean;
  } | null;
  transcriptionLanguage: string;
  isDark: boolean;
}

export const TranscriptionView: React.FC<TranscriptionViewProps> = ({
  sentences,
  currentSentence,
  transcriptionLanguage,
  isDark
}) => {
  const { t } = useTranslation();
  const { colors } = useConversationTheme();
  const [transcriptionText, setTranscriptionText] = useState<string>('');
  const containerRef = useRef<HTMLDivElement>(null);
  const textRef = useRef<HTMLDivElement>(null);
  const transcriptionBufferRef = useRef<{ id: string; text: string }[]>([]);
  const updateTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Helper function to determine if language is RTL
  const isRTL = (lang: string) => {
    const rtlLanguages = ['ar', 'he', 'fa', 'ur', 'yi', 'ji', 'iw', 'ku', 'ps', 'sd', 'ug'];
    return rtlLanguages.includes(lang.toLowerCase());
  };

  // Buffered transcription updates
  const updateTranscriptionText = () => {
    const texts = transcriptionBufferRef.current.map(item => item.text);
    const fullText = texts.join(' ');
    setTranscriptionText(fullText);
  };

  // Update buffer when current sentence changes
  useEffect(() => {
    if (currentSentence && currentSentence.transcription) {
      if (updateTimerRef.current) {
        clearTimeout(updateTimerRef.current);
      }
      
      updateTimerRef.current = setTimeout(() => {
        const existingIndex = transcriptionBufferRef.current.findIndex(
          item => item.id === currentSentence.id
        );
        
        if (existingIndex >= 0) {
          transcriptionBufferRef.current[existingIndex].text = currentSentence.transcription;
        } else {
          transcriptionBufferRef.current.push({
            id: currentSentence.id,
            text: currentSentence.transcription
          });
        }
        
        updateTranscriptionText();
      }, 50);
    }
    
    return () => {
      if (updateTimerRef.current) {
        clearTimeout(updateTimerRef.current);
      }
    };
  }, [currentSentence]);

  // Add completed sentences to buffer
  useEffect(() => {
    sentences.forEach(sentence => {
      if (sentence.isComplete && sentence.transcription) {
        const existingIndex = transcriptionBufferRef.current.findIndex(
          item => item.id === sentence.id
        );
        
        if (existingIndex >= 0) {
          transcriptionBufferRef.current[existingIndex].text = sentence.transcription;
        } else {
          transcriptionBufferRef.current.push({
            id: sentence.id,
            text: sentence.transcription
          });
        }
      }
    });
    updateTranscriptionText();
  }, [sentences]);

  // New approach: Use transform to move text
  useEffect(() => {
    if (!containerRef.current || !textRef.current) return;

    const container = containerRef.current;
    const text = textRef.current;
    
    // Use requestAnimationFrame for smooth updates
    requestAnimationFrame(() => {
      const containerWidth = container.offsetWidth;
      const textWidth = text.scrollWidth;
      
      if (textWidth > containerWidth) {
        // Text overflows, need to scroll
        if (isRTL(transcriptionLanguage)) {
          // For RTL: Move text to the right to show the left (newest) part
          const offset = textWidth - containerWidth;
          text.style.transform = `translateX(${offset}px)`;
        } else {
          // For LTR: Move text to the left to show the right (newest) part
          const offset = containerWidth - textWidth;
          text.style.transform = `translateX(${offset}px)`;
        }
      } else {
        // No overflow, reset transform
        text.style.transform = 'translateX(0)';
      }
    });
  }, [transcriptionText, transcriptionLanguage]);

  return (
    <div className="border-b" style={{ backgroundColor: colors.background, borderColor: colors.border }}>
      <div className="w-full px-6 py-4">
        <div 
          ref={containerRef}
          className="relative overflow-hidden"
          style={{ height: '1.75rem' }}
        >
          <div 
            ref={textRef}
            className="absolute whitespace-nowrap transition-transform duration-300 ease-out"
            dir={isRTL(transcriptionLanguage) ? 'rtl' : 'ltr'}
            style={{
              [isRTL(transcriptionLanguage) ? 'right' : 'left']: 0,
              top: 0,
              lineHeight: '1.75rem'
            }}
          >
            {transcriptionText ? (
              <span 
                style={{ 
                  color: colors.text,
                  fontSize: '1.125rem',
                  fontFamily: isRTL(transcriptionLanguage) ? "'Noto Sans Arabic', system-ui, sans-serif" : 'inherit'
                }}
              >
                {transcriptionText}
              </span>
            ) : (
              <span style={{ color: colors.mutedText2, fontSize: '1.125rem' }}>
                {t('mosqueAdmin.monitor.waitingForTranscription')}
              </span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/display/TranslationCards.tsx
================================================
import React, { useRef, useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ArrowDown, Circle } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';

interface TranslationLine {
  id: string;
  text: string;
  timestamp: number;
}

interface TranslationCardsProps {
  lines: TranslationLine[];
  activeLineId: string | null;
  translationLanguage: string;
  isDark: boolean;
  viewMode: 'card' | 'typewriter';
  compactFont: boolean;
  invertedStacking: boolean;
}

export const TranslationCards: React.FC<TranslationCardsProps> = ({
  lines,
  activeLineId,
  translationLanguage,
  isDark,
  viewMode,
  compactFont,
  invertedStacking
}) => {
  const { t } = useTranslation();
  const [showScrollIndicator, setShowScrollIndicator] = useState(false);
  const modernTranslationRef = useRef<HTMLDivElement>(null);

  // Helper function to determine if language is RTL
  const isRTL = (lang: string) => {
    const rtlLanguages = ['ar', 'he', 'fa', 'ur', 'yi', 'ji', 'iw', 'ku', 'ps', 'sd', 'ug'];
    return rtlLanguages.includes(lang.toLowerCase());
  };

  // Define colors based on theme
  const colors = {
    background: isDark ? '#0a1212' : '#fdf1f4',
    text: isDark ? '#e8e3d3' : '#0a3a3a',
    mutedText2: isDark ? 'rgba(232, 227, 211, 0.7)' : 'rgba(10, 58, 58, 0.7)',
    border: isDark ? 'rgba(232, 227, 211, 0.1)' : 'rgba(10, 58, 58, 0.1)',
    accent: '#d4a574',
    cardBg: isDark ? 'rgba(232, 227, 211, 0.08)' : 'rgba(255, 255, 255, 0.9)',
    cardBgInactive: isDark ? 'rgba(232, 227, 211, 0.04)' : 'rgba(255, 255, 255, 0.6)',
    cardBorder: isDark ? 'rgba(212, 165, 116, 0.3)' : 'rgba(212, 165, 116, 0.3)',
  };

  // Auto-scroll based on stacking mode
  useEffect(() => {
    if (modernTranslationRef.current) {
      if (invertedStacking) {
        modernTranslationRef.current.scrollTop = 0; // Scroll to top for inverted stacking
      } else {
        modernTranslationRef.current.scrollTop = modernTranslationRef.current.scrollHeight; // Scroll to bottom for normal
      }
    }
  }, [lines, invertedStacking]);

  // Check scroll position based on stacking mode
  const checkScrollPosition = () => {
    const container = modernTranslationRef.current;
    if (container) {
      if (invertedStacking) {
        const isAtTop = container.scrollTop < 50;
        setShowScrollIndicator(!isAtTop && lines.length > 0);
      } else {
        const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 50;
        setShowScrollIndicator(!isAtBottom && lines.length > 0);
      }
    }
  };

  // Check scroll position on resize and content changes
  useEffect(() => {
    checkScrollPosition();
    window.addEventListener('resize', checkScrollPosition);
    return () => window.removeEventListener('resize', checkScrollPosition);
  }, [lines, invertedStacking]);

  // Scroll to latest position based on stacking mode
  const scrollToLatest = () => {
    const container = modernTranslationRef.current;
    if (container) {
      if (invertedStacking) {
        container.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top for inverted
      } else {
        container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' }); // Scroll to bottom for normal
      }
    }
  };

  return (
    <div className="flex-1 relative overflow-hidden">
      {/* Translation Display */}
      <div 
        ref={modernTranslationRef} 
        className="h-full overflow-y-auto px-6 pb-24 space-y-4 scroll-smooth scrollbar-hide"
        onScroll={checkScrollPosition}
        style={{
          overscrollBehavior: 'contain',
          WebkitOverflowScrolling: 'touch'
        }}
      >
        <AnimatePresence mode="popLayout">
          {lines.length > 0 ? (
            (invertedStacking ? [...lines].reverse() : lines).map((line, index) => {
              const isLatest = line.id === activeLineId;
              
              return (
                <motion.div
                  key={line.id}
                  layout
                  initial={{ opacity: 0, y: invertedStacking ? -20 : 20, scale: 0.95 }}
                  animate={{ 
                    opacity: isLatest ? 1 : 0.7,
                    y: 0,
                    scale: 1
                  }}
                  exit={{ opacity: 0, y: invertedStacking ? 20 : -20, scale: 0.95 }}
                  transition={{ 
                    type: "spring",
                    stiffness: 500,
                    damping: 30
                  }}
                  className="relative"
                >
                  <div 
                    className="rounded-2xl p-6 backdrop-blur-sm transition-all duration-300 border"
                    style={{ 
                      backgroundColor: isLatest ? colors.cardBg : colors.cardBgInactive,
                      borderColor: isLatest ? colors.cardBorder : colors.border,
                      boxShadow: isLatest ? '0 4px 20px rgba(212, 165, 116, 0.2)' : 'none'
                    }}
                  >
                    {/* Golden Indicator Bar */}
                    {isLatest && (
                      <motion.div
                        className="absolute left-0 top-0 bottom-0 w-1 rounded-l-2xl"
                        style={{ backgroundColor: colors.accent }}
                        initial={{ scaleY: 0 }}
                        animate={{ scaleY: 1 }}
                        transition={{ delay: 0.2, duration: 0.3 }}
                      />
                    )}
                    
                    {/* Translation Text */}
                    <p 
                      className={`leading-relaxed ${
                        compactFont ? 'text-base sm:text-lg' : 'text-lg sm:text-xl lg:text-2xl'
                      } ${
                        isRTL(translationLanguage) ? 'text-right' : 'text-left'
                      }`}
                      style={{ 
                        color: colors.text,
                        opacity: isLatest ? 1 : 0.8
                      }}
                      dir={isRTL(translationLanguage) ? 'rtl' : 'ltr'}
                    >
                      {line.text}
                    </p>
                  </div>
                </motion.div>
              );
            })
          ) : (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="flex items-center justify-center h-full"
            >
              <div className="text-center">
                <motion.div
                  animate={{ scale: [1, 1.2, 1] }}
                  transition={{ duration: 2, repeat: Infinity }}
                  className="w-16 h-16 mx-auto mb-4 rounded-full"
                  style={{ backgroundColor: 'rgba(212, 165, 116, 0.2)' }}
                >
                  <div className="w-full h-full rounded-full flex items-center justify-center" style={{ backgroundColor: 'rgba(212, 165, 116, 0.4)' }}>
                    <Circle className="w-8 h-8" style={{ color: '#d4a574' }} />
                  </div>
                </motion.div>
                <p style={{ color: colors.mutedText2 }}>
                  {t('mosqueAdmin.monitor.waitingForTranslation')}
                </p>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Scroll Indicator */}
      <AnimatePresence>
        {showScrollIndicator && (
          <motion.button
            initial={{ opacity: 0, y: invertedStacking ? -20 : 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: invertedStacking ? -20 : 20 }}
            onClick={scrollToLatest}
            className={`absolute ${invertedStacking ? 'top-6' : 'bottom-6'} right-6 p-3 rounded-full shadow-lg transition-all z-20`}
            style={{ backgroundColor: colors.accent, color: colors.background }}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.95 }}
          >
            <ArrowDown className={`w-5 h-5 ${invertedStacking ? 'rotate-180' : ''}`} />
          </motion.button>
        )}
      </AnimatePresence>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/footer/ConnectedControls.tsx
================================================
import React from 'react';
import { ConversationUnifiedMicToggle } from '../ConversationUnifiedMicToggle';
import { ConversationMediaDeviceMenu } from '../ConversationMediaDeviceMenu';
import { ConversationDisconnectButton } from '../ConversationDisconnectButton';
import { ConversationParticipantInfo } from '../ConversationParticipantInfo';
import { motion } from 'framer-motion';
import { useConversationTheme } from '../../utils/conversationTheme';
import { useTranslation } from '@/hooks/useTranslation';

interface ConnectedControlsProps {
  role: 'primary' | 'secondary';
}

export const ConnectedControls: React.FC<ConnectedControlsProps> = ({ 
  role
}) => {
  const { colors } = useConversationTheme();
  const { t } = useTranslation();

  return (
    <div className="container mx-auto px-2 sm:px-4 py-3">
      <div className="flex items-center justify-between gap-2 sm:gap-4">
        {/* Left Section: Live Status (Always Visible) */}
        <div className="flex items-center gap-2 sm:gap-4">
          <motion.div
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            className="flex items-center gap-1 sm:gap-2"
          >
            <div className="relative">
              <div className="w-2 h-2 sm:w-3 sm:h-3 rounded-full" style={{ backgroundColor: colors.error }} />
              <div className="absolute inset-0 w-2 h-2 sm:w-3 sm:h-3 rounded-full animate-ping" style={{ backgroundColor: colors.error }} />
            </div>
            <span className="text-xs sm:text-sm font-bold uppercase" style={{ color: colors.error }}>{t('connectedControls.live')}</span>
          </motion.div>
          
          <ConversationParticipantInfo variant="compact" />
        </div>

        {/* Center Section: Controls */}
        <div className="flex items-center gap-2 sm:gap-4">
          <ConversationUnifiedMicToggle role={role} />
          <ConversationMediaDeviceMenu
            kind="audioinput"
            variant="compact"
            className="min-w-0 flex-1 sm:flex-initial"
          />
        </div>

        {/* Right Section: End Button (Always Visible) */}
        <motion.div
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          className="shrink-0"
        >
          <ConversationDisconnectButton
            variant="destructive"
            icon="phone"
            customLabel={t('connectedControls.end')}
            className="h-10 sm:h-12 px-3 sm:px-6 text-xs sm:text-base font-semibold"
            style={{
              background: `linear-gradient(to right, ${colors.error}33, ${colors.error}33)`,
              borderColor: `${colors.error}4D`,
              color: colors.error,
              border: '1px solid'
            }}
          />
        </motion.div>
      </div>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/footer/ConversationFooter.tsx
================================================
import React from 'react';
import { LiveKitRoom, RoomAudioRenderer } from '@livekit/components-react';
import { motion, AnimatePresence } from 'framer-motion';
import { ConnectedControls } from './ConnectedControls';
import { DisconnectedControls } from './DisconnectedControls';
import { LiveKitCleanupHandler } from '@/features/livekit/components/LiveKitCleanupHandler';
import { useConversationTheme } from '../../utils/conversationTheme';

interface ConversationFooterProps {
  token: string | null;
  serverUrl: string;
  loading: boolean;
  error: string | null;
  roomName: string | null;
  roomTitle: string | null;
  onConnect: () => void;
  onDisconnect: () => void;
  isConnecting: boolean;
  sessionId?: string | null;
  roomId?: number;
  role: 'primary' | 'secondary';
  isVisible?: boolean;
}

// Memoized LiveKit connection wrapper
const StableLiveKitConnection = React.memo<{
  token: string;
  serverUrl: string;
  onDisconnected: (reason?: any) => void;
  onConnected: () => void;
  onError: (error: any) => void;
  sessionId?: string | null;
  roomId?: number;
  children: React.ReactNode;
}>(({ token, serverUrl, onDisconnected, onConnected, onError, sessionId, roomId, children }) => {
  const renderCount = React.useRef(0);
  const hasConnectedRef = React.useRef(false);
  
  React.useEffect(() => {
    renderCount.current++;
    console.log(`[StableLiveKitConnection] Render #${renderCount.current}, token: ${token.substring(0, 20)}...`);
  });

  const handleConnected = () => {
    if (!hasConnectedRef.current) {
      console.log('[StableLiveKitConnection] Connected to LiveKit');
      hasConnectedRef.current = true;
      onConnected();
    }
  };

  const handleDisconnected = (reason?: any) => {
    console.log('[StableLiveKitConnection] Disconnected from LiveKit', reason);
    hasConnectedRef.current = false;
    onDisconnected(reason);
  };

  return (
    <LiveKitRoom
      video={false}
      audio={true}
      token={token}
      serverUrl={serverUrl}
      onDisconnected={handleDisconnected}
      onConnected={handleConnected}
      onError={onError}
      className="livekit-room"
      connect={true}
    >
      <RoomAudioRenderer />
      {sessionId && roomId && (
        <LiveKitCleanupHandler 
          sessionId={sessionId} 
          roomId={roomId} 
          onCleanupRequested={handleDisconnected}
        />
      )}
      {children}
    </LiveKitRoom>
  );
}, (prevProps, nextProps) => {
  // Only re-render if connection params change
  return prevProps.token === nextProps.token && 
         prevProps.serverUrl === nextProps.serverUrl &&
         prevProps.sessionId === nextProps.sessionId &&
         prevProps.roomId === nextProps.roomId;
});

StableLiveKitConnection.displayName = 'StableLiveKitConnection';

export const ConversationFooter: React.FC<ConversationFooterProps> = ({
  token,
  serverUrl,
  loading,
  error,
  roomName,
  roomTitle,
  onConnect,
  onDisconnect,
  isConnecting,
  sessionId,
  roomId,
  role,
  isVisible = true
}) => {
  const { colors } = useConversationTheme();
  const footerVariants = {
    hidden: { y: '100%' },
    visible: { 
      y: 0,
      transition: {
        type: 'spring' as const,
        damping: 30,
        stiffness: 400,
        mass: 0.8
      }
    },
    exit: { 
      y: '100%',
      transition: {
        type: 'spring' as const,
        damping: 30,
        stiffness: 400,
        mass: 0.8
      }
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <>
          {!token ? (
            <motion.div
              className="fixed bottom-0 left-0 right-0 z-50"
              variants={footerVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
            >
              <div className="backdrop-blur-xl shadow-2xl" style={{ backgroundColor: colors.cardBg }}>
                <DisconnectedControls
                  roomTitle={roomTitle}
                  error={error}
                  isConnecting={isConnecting}
                  loading={loading}
                  onConnect={onConnect}
                />
              </div>
            </motion.div>
          ) : (
            <motion.div
              className="fixed bottom-0 left-0 right-0 z-50"
              variants={footerVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
            >
              <div className="backdrop-blur-xl shadow-2xl" style={{ backgroundColor: colors.cardBg }}>
                <StableLiveKitConnection
                  token={token}
                  serverUrl={serverUrl}
                  onDisconnected={(reason) => {
                    console.log(`[ConversationFooter] LiveKit disconnected, reason:`, reason);
                    onDisconnect();
                  }}
                  onConnected={() => {
                    console.log(`[ConversationFooter] LiveKit connected successfully`);
                  }}
                  onError={(error) => {
                    console.error(`[ConversationFooter] LiveKit error:`, error);
                  }}
                  sessionId={sessionId}
                  roomId={roomId}
                >
                  <ConnectedControls 
                    role={role}
                  />
                </StableLiveKitConnection>
              </div>
            </motion.div>
          )}
        </>
      )}
    </AnimatePresence>
  );
};


================================================
FILE: src/features/conversation/components/footer/DisconnectedControls.tsx
================================================
import React from 'react';
import { Mic, Loader2, Radio, AlertCircle } from 'lucide-react';
import { motion } from 'framer-motion';
import { useConversationTheme } from '../../utils/conversationTheme';
import { useTranslation } from '@/hooks/useTranslation';

interface DisconnectedControlsProps {
  roomTitle: string | null;
  error: string | null;
  isConnecting: boolean;
  loading: boolean;
  onConnect: () => void;
}

export const DisconnectedControls: React.FC<DisconnectedControlsProps> = ({
  roomTitle,
  error,
  isConnecting,
  loading,
  onConnect
}) => {
  const { colors } = useConversationTheme();
  const { t } = useTranslation();
  return (
    <div className="container mx-auto px-4 py-3">
      {/* Error Message */}
      {error && (
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className="mb-3 p-3 rounded-md flex items-center gap-2 text-sm"
          style={{
            backgroundColor: `${colors.error}1A`,
            borderColor: `${colors.error}33`,
            border: '1px solid',
            color: colors.error
          }}
        >
          <AlertCircle className="h-4 w-4 shrink-0" />
          {error}
        </motion.div>
      )}
      
      <div className="flex items-center justify-between gap-4">
        {/* Left Section: Status */}
        <div className="flex items-center gap-3">
          <div 
            className="w-10 h-10 rounded-full flex items-center justify-center"
            style={{ 
              backgroundColor: `${colors.accent}1A` 
            }}
          >
            <Mic className="h-5 w-5" style={{ color: colors.accent }} />
          </div>
          <div className="hidden sm:block">
            <p className="text-sm font-semibold" style={{ color: colors.text }}>{t('disconnectedControls.readyToBroadcast')}</p>
            <p className="text-xs" style={{ color: colors.mutedText }}>{roomTitle || t('disconnectedControls.audioSession')}</p>
          </div>
        </div>

        {/* Center Section: Connect Button */}
        <button
          onClick={onConnect}
          disabled={isConnecting || loading}
          className="min-w-[200px] h-12 px-6 rounded-md text-base font-semibold shadow-lg hover:shadow-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
          style={{
            backgroundColor: colors.buttonPrimary,
            color: colors.buttonPrimaryText
          }}
          onMouseEnter={(e) => {
            if (!e.currentTarget.disabled) {
              e.currentTarget.style.backgroundColor = colors.buttonHover;
            }
          }}
          onMouseLeave={(e) => {
            if (!e.currentTarget.disabled) {
              e.currentTarget.style.backgroundColor = colors.buttonPrimary;
            }
          }}
        >
          {isConnecting || loading ? (
            <>
              <Loader2 className="mr-2 h-5 w-5 animate-spin" />
              {t('disconnectedControls.connecting')}
            </>
          ) : (
            <>
              <Radio className="mr-2 h-5 w-5" />
              {t('disconnectedControls.startBroadcasting')}
            </>
          )}
        </button>

        {/* Right Section: Empty for balance */}
        <div className="w-10" />
      </div>
    </div>
  );
};


================================================
FILE: src/features/conversation/components/footer/index.ts
================================================
export { ConversationFooter } from './ConversationFooter';
export { ConnectedControls } from './ConnectedControls';
export { DisconnectedControls } from './DisconnectedControls';


================================================
FILE: src/features/conversation/hooks/index.ts
================================================
export { useWindowCoordination } from './useWindowCoordination';
export { useLiveKitConnection } from './useLiveKitConnection';
export { useConversationSession } from './useConversationSession';
export { useConversationState } from './useConversationState';
export { useConversationCoordinator } from './useConversationCoordinator'; // Keep existing hook for now
export { usePushToTalk } from './usePushToTalk';


================================================
FILE: src/features/conversation/hooks/useConversationCoordinator.ts
================================================
import { useEffect, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';

interface UseConversationCoordinatorProps {
  roomId: number;
  role: 'primary' | 'secondary';
  onGoLiveCommand?: () => void;
  onStopCommand?: () => void;
  onEndCommand?: () => void;
  onLeaveRoomCommand?: () => void;
  onMicToggleCommand?: (isMuted: boolean) => void;
  onStartBroadcastCommand?: () => void;
}

/**
 * Coordinates actions between primary and secondary conversation windows
 * Uses Supabase broadcast to sync actions across windows
 */
export const useConversationCoordinator = ({
  roomId,
  role,
  onGoLiveCommand,
  onStopCommand,
  onEndCommand,
  onLeaveRoomCommand,
  onMicToggleCommand,
  onStartBroadcastCommand
}: UseConversationCoordinatorProps) => {
  const channelRef = useRef<any>(null);
  const isSubscribed = useRef(false);

  useEffect(() => {
    // Use a consistent channel name for conversation mode
    const channelName = `conversation_mode_coordinator`;
    
    console.log(`[${role}] Connecting to channel: ${channelName}`);
    
    const setupChannel = async () => {
      try {
        channelRef.current = supabase.channel(channelName, {
          config: {
            broadcast: { 
              self: false, // Don't receive own messages
              ack: true    // Wait for acknowledgment
            },
          },
        });

        channelRef.current
          .on('broadcast', { event: 'go_live' }, (payload: any) => {
            console.log(`[${role}] Received go live broadcast:`, payload);
            if (payload.payload?.from !== role) {
              console.log(`[${role}] Executing go live command from ${payload.payload.from}`);
              // Small delay to ensure DOM is ready
              setTimeout(() => {
                onGoLiveCommand?.();
              }, 100);
            }
          })
          .on('broadcast', { event: 'stop_monitoring' }, (payload: any) => {
            console.log(`[${role}] Received stop broadcast:`, payload);
            if (payload.payload?.from !== role) {
              console.log(`[${role}] Executing stop command from ${payload.payload.from}`);
              setTimeout(() => {
                onStopCommand?.();
              }, 100);
            }
          })
          .on('broadcast', { event: 'end_room' }, (payload: any) => {
            console.log(`[${role}] Received end broadcast:`, payload);
            if (payload.payload?.from !== role) {
              console.log(`[${role}] Executing end command from ${payload.payload.from}`);
              setTimeout(() => {
                onEndCommand?.();
              }, 100);
            }
          })
          .on('broadcast', { event: 'leave_room' }, (payload: any) => {
            console.log(`[${role}] Received leave room broadcast:`, payload);
            if (payload.payload?.from !== role) {
              console.log(`[${role}] Executing leave room command from ${payload.payload.from}`);
              setTimeout(() => {
                onLeaveRoomCommand?.();
              }, 100);
            }
          })
          .on('broadcast', { event: 'mic_toggle' }, (payload: any) => {
            console.log(`[${role}] Received mic toggle broadcast:`, payload);
            if (payload.payload?.from !== role) {
              const otherIsMuted = payload.payload.isMuted;
              console.log(`[${role}] Other speaker is ${otherIsMuted ? 'muted' : 'unmuted'}, we should be ${otherIsMuted ? 'unmuted' : 'muted'}`);
              setTimeout(() => {
                // Inverse microphone logic: when one speaker is muted, the other should be unmuted
                // This creates a push-to-talk style conversation where only one person can speak at a time
                onMicToggleCommand?.(!otherIsMuted);
              }, 100);
            }
          })
          .on('broadcast', { event: 'start_broadcast' }, (payload: any) => {
            console.log(`[${role}] Received start broadcast:`, payload);
            if (payload.payload?.from !== role) {
              console.log(`[${role}] Executing start broadcast command from ${payload.payload.from}`)
              setTimeout(() => {
                onStartBroadcastCommand?.();
              }, 100);
            }
          });

        const { error } = await channelRef.current.subscribe();
        if (error) {
          console.error(`[${role}] Channel subscription error:`, error);
        } else {
          isSubscribed.current = true;
          console.log(`[${role}] Successfully subscribed to channel`);
        }
      } catch (err) {
        console.error(`[${role}] Failed to setup channel:`, err);
      }
    };

    setupChannel();

    return () => {
      console.log(`[${role}] Unsubscribing from channel`);
      if (channelRef.current) {
        channelRef.current.unsubscribe();
      }
      isSubscribed.current = false;
    };
  }, [role, onGoLiveCommand, onStopCommand, onEndCommand, onLeaveRoomCommand, onMicToggleCommand, onStartBroadcastCommand]);

  // Generic broadcast function to reduce duplication
  const broadcastCommand = async (eventName: string, commandName: string, extraPayload?: any) => {
    console.log(`[${role}] Broadcasting ${commandName}`);
    
    // Wait a bit if not subscribed yet
    if (!isSubscribed.current) {
      console.log(`[${role}] Waiting for channel subscription...`);
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    if (channelRef.current && isSubscribed.current) {
      try {
        const result = await channelRef.current.send({
          type: 'broadcast',
          event: eventName,
          payload: { 
            from: role, 
            roomId, 
            timestamp: Date.now(),
            ...extraPayload 
          }
        });
        console.log(`[${role}] Broadcast ${commandName} result:`, result);
      } catch (error) {
        console.error(`[${role}] Failed to broadcast ${commandName}:`, error);
      }
    } else {
      console.error(`[${role}] Channel not ready for broadcast (subscribed: ${isSubscribed.current})`);
    }
  };

  const broadcastGoLive = async () => {
    await broadcastCommand('go_live', 'go live command');
  };

  const broadcastStop = async () => {
    await broadcastCommand('stop_monitoring', 'stop command');
  };

  const broadcastEnd = async () => {
    await broadcastCommand('end_room', 'end command');
  };

  const broadcastLeaveRoom = async () => {
    await broadcastCommand('leave_room', 'leave room command');
  };

  const broadcastMicToggle = async (isMuted: boolean) => {
    await broadcastCommand('mic_toggle', 'mic toggle command', { isMuted });
  };

  const broadcastStartBroadcast = async () => {
    await broadcastCommand('start_broadcast', 'start broadcast command');
  };

  return {
    broadcastGoLive,
    broadcastStop,
    broadcastEnd,
    broadcastLeaveRoom,
    broadcastMicToggle,
    broadcastStartBroadcast
  };
};


================================================
FILE: src/features/conversation/hooks/useConversationSession.ts
================================================
import { useState, useCallback, useRef, useEffect } from 'react';
import { SessionManager } from '../services/sessionManager';
import { Room } from '../types/conversation.types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

interface UseConversationSessionProps {
  room: Room;
  mosqueId: number;
  enabled?: boolean;
}

export const useConversationSession = ({ room, mosqueId, enabled = false }: UseConversationSessionProps) => {
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [isActive, setIsActive] = useState(false);
  const [transcriptCount, setTranscriptCount] = useState(0);
  
  const { toast } = useToast();
  const { t } = useTranslation();
  const managerRef = useRef<SessionManager>(new SessionManager());
  const unsubscribeRef = useRef<(() => void) | null>(null);

  // Subscribe to transcript updates when session is active
  useEffect(() => {
    if (sessionId && isActive && enabled) {
      unsubscribeRef.current = managerRef.current.subscribeToTranscripts(
        sessionId,
        () => setTranscriptCount(prev => prev + 1)
      );
    }

    return () => {
      unsubscribeRef.current?.();
      unsubscribeRef.current = null;
    };
  }, [sessionId, isActive, enabled]);

  const startSession = useCallback(async (): Promise<string | null> => {
    try {
      const newSessionId = await managerRef.current.createSession(room.id, mosqueId);
      
      if (!newSessionId) {
        toast({
          title: t('common.error'),
          description: t('technical.errors.createFailed'),
          variant: "destructive"
        });
        return null;
      }

      setSessionId(newSessionId);
      setIsActive(true);
      setTranscriptCount(0);
      
      return newSessionId;
    } catch (err) {
      console.error('Failed to start session:', err);
      toast({
        title: t('common.error'),
        description: t('technical.errors.createFailed'),
        variant: "destructive"
      });
      return null;
    }
  }, [room.id, mosqueId, toast, t]);

  const endSession = useCallback(async (skipWait: boolean = false) => {
    if (!sessionId) return;

    try {
      await managerRef.current.endSession(sessionId, room.id, room, skipWait);
      
      setSessionId(null);
      setIsActive(false);
      
      toast({
        title: t('mosqueAdmin.monitor.stopMonitoring'),
        description: `Session ended with ${transcriptCount} transcript segments`,
      });
    } catch (err) {
      console.error('Failed to end session:', err);
      toast({
        title: t('common.error'),
        description: 'Failed to end session properly',
        variant: "destructive"
      });
    }
  }, [sessionId, room, transcriptCount, toast, t]);

  const checkActiveSession = useCallback(async () => {
    try {
      const activeSession = await managerRef.current.getActiveSession(room.id);
      
      if (activeSession) {
        setSessionId(activeSession.id);
        setIsActive(true);
        return activeSession;
      }
      
      return null;
    } catch (err) {
      console.error('Failed to check active session:', err);
      return null;
    }
  }, [room.id]);

  return {
    sessionId,
    isActive,
    transcriptCount,
    startSession,
    endSession,
    checkActiveSession
  };
};


================================================
FILE: src/features/conversation/hooks/useConversationState.ts
================================================
import { useState, useCallback } from 'react';
import { ConversationState, ConversationDisplaySettings, ConversationSentence } from '../types/conversation.types';

const initialState: ConversationState = {
  isMonitoring: false,
  currentSessionId: null,
  isBroadcasting: false,
  isMicMuted: true,
  isConnecting: false,
  error: null
};

const initialDisplaySettings: ConversationDisplaySettings = {
  viewMode: 'card',
  showTranscription: true,
  isFullscreen: false,
  invertedStacking: false,
  compactFont: false,
  theme: 'light',
  isListeningMode: true
};

export const useConversationState = () => {
  const [state, setState] = useState<ConversationState>(initialState);
  const [displaySettings, setDisplaySettings] = useState<ConversationDisplaySettings>(initialDisplaySettings);
  const [sentences, setSentences] = useState<ConversationSentence[]>([]);
  const [currentSentence, setCurrentSentence] = useState<{
    id: string;
    transcription: string;
    timestamp: string;
    isComplete?: boolean;
  } | null>(null);

  // State update functions
  const updateState = useCallback((updates: Partial<ConversationState>) => {
    console.log('[useConversationState] State update:', updates);
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  const updateDisplaySettings = useCallback((updates: Partial<ConversationDisplaySettings>) => {
    setDisplaySettings(prev => ({ ...prev, ...updates }));
  }, []);

  // Sentence management
  const addOrUpdateSentence = useCallback((sentenceData: {
    id: string;
    transcription: string;
    isComplete: boolean;
    timestamp: string;
  }) => {
    if (sentenceData.isComplete) {
      setSentences(prev => {
        const existingIndex = prev.findIndex(s => s.id === sentenceData.id);
        if (existingIndex >= 0) {
          const updated = [...prev];
          updated[existingIndex] = {
            ...updated[existingIndex],
            transcription: sentenceData.transcription,
            isComplete: true,
            timestamp: sentenceData.timestamp
          };
          return updated;
        } else {
          return [{
            id: sentenceData.id,
            transcription: sentenceData.transcription,
            translation: '',
            isComplete: true,
            timestamp: sentenceData.timestamp
          }, ...prev.slice(0, 49)];
        }
      });
      setCurrentSentence(null);
    } else {
      setCurrentSentence(current => {
        if (current?.id === sentenceData.id) {
          return {
            ...current,
            transcription: (current.transcription + ' ' + sentenceData.transcription).trim(),
            timestamp: sentenceData.timestamp
          };
        } else {
          return {
            id: sentenceData.id,
            transcription: sentenceData.transcription,
            timestamp: sentenceData.timestamp,
            isComplete: false
          };
        }
      });
    }
  }, []);

  const updateSentenceTranslation = useCallback((sentenceId: string, translation: string) => {
    setSentences(prev => {
      const sentenceIndex = prev.findIndex(s => s.id === sentenceId);
      if (sentenceIndex !== -1) {
        const updated = [...prev];
        updated[sentenceIndex] = {
          ...updated[sentenceIndex],
          translation: translation
        };
        return updated;
      }
      return prev;
    });
  }, []);

  const resetConversation = useCallback(() => {
    // Only reset sentences, not the entire state
    setSentences([]);
    setCurrentSentence(null);
  }, []);

  const toggleFullscreen = useCallback(() => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
      updateDisplaySettings({ isFullscreen: true });
    } else {
      document.exitFullscreen();
      updateDisplaySettings({ isFullscreen: false });
    }
  }, [updateDisplaySettings]);

  return {
    // State
    state,
    displaySettings,
    sentences,
    currentSentence,
    
    // Update functions
    updateState,
    updateDisplaySettings,
    addOrUpdateSentence,
    updateSentenceTranslation,
    resetConversation,
    toggleFullscreen
  };
};


================================================
FILE: src/features/conversation/hooks/useLiveKitConnection.ts
================================================
import { useState, useCallback, useRef } from 'react';
import { LiveKitManager } from '../services/livekitManager';
import { ConversationRole, LiveKitConnectionConfig, Room } from '../types/conversation.types';
import { useToast } from '@/hooks/use-toast';

interface UseLiveKitConnectionProps {
  room: Room;
  role: ConversationRole;
}

export const useLiveKitConnection = ({ room, role }: UseLiveKitConnectionProps) => {
  const [connectionConfig, setConnectionConfig] = useState<LiveKitConnectionConfig>({
    token: null,
    serverUrl: '',
    roomName: room.Livekit_room_name,
    participantName: role === 'primary' ? 'Host_Primary' : 'Host_Secondary'
  });
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();
  
  const managerRef = useRef<LiveKitManager>(new LiveKitManager(role, room));

  const generateToken = useCallback(async (sessionId?: string) => {
    setIsConnecting(true);
    setError(null);

    try {
      const config = await managerRef.current.generateToken(sessionId);
      setConnectionConfig(config);
      
      toast({
        title: "Connected to room",
        description: `Joined ${room.Title} as ${role} speaker`,
      });
      
      return config;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to generate token';
      setError(errorMessage);
      
      toast({
        title: "Connection failed",
        description: "Could not connect to LiveKit room",
        variant: "destructive",
      });
      
      throw err;
    } finally {
      setIsConnecting(false);
    }
  }, [room.Title, role, toast]);

  const disconnect = useCallback(() => {
    setConnectionConfig({
      token: null,
      serverUrl: '',
      roomName: room.Livekit_room_name,
      participantName: role === 'primary' ? 'Host_Primary' : 'Host_Secondary'
    });
    setError(null);
  }, [room.Livekit_room_name, role]);

  const validateRoom = useCallback(() => {
    return managerRef.current.validateRoomConfiguration();
  }, []);

  return {
    connectionConfig,
    isConnecting,
    error,
    generateToken,
    disconnect,
    validateRoom,
    isConnected: !!connectionConfig.token
  };
};


================================================
FILE: src/features/conversation/hooks/usePushToTalk.ts
================================================
import { useState, useEffect, useCallback, useRef } from 'react';
import { ConversationRole } from '../types/conversation.types';
import { pushToTalkService } from '../services/pushToTalkService';

export const usePushToTalk = (role: ConversationRole) => {
  // Initial state: Primary is unmuted (false), Secondary is muted (true)
  const [isMuted, setIsMuted] = useState(() => 
    pushToTalkService.getInitialState(role)
  );
  const [isToggling, setIsToggling] = useState(false);
  
  // Keep track of current state in a ref for the interval
  const currentMutedRef = useRef(isMuted);
  
  useEffect(() => {
    currentMutedRef.current = isMuted;
  }, [isMuted]);

  useEffect(() => {
    // Initialize the service with our role
    pushToTalkService.initialize(role);

    // Subscribe to state changes - receive the actual state, not a toggle
    const unsubscribe = pushToTalkService.subscribe((newMutedState: boolean) => {
      console.log(`[usePushToTalk ${role}] State update received:`, newMutedState);
      setIsMuted(newMutedState);
    });

    // Set up periodic sync (primary only) to recover from any desync
    let syncInterval: NodeJS.Timeout | null = null;
    if (role === 'primary') {
      syncInterval = setInterval(() => {
        // Primary should broadcast the CURRENT actual states
        // Primary unmuted (false) means Secondary should be muted (true) and vice versa
        const currentPrimaryMuted = currentMutedRef.current;
        const currentSecondaryMuted = !currentPrimaryMuted; // Always opposite
        
        console.log(`[usePushToTalk] Sync check - Primary muted: ${currentPrimaryMuted}, Secondary should be: ${currentSecondaryMuted}`);
        pushToTalkService.syncStates(currentPrimaryMuted, currentSecondaryMuted);
      }, 10000); // Every 10 seconds (increased from 5 to reduce noise)
    }

    return () => {
      unsubscribe();
      if (syncInterval) {
        clearInterval(syncInterval);
      }
    };
  }, [role]); // Only re-run if role changes

  const toggleMic = useCallback(async () => {
    if (isToggling) {
      console.log(`[usePushToTalk ${role}] Toggle blocked - already toggling`);
      return;
    }
    
    console.log(`[usePushToTalk ${role}] Toggle called, current muted:`, isMuted);
    setIsToggling(true);
    
    // Pass current state so service knows what to toggle from
    await pushToTalkService.toggleMic(role, isMuted);
    
    // Clear toggling state after a delay
    setTimeout(() => {
      setIsToggling(false);
    }, 500);
  }, [role, isMuted, isToggling]);

  return {
    isMuted,
    toggleMic,
    isToggling,
    // Helper to determine if mic is enabled (opposite of muted)
    isEnabled: !isMuted
  };
};


================================================
FILE: src/features/conversation/hooks/useSecondaryWindowModifications.ts
================================================
import { useEffect } from 'react';
import { ConversationRole } from '../types/conversation.types';

export const useSecondaryWindowModifications = (role: ConversationRole) => {
  useEffect(() => {
    if (role !== 'secondary') return;

    // Hide specific elements for secondary view
    const hideElements = () => {
      // Hide Launch Display button
      const buttons = document.querySelectorAll('button');
      buttons.forEach(button => {
        if (button.textContent?.includes('Display') || button.textContent?.includes('Launch')) {
          (button as HTMLElement).style.display = 'none';
        }
      });
    };

    // Apply modifications after a delay and on mutations
    setTimeout(hideElements, 500);
    const observer = new MutationObserver(hideElements);
    observer.observe(document.body, { childList: true, subtree: true });
    
    return () => observer.disconnect();
  }, [role]);
};


================================================
FILE: src/features/conversation/hooks/useWindowCoordination.ts
================================================
import { useEffect, useRef } from 'react';
import { WindowCoordinator } from '../services/windowCoordinator';
import { ConversationRole, WindowCoordinatorCallbacks } from '../types/conversation.types';

interface UseWindowCoordinationProps extends WindowCoordinatorCallbacks {
  roomId: number;
  role: ConversationRole;
  enabled?: boolean;
}

export const useWindowCoordination = ({
  roomId,
  role,
  enabled = true,
  onGoLiveCommand,
  onStopCommand,
  onEndCommand,
  onLeaveRoomCommand,
  onStartBroadcastCommand
}: UseWindowCoordinationProps) => {
  const coordinatorRef = useRef<WindowCoordinator | null>(null);
  const callbacksRef = useRef<WindowCoordinatorCallbacks>({
    onGoLiveCommand,
    onStopCommand,
    onEndCommand,
    onLeaveRoomCommand,
    onStartBroadcastCommand
  });

  // Update callbacks ref without recreating the coordinator
  useEffect(() => {
    callbacksRef.current = {
      onGoLiveCommand,
      onStopCommand,
      onEndCommand,
      onLeaveRoomCommand,
      onStartBroadcastCommand
    };
  }, [onGoLiveCommand, onStopCommand, onEndCommand, onLeaveRoomCommand, onStartBroadcastCommand]);

  useEffect(() => {
    if (!enabled) {
      return;
    }

    const coordinator = new WindowCoordinator(role, roomId, {
      onGoLiveCommand: () => callbacksRef.current.onGoLiveCommand?.(),
      onStopCommand: () => callbacksRef.current.onStopCommand?.(),
      onEndCommand: () => callbacksRef.current.onEndCommand?.(),
      onLeaveRoomCommand: () => callbacksRef.current.onLeaveRoomCommand?.(),
      onStartBroadcastCommand: () => callbacksRef.current.onStartBroadcastCommand?.()
    });

    coordinatorRef.current = coordinator;
    coordinator.connect();

    return () => {
      coordinator.disconnect();
      coordinatorRef.current = null;
    };
  }, [enabled, role, roomId]); // Only reconnect if these change

  return {
    broadcastGoLive: async () => {
      await coordinatorRef.current?.broadcastGoLive();
    },
    broadcastStop: async () => {
      await coordinatorRef.current?.broadcastStop();
    },
    broadcastEnd: async () => {
      await coordinatorRef.current?.broadcastEnd();
    },
    broadcastLeaveRoom: async () => {
      await coordinatorRef.current?.broadcastLeaveRoom();
    },
    broadcastStartBroadcast: async () => {
      await coordinatorRef.current?.broadcastStartBroadcast();
    }
  };
};


================================================
FILE: src/features/conversation/services/index.ts
================================================
export { WindowCoordinator } from './windowCoordinator';
export { SessionManager } from './sessionManager';
export { LiveKitManager } from './livekitManager';
export { pushToTalkService } from './pushToTalkService';


================================================
FILE: src/features/conversation/services/livekitManager.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import { ConversationRole, LiveKitConnectionConfig, Room } from '../types/conversation.types';

export class LiveKitManager {
  private role: ConversationRole;
  private room: Room;

  constructor(role: ConversationRole, room: Room) {
    this.role = role;
    this.room = room;
  }

  async generateToken(sessionId?: string): Promise<LiveKitConnectionConfig> {
    if (!this.room.Livekit_room_name) {
      throw new Error('Room not configured for LiveKit');
    }

    try {
      const participantName = this.role === 'primary' ? 'Host_Primary' : 'Host_Secondary';
      
      const { data, error } = await supabase.functions.invoke('generate-livekit-token', {
        body: {
          room_id: this.room.id,
          participant_name: participantName,
          permissions: 'speaker',
          session_id: sessionId
        }
      });

      if (error) throw error;
      if (!data || !data.token) throw new Error('Failed to get valid token from server');

      console.log(`[${this.role}] Token received for LiveKit connection`);

      return {
        token: data.token,
        serverUrl: data.server_url || '',
        roomName: this.room.Livekit_room_name,
        participantName
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to generate token';
      console.error(`[${this.role}] LiveKit token generation failed:`, errorMessage);
      throw new Error(errorMessage);
    }
  }

  getConnectionInfo(): {
    roomTitle: string;
    roomName: string | null;
    role: ConversationRole;
  } {
    return {
      roomTitle: `${this.room.Title} - ${this.role === 'primary' ? 'Primary' : 'Secondary'} Speaker`,
      roomName: this.room.Livekit_room_name,
      role: this.role
    };
  }

  validateRoomConfiguration(): boolean {
    return !!this.room.Livekit_room_name;
  }
}


================================================
FILE: src/features/conversation/services/pushToTalkService.ts
================================================
import { ConversationRole } from '../types/conversation.types';
import { supabase } from '@/integrations/supabase/client';

export interface MicStateMessage {
  type: 'set_state';
  primaryMuted: boolean;
  secondaryMuted: boolean;
  fromRole: ConversationRole;
  timestamp: number;
}

export type MicStateListener = (isMuted: boolean) => void;

class PushToTalkService {
  private channel: any = null;
  private listeners = new Set<MicStateListener>();
  private currentRole: ConversationRole | null = null;
  private channelName = 'mic-push-to-talk';
  private isSubscribed = false;
  private lastToggleTime = 0;
  private debounceMs = 500; // Increased to prevent rapid toggle issues
  private isProcessingToggle = false; // Lock to prevent overlapping toggles

  constructor() {
    // Initialize Supabase broadcast channel
    this.setupSupabaseChannel();
  }

  private async setupSupabaseChannel() {
    try {
      this.channel = supabase.channel(this.channelName, {
        config: {
          broadcast: { 
            self: false, // Don't receive own messages
            ack: true    // Wait for acknowledgment
          },
        },
      });

      this.channel.on('broadcast', { event: 'mic_state' }, (payload: any) => {
        console.log(`[PushToTalkService] Received mic_state broadcast:`, payload);
        const message = payload.payload as MicStateMessage;
        
        if (message && this.currentRole) {
          // Ignore messages that are too old (>1 second)
          const messageAge = Date.now() - message.timestamp;
          if (messageAge > 1000) {
            console.warn(`[PushToTalkService] Ignoring stale message (${messageAge}ms old)`);
            return;
          }
          
          // Set our state to what we received
          const shouldBeMuted = this.currentRole === 'primary' 
            ? message.primaryMuted 
            : message.secondaryMuted;
          
          // Notify listeners with the new state
          this.notifyListeners(shouldBeMuted);
        }
      });

      const { error } = await this.channel.subscribe();
      if (error) {
        console.error(`[PushToTalkService] Channel subscription error:`, error);
      } else {
        this.isSubscribed = true;
        console.log(`[PushToTalkService] Successfully subscribed to channel`);
      }
    } catch (err) {
      console.error(`[PushToTalkService] Failed to setup channel:`, err);
    }
  }

  /**
   * Initialize the service with the current window's role
   */
  initialize(role: ConversationRole) {
    this.currentRole = role;
  }

  /**
   * Get the initial mic state based on role
   */
  getInitialState(role: ConversationRole): boolean {
    // Primary starts unmuted (false), Secondary starts muted (true)
    return role === 'secondary';
  }

  /**
   * Toggle both mics by setting explicit states
   */
  async toggleMic(currentRole: ConversationRole, currentMutedState: boolean) {
    // Prevent overlapping toggles
    if (this.isProcessingToggle) {
      console.log(`[PushToTalkService] Toggle blocked - already processing`);
      return;
    }

    // Debounce rapid toggles
    const now = Date.now();
    if (now - this.lastToggleTime < this.debounceMs) {
      console.log(`[PushToTalkService] Toggle debounced (${now - this.lastToggleTime}ms since last)`);
      return;
    }
    
    this.isProcessingToggle = true;
    this.lastToggleTime = now;

    // Calculate what the new states should be (opposite of current)
    const newPrimaryMuted = currentRole === 'primary' ? !currentMutedState : currentMutedState;
    const newSecondaryMuted = currentRole === 'secondary' ? !currentMutedState : currentMutedState;

    console.log(`[PushToTalkService] Toggling from ${currentRole}:`, {
      currentMuted: currentMutedState,
      newPrimaryMuted,
      newSecondaryMuted
    });

    const message: MicStateMessage = {
      type: 'set_state',
      primaryMuted: newPrimaryMuted,
      secondaryMuted: newSecondaryMuted,
      fromRole: currentRole,
      timestamp: now
    };

    // Update local state first
    const myNewState = currentRole === 'primary' ? newPrimaryMuted : newSecondaryMuted;
    this.notifyListeners(myNewState);

    // Then broadcast to other window
    if (this.channel && this.isSubscribed) {
      try {
        const result = await this.channel.send({
          type: 'broadcast',
          event: 'mic_state',
          payload: message
        });
        
        console.log(`[PushToTalkService] Broadcast mic_state result:`, result);
      } catch (error) {
        console.error(`[PushToTalkService] Failed to broadcast mic_state:`, error);
      }
    } else {
      console.error(`[PushToTalkService] Channel not ready for broadcast (subscribed: ${this.isSubscribed})`);
    }
    
    // Release the lock after a short delay to ensure state propagation
    setTimeout(() => {
      this.isProcessingToggle = false;
    }, 100);
  }

  /**
   * Force sync states (called periodically for recovery)
   * Only sends if states need correction
   */
  async syncStates(primaryMuted: boolean, secondaryMuted: boolean) {
    if (!this.isSubscribed || !this.currentRole) return;

    // Only primary should send sync messages to avoid conflicts
    if (this.currentRole !== 'primary') return;

    // Verify states are opposite (XOR check)
    if (primaryMuted === secondaryMuted) {
      console.warn(`[PushToTalkService] States are not opposite! Forcing correction.`);
      // Force them to be opposite based on primary's state
      secondaryMuted = !primaryMuted;
      
      const message: MicStateMessage = {
        type: 'set_state',
        primaryMuted,
        secondaryMuted,
        fromRole: 'primary',
        timestamp: Date.now()
      };

      try {
        await this.channel.send({
          type: 'broadcast',
          event: 'mic_state',
          payload: message
        });
        console.log(`[PushToTalkService] Corrective sync sent - Primary: ${primaryMuted}, Secondary: ${secondaryMuted}`);
      } catch (error) {
        console.error(`[PushToTalkService] Failed to sync states:`, error);
      }
    }
    // If states are already correct (opposite), don't send unnecessary messages
  }

  /**
   * Subscribe to mic state changes
   */
  subscribe(listener: MicStateListener) {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }

  private notifyListeners(isMuted: boolean) {
    this.listeners.forEach(listener => {
      listener(isMuted);
    });
  }

  /**
   * Clean up resources
   */
  destroy() {
    if (this.channel) {
      this.channel.unsubscribe();
      this.channel = null;
    }
    this.isSubscribed = false;
    this.listeners.clear();
  }
}

// Export singleton instance
export const pushToTalkService = new PushToTalkService();


================================================
FILE: src/features/conversation/services/sessionManager.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import { cleanupSession } from '@/utils/sessionCleanupCoordinator';
import { ConversationSession, Room } from '../types/conversation.types';
import { connectionManager } from '@/lib/supabaseConnectionManager';

export class SessionManager {
  async createSession(roomId: number, mosqueId: number): Promise<string | null> {
    try {
      // Clean up any existing sessions first
      const { data: existingSessions } = await supabase
        .from('room_sessions')
        .select('id')
        .eq('room_id', roomId)
        .eq('status', 'active');
        
      if (existingSessions && existingSessions.length > 0) {
        for (const session of existingSessions) {
          await cleanupSession({
            sessionId: session.id,
            roomId: roomId,
            source: 'user',
            skipTranscriptWait: true // Skip waiting since we're starting a new session
          });
        }
      }
      
      // Create new session
      const { data, error } = await supabase
        .from('room_sessions')
        .insert({
          room_id: roomId,
          mosque_id: mosqueId,
          status: 'active',
          logging_enabled: true
        })
        .select()
        .single();

      if (error) {
        console.error('Failed to create session:', error);
        return null;
      }

      return data.id;
    } catch (err) {
      console.error('Error creating session:', err);
      return null;
    }
  }

  async endSession(sessionId: string, roomId: number, room?: Room, skipWait: boolean = false): Promise<void> {
    if (!sessionId) return;

    // For user-initiated stops, we skip the transcript wait to prevent UI blocking
    await cleanupSession({
      sessionId: sessionId,
      roomId: roomId,
      source: 'user',
      room: room,
      skipTranscriptWait: skipWait
    });
  }

  async getActiveSession(roomId: number): Promise<ConversationSession | null> {
    try {
      const { data, error } = await supabase
        .from('room_sessions')
        .select('*')
        .eq('room_id', roomId)
        .eq('status', 'active')
        .single();

      if (error || !data) return null;

      return {
        id: data.id,
        roomId: data.room_id,
        mosqueId: data.mosque_id,
        status: data.status,
        startedAt: new Date(data.created_at),
        endedAt: data.ended_at ? new Date(data.ended_at) : undefined
      };
    } catch (err) {
      console.error('Error getting active session:', err);
      return null;
    }
  }

  subscribeToTranscripts(sessionId: string, onTranscript: () => void): () => void {
    // Use connectionManager for centralized channel management
    return connectionManager.subscribe(
      'conversation-transcripts',
      `transcript-monitor-${sessionId}`,
      {
        event: 'INSERT',
        schema: 'public',
        table: 'transcripts',
        filter: `session_id=eq.${sessionId}`,
        callback: onTranscript
      }
    );
  }
}


================================================
FILE: src/features/conversation/services/windowCoordinator.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import { ConversationRole, BroadcastPayload, WindowCoordinatorCallbacks } from '../types/conversation.types';

export class WindowCoordinator {
  private channelName = 'conversation_mode_coordinator';
  private channel: any = null;
  private role: ConversationRole;
  private roomId: number;
  private callbacks: WindowCoordinatorCallbacks;
  private isSubscribed = false;

  constructor(role: ConversationRole, roomId: number, callbacks: WindowCoordinatorCallbacks) {
    this.role = role;
    this.roomId = roomId;
    this.callbacks = callbacks;
  }

  async connect(): Promise<void> {
    console.log(`[${this.role}] Connecting to channel: ${this.channelName}`);
    
    try {
      this.channel = supabase.channel(this.channelName, {
        config: {
          broadcast: { 
            self: false, // Don't receive own messages
            ack: true    // Wait for acknowledgment
          },
        },
      });

      this.setupEventListeners();

      const { error } = await this.channel.subscribe();
      if (error) {
        console.error(`[${this.role}] Channel subscription error:`, error);
        throw error;
      }
      
      this.isSubscribed = true;
      console.log(`[${this.role}] Successfully subscribed to channel`);
    } catch (err) {
      console.error(`[${this.role}] Failed to setup channel:`, err);
      throw err;
    }
  }

  private setupEventListeners(): void {
    this.channel
      .on('broadcast', { event: 'go_live' }, (payload: any) => {
        this.handleBroadcast('go_live', payload, this.callbacks.onGoLiveCommand);
      })
      .on('broadcast', { event: 'stop_monitoring' }, (payload: any) => {
        this.handleBroadcast('stop_monitoring', payload, this.callbacks.onStopCommand);
      })
      .on('broadcast', { event: 'end_room' }, (payload: any) => {
        this.handleBroadcast('end_room', payload, this.callbacks.onEndCommand);
      })
      .on('broadcast', { event: 'leave_room' }, (payload: any) => {
        this.handleBroadcast('leave_room', payload, this.callbacks.onLeaveRoomCommand);
      })
      .on('broadcast', { event: 'start_broadcast' }, (payload: any) => {
        this.handleBroadcast('start_broadcast', payload, this.callbacks.onStartBroadcastCommand);
      });
  }

  private handleBroadcast(event: string, payload: any, callback?: () => void): void {
    console.log(`[${this.role}] Received ${event} broadcast:`, payload);
    
    if (payload.payload?.from !== this.role && callback) {
      console.log(`[${this.role}] Executing ${event} command from ${payload.payload.from}`);
      // Small delay to ensure DOM is ready
      setTimeout(() => callback(), 100);
    }
  }


  async broadcast(event: string, extraPayload?: any): Promise<void> {
    console.log(`[${this.role}] Broadcasting ${event}`);
    
    // Wait a bit if not subscribed yet
    if (!this.isSubscribed) {
      console.log(`[${this.role}] Waiting for channel subscription...`);
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    if (this.channel && this.isSubscribed) {
      try {
        const payload: BroadcastPayload = {
          from: this.role,
          roomId: this.roomId,
          timestamp: Date.now(),
          ...extraPayload
        };

        const result = await this.channel.send({
          type: 'broadcast',
          event: event,
          payload: payload
        });
        
        console.log(`[${this.role}] Broadcast ${event} result:`, result);
      } catch (error) {
        console.error(`[${this.role}] Failed to broadcast ${event}:`, error);
        throw error;
      }
    } else {
      console.error(`[${this.role}] Channel not ready for broadcast (subscribed: ${this.isSubscribed})`);
      throw new Error('Channel not ready');
    }
  }

  async broadcastGoLive(): Promise<void> {
    await this.broadcast('go_live');
  }

  async broadcastStop(): Promise<void> {
    await this.broadcast('stop_monitoring');
  }

  async broadcastEnd(): Promise<void> {
    await this.broadcast('end_room');
  }

  async broadcastLeaveRoom(): Promise<void> {
    await this.broadcast('leave_room');
  }


  async broadcastStartBroadcast(): Promise<void> {
    await this.broadcast('start_broadcast');
  }

  disconnect(): void {
    console.log(`[${this.role}] Disconnecting from channel`);
    if (this.channel) {
      this.channel.unsubscribe();
      this.channel = null;
    }
    this.isSubscribed = false;
  }
}


================================================
FILE: src/features/conversation/types/conversation.types.ts
================================================
import { Tables } from '@/integrations/supabase/types';

export type Room = Tables<'rooms'>;

export type ConversationRole = 'primary' | 'secondary';

export interface ConversationCommand {
  type: 'go_live' | 'stop_monitoring' | 'end_room' | 'leave_room' | 'start_broadcast';
  from: ConversationRole;
  roomId: number;
  timestamp: number;
  payload?: any;
}

export interface ConversationSession {
  id: string;
  roomId: number;
  mosqueId: number;
  status: 'active' | 'ended';
  startedAt: Date;
  endedAt?: Date;
}

export interface ConversationState {
  isMonitoring: boolean;
  currentSessionId: string | null;
  isBroadcasting: boolean;
  isMicMuted: boolean;
  isConnecting: boolean;
  error: string | null;
}

export interface LiveKitConnectionConfig {
  token: string | null;
  serverUrl: string;
  roomName: string | null;
  participantName: string;
}

export interface ConversationSentence {
  id: string;
  transcription: string;
  translation: string;
  isComplete: boolean;
  timestamp: string;
}

export interface ConversationDisplaySettings {
  showTranscription: boolean;
  isFullscreen: boolean;
  invertedStacking: boolean;
  compactFont: boolean;
  theme: 'light' | 'dark';
}

export interface WindowCoordinatorCallbacks {
  onGoLiveCommand?: () => void;
  onStopCommand?: () => void;
  onEndCommand?: () => void;
  onLeaveRoomCommand?: () => void;
  onStartBroadcastCommand?: () => void;
}

export interface BroadcastPayload {
  from: ConversationRole;
  roomId: number;
  timestamp: number;
  [key: string]: any;
}


================================================
FILE: src/features/conversation/types/index.ts
================================================
export * from './conversation.types';


================================================
FILE: src/features/conversation/utils/conversationTheme.ts
================================================
import { createContext, useContext } from 'react';

export type ConversationTheme = 'light' | 'dark';

export interface ConversationColors {
  // Base colors
  background: string;
  text: string;
  mutedText: string;
  mutedText2: string;
  border: string;
  accent: string;
  
  // Card colors
  cardBg: string;
  cardBgInactive: string;
  cardBorder: string;
  
  // UI element colors
  hover: string;
  inputBg: string;
  dropdownBg: string;
  dropdownBorder: string;
  selectedBg: string;
  
  // Status colors
  primaryRole: string;
  secondaryRole: string;
  error: string;
  success: string;
  warning: string;
  
  // Control colors
  buttonPrimary: string;
  buttonPrimaryText: string;
  buttonSecondary: string;
  buttonSecondaryText: string;
  buttonHover: string;
  
  // Overlay colors
  overlayBg: string;
  overlayText: string;
}

const lightColors: ConversationColors = {
  // Base colors
  background: '#fdf1f4',
  text: '#0a3a3a',
  mutedText: 'rgba(10, 58, 58, 0.7)',
  mutedText2: 'rgba(10, 58, 58, 0.5)',
  border: 'rgba(10, 58, 58, 0.1)',
  accent: '#d4a574',
  
  // Card colors
  cardBg: 'rgba(255, 255, 255, 0.9)',
  cardBgInactive: 'rgba(255, 255, 255, 0.6)',
  cardBorder: 'rgba(212, 165, 116, 0.3)',
  
  // UI element colors
  hover: 'rgba(212, 165, 116, 0.1)',
  inputBg: 'white',
  dropdownBg: 'white',
  dropdownBorder: 'rgba(10, 58, 58, 0.2)',
  selectedBg: 'rgba(212, 165, 116, 0.15)',
  
  // Status colors
  primaryRole: '#3b82f6',
  secondaryRole: '#10b981',
  error: '#dc2626',
  success: '#10b981',
  warning: '#f59e0b',
  
  // Control colors
  buttonPrimary: '#0a3a3a',
  buttonPrimaryText: '#fdf1f4',
  buttonSecondary: 'white',
  buttonSecondaryText: '#0a3a3a',
  buttonHover: '#083030',
  
  // Overlay colors
  overlayBg: 'rgba(253, 241, 244, 0.95)',
  overlayText: '#0a3a3a',
};

const darkColors: ConversationColors = {
  // Base colors
  background: '#0a1212',
  text: '#e8e3d3',
  mutedText: 'rgba(232, 227, 211, 0.7)',
  mutedText2: 'rgba(232, 227, 211, 0.5)',
  border: 'rgba(232, 227, 211, 0.1)',
  accent: '#d4a574',
  
  // Card colors
  cardBg: 'rgba(232, 227, 211, 0.08)',
  cardBgInactive: 'rgba(232, 227, 211, 0.04)',
  cardBorder: 'rgba(212, 165, 116, 0.3)',
  
  // UI element colors
  hover: 'rgba(212, 165, 116, 0.2)',
  inputBg: 'rgba(232, 227, 211, 0.1)',
  dropdownBg: '#1a2020',
  dropdownBorder: 'rgba(232, 227, 211, 0.2)',
  selectedBg: 'rgba(212, 165, 116, 0.25)',
  
  // Status colors
  primaryRole: '#60a5fa',
  secondaryRole: '#34d399',
  error: '#ef4444',
  success: '#34d399',
  warning: '#fbbf24',
  
  // Control colors
  buttonPrimary: '#e8e3d3',
  buttonPrimaryText: '#0a1212',
  buttonSecondary: 'rgba(232, 227, 211, 0.1)',
  buttonSecondaryText: '#e8e3d3',
  buttonHover: '#f5f2e8',
  
  // Overlay colors
  overlayBg: 'rgba(10, 18, 18, 0.95)',
  overlayText: '#e8e3d3',
};

export const getConversationColors = (theme: ConversationTheme): ConversationColors => {
  return theme === 'dark' ? darkColors : lightColors;
};

// Context for theme
export interface ConversationThemeContextType {
  theme: ConversationTheme;
  colors: ConversationColors;
  toggleTheme: () => void;
}

export const ConversationThemeContext = createContext<ConversationThemeContextType | null>(null);

export const useConversationTheme = () => {
  const context = useContext(ConversationThemeContext);
  if (!context) {
    // Return default light theme if no context provider
    return {
      theme: 'light' as ConversationTheme,
      colors: lightColors,
      toggleTheme: () => {}
    };
  }
  return context;
};


================================================
FILE: src/features/dashboard/components/EditRoomForm.tsx
================================================
import React from 'react';
import { UseFormReturn } from 'react-hook-form';
import { z } from 'zod';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { Loader2, Settings } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import { LANGUAGE_OPTIONS, SLIDER_CONFIG, SPEECHMATICS_DOMAIN_OPTIONS } from '@/utils/constants';
import { LanguageSelectorInline } from '@/components/ui/language-selector-inline';

type Room = Tables<'rooms'>;
type PromptTemplate = Tables<'prompt_templates'>;

const roomSchema = z.object({
  title: z.string().min(2, 'form.validation.titleRequired').max(200, 'form.validation.titleMaxLength'),
  transcription_language: z.string().min(1, 'form.validation.languageRequired'),
  translation_language: z.string().min(1, 'form.validation.languageRequired'),
  max_delay: z.number().min(1.0, 'form.validation.maxDelayRange').max(5.0, 'form.validation.maxDelayRange'),
  punctuation_sensitivity: z.number().min(0.0, 'form.validation.punctuationRange').max(1.0, 'form.validation.punctuationRange'),
  context_window_size: z.number().min(3).max(20),
  prompt_template_id: z.string().optional(),
  speechmatics_domain: z.string().default('broadcast'),
});

type RoomFormData = z.infer<typeof roomSchema>;

interface EditRoomFormProps {
  editForm: UseFormReturn<RoomFormData>;
  editingRoom: Room | null;
  showEditDialog: boolean;
  setShowEditDialog: (show: boolean) => void;
  handleUpdateRoom: (data: RoomFormData) => Promise<void>;
  promptTemplates: PromptTemplate[];
}

const EditRoomForm: React.FC<EditRoomFormProps> = ({
  editForm,
  editingRoom,
  showEditDialog,
  setShowEditDialog,
  handleUpdateRoom,
  promptTemplates,
}) => {
  const { t } = useTranslation();

  return (
    <Dialog open={showEditDialog} onOpenChange={setShowEditDialog} modal={false}>
      <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5" />
            {t('mosqueAdmin.rooms.editRoom')}
          </DialogTitle>
        </DialogHeader>
        
        <Form {...editForm}>
          <form onSubmit={editForm.handleSubmit(handleUpdateRoom)} className="space-y-6">
            <div className="space-y-4">
              <FormField
                control={editForm.control}
                name="title"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.roomTitle')}</FormLabel>
                    <FormControl>
                      <Input placeholder={t('mosqueAdmin.rooms.roomTitlePlaceholder')} {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={editForm.control}
                name="prompt_template_id"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.promptTemplate')}</FormLabel>
                    <Select 
                      onValueChange={field.onChange}
                      value={field.value || 'system-default'}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder={t('mosqueAdmin.rooms.selectPromptTemplate')} />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="system-default">{t('mosqueAdmin.rooms.defaultPrompt')}</SelectItem>
                        {promptTemplates.map((template) => (
                          <SelectItem key={template.id} value={template.id}>
                            <div className="flex flex-col items-start">
                              <span>{template.name}</span>
                              {template.description && (
                                <span className="text-xs text-muted-foreground">{template.description}</span>
                              )}
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription>
                      {t('mosqueAdmin.rooms.promptTemplateDescription')}
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <FormField
                  control={editForm.control}
                  name="transcription_language"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('superAdmin.templates.spokenLanguage')}</FormLabel>
                      <FormControl>
                        <LanguageSelectorInline
                          value={field.value}
                          onChange={field.onChange}
                          placeholder={t('form.validation.selectRequired')}
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.spokenLanguageDescription', 'The language being spoken by the imam')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={editForm.control}
                  name="translation_language"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('superAdmin.templates.translationLanguage')}</FormLabel>
                      <FormControl>
                        <LanguageSelectorInline
                          value={field.value}
                          onChange={field.onChange}
                          placeholder={t('form.validation.selectRequired')}
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.translationLanguageDescription', 'The language to translate into for attendees')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>

              <FormField
                control={editForm.control}
                name="speechmatics_domain"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.contentType')}</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value || 'broadcast'}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder={t('mosqueAdmin.rooms.selectContentType')} />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {SPEECHMATICS_DOMAIN_OPTIONS.map(option => (
                          <SelectItem key={option.value} value={option.value}>
                            {t(`mosqueAdmin.rooms.domain.${option.value}`, option.label)}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription>
                      {t('mosqueAdmin.rooms.contentTypeDescription')}
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={editForm.control}
                name="max_delay"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.maxDelay')}: {field.value}s</FormLabel>
                    <FormControl>
                      <Slider
                        min={SLIDER_CONFIG.maxDelay.min}
                        max={SLIDER_CONFIG.maxDelay.max}
                        step={SLIDER_CONFIG.maxDelay.step}
                        value={[field.value]}
                        onValueChange={(value) => field.onChange(value[0])}
                        className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                      />
                    </FormControl>
                    <FormDescription>
                      {t('mosqueAdmin.rooms.maxDelayDescription')}
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={editForm.control}
                name="punctuation_sensitivity"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.punctuationSensitivity')}: {(field.value * 100).toFixed(0)}%</FormLabel>
                    <FormControl>
                      <Slider
                        min={SLIDER_CONFIG.punctuationSensitivity.min}
                        max={SLIDER_CONFIG.punctuationSensitivity.max}
                        step={SLIDER_CONFIG.punctuationSensitivity.step}
                        value={[field.value]}
                        onValueChange={(value) => field.onChange(value[0])}
                        className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                      />
                    </FormControl>
                    <FormDescription>
                      {t('mosqueAdmin.rooms.punctuationSensitivityDescription')}
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={editForm.control}
                name="context_window_size"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.contextWindowSize')}: {field.value} {t('mosqueAdmin.rooms.sentences')}</FormLabel>
                    <FormControl>
                      <Slider
                        min={SLIDER_CONFIG.contextWindowSize.min}
                        max={SLIDER_CONFIG.contextWindowSize.max}
                        step={SLIDER_CONFIG.contextWindowSize.step}
                        value={[field.value]}
                        onValueChange={(value) => field.onChange(value[0])}
                        className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                      />
                    </FormControl>
                    <FormDescription>
                      {t('mosqueAdmin.rooms.contextWindowSizeDescription')}
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => setShowEditDialog(false)}>
                {t('common.cancel')}
              </Button>
              <Button type="submit" disabled={editForm.formState.isSubmitting}>
                {editForm.formState.isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                {t('common.save')}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};

export default EditRoomForm;


================================================
FILE: src/features/dashboard/components/EditRoomFormInline.tsx
================================================
import React from 'react';
import { UseFormReturn } from 'react-hook-form';
import { z } from 'zod';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Loader2, Settings, X } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import { LANGUAGE_OPTIONS, SLIDER_CONFIG, SPEECHMATICS_DOMAIN_OPTIONS } from '@/utils/constants';
import { LanguageSelectorInline } from '@/components/ui/language-selector-inline';

type Room = Tables<'rooms'>;
type PromptTemplate = Tables<'prompt_templates'>;

const roomSchema = z.object({
  title: z.string().min(2, 'form.validation.titleRequired').max(200, 'form.validation.titleMaxLength'),
  transcription_language: z.string().min(1, 'form.validation.languageRequired'),
  translation_language: z.string().min(1, 'form.validation.languageRequired'),
  max_delay: z.number().min(1.0, 'form.validation.maxDelayRange').max(5.0, 'form.validation.maxDelayRange'),
  punctuation_sensitivity: z.number().min(0.0, 'form.validation.punctuationRange').max(1.0, 'form.validation.punctuationRange'),
  context_window_size: z.number().min(3).max(20),
  prompt_template_id: z.string().optional(),
  speechmatics_domain: z.string().default('broadcast'),
});

type RoomFormData = z.infer<typeof roomSchema>;

interface EditRoomFormInlineProps {
  editForm: UseFormReturn<RoomFormData>;
  editingRoom: Room | null;
  showEditForm: boolean;
  setShowEditForm: (show: boolean) => void;
  handleUpdateRoom: (data: RoomFormData) => Promise<void>;
  promptTemplates: PromptTemplate[];
}

const EditRoomFormInline: React.FC<EditRoomFormInlineProps> = ({
  editForm,
  editingRoom,
  showEditForm,
  setShowEditForm,
  handleUpdateRoom,
  promptTemplates,
}) => {
  const { t } = useTranslation();
  const [isUpdating, setIsUpdating] = React.useState(false);

  const onSubmit = async (data: RoomFormData) => {
    setIsUpdating(true);
    try {
      await handleUpdateRoom(data);
      setShowEditForm(false);
    } finally {
      setIsUpdating(false);
    }
  };

  if (!showEditForm || !editingRoom) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50">
      <Card className="w-full max-w-[600px] max-h-[90vh] bg-background relative">
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5" />
            {t('mosqueAdmin.rooms.editRoom')}
          </CardTitle>
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setShowEditForm(false)}
            className="h-8 w-8"
          >
            <X className="h-4 w-4" />
          </Button>
        </CardHeader>
        
        <Form {...editForm}>
          <form onSubmit={editForm.handleSubmit(onSubmit)}>
            <ScrollArea className="max-h-[calc(90vh-200px)]">
              <CardContent className="space-y-6">
              <div className="space-y-4">
                <FormField
                  control={editForm.control}
                  name="title"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueAdmin.rooms.roomTitle')}</FormLabel>
                      <FormControl>
                        <Input placeholder={t('mosqueAdmin.rooms.roomTitlePlaceholder')} {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={editForm.control}
                  name="prompt_template_id"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueAdmin.rooms.promptTemplate')}</FormLabel>
                      <Select 
                        onValueChange={field.onChange}
                        value={field.value || 'system-default'}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder={t('mosqueAdmin.rooms.selectPromptTemplate')} />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          <SelectItem value="system-default">{t('mosqueAdmin.rooms.defaultPrompt')}</SelectItem>
                          {promptTemplates.map((template) => (
                            <SelectItem key={template.id} value={template.id}>
                              <div className="flex flex-col items-start">
                                <span>{template.name}</span>
                                {template.description && (
                                  <span className="text-xs text-muted-foreground">{template.description}</span>
                                )}
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormDescription>
                        {t('mosqueAdmin.rooms.promptTemplateDescription')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <FormField
                    control={editForm.control}
                    name="transcription_language"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('superAdmin.templates.spokenLanguage')}</FormLabel>
                        <FormControl>
                          <LanguageSelectorInline
                            value={field.value}
                            onChange={field.onChange}
                            placeholder={t('form.validation.selectRequired')}
                          />
                        </FormControl>
                        <FormDescription className="text-xs">
                          {t('mosqueAdmin.rooms.spokenLanguageDescription', 'The language being spoken by the imam')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={editForm.control}
                    name="translation_language"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('superAdmin.templates.translationLanguage')}</FormLabel>
                        <FormControl>
                          <LanguageSelectorInline
                            value={field.value}
                            onChange={field.onChange}
                            placeholder={t('form.validation.selectRequired')}
                          />
                        </FormControl>
                        <FormDescription className="text-xs">
                          {t('mosqueAdmin.rooms.translationLanguageDescription', 'The language to translate into for attendees')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={editForm.control}
                  name="speechmatics_domain"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueAdmin.rooms.contentType')}</FormLabel>
                      <Select onValueChange={field.onChange} defaultValue={field.value || 'broadcast'}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder={t('mosqueAdmin.rooms.selectContentType')} />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {SPEECHMATICS_DOMAIN_OPTIONS.map(option => (
                            <SelectItem key={option.value} value={option.value}>
                              {t(`mosqueAdmin.rooms.domain.${option.value}`, option.label)}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.contentTypeDescription')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={editForm.control}
                  name="max_delay"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueAdmin.rooms.maxDelay')}: {field.value}s</FormLabel>
                      <FormControl>
                        <Slider
                          min={SLIDER_CONFIG.maxDelay.min}
                          max={SLIDER_CONFIG.maxDelay.max}
                          step={SLIDER_CONFIG.maxDelay.step}
                          value={[field.value]}
                          onValueChange={(value) => field.onChange(value[0])}
                          className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.maxDelayDescription')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={editForm.control}
                  name="punctuation_sensitivity"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueAdmin.rooms.punctuationSensitivity')}: {(field.value * 100).toFixed(0)}%</FormLabel>
                      <FormControl>
                        <Slider
                          min={SLIDER_CONFIG.punctuationSensitivity.min}
                          max={SLIDER_CONFIG.punctuationSensitivity.max}
                          step={SLIDER_CONFIG.punctuationSensitivity.step}
                          value={[field.value]}
                          onValueChange={(value) => field.onChange(value[0])}
                          className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.punctuationSensitivityDescription')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={editForm.control}
                  name="context_window_size"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueAdmin.rooms.contextWindowSize')}: {field.value} {t('mosqueAdmin.rooms.sentences')}</FormLabel>
                      <FormControl>
                        <Slider
                          min={SLIDER_CONFIG.contextWindowSize.min}
                          max={SLIDER_CONFIG.contextWindowSize.max}
                          step={SLIDER_CONFIG.contextWindowSize.step}
                          value={[field.value]}
                          onValueChange={(value) => field.onChange(value[0])}
                          className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.contextWindowSizeDescription')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </CardContent>
            </ScrollArea>
            
            <CardFooter className="flex justify-between">
              <Button
                type="button"
                variant="outline"
                onClick={() => setShowEditForm(false)}
              >
                {t('form.actions.cancel')}
              </Button>
              <Button type="submit" disabled={isUpdating}>
                {isUpdating && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                {isUpdating ? t('mosqueAdmin.rooms.updating') : t('mosqueAdmin.rooms.updateRoom')}
              </Button>
            </CardFooter>
          </form>
        </Form>
      </Card>
    </div>
  );
};

export default EditRoomFormInline;


================================================
FILE: src/features/dashboard/components/EmptyMonitorState.tsx
================================================
import React from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Activity } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';

interface EmptyMonitorStateProps {
  onGoToManagement: () => void;
}

const EmptyMonitorState: React.FC<EmptyMonitorStateProps> = ({ onGoToManagement }) => {
  const { t } = useTranslation();

  return (
    <Card className="w-full">
      <CardContent className="text-center py-8">
        <Activity className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
        <h3 className="text-lg font-semibold mb-2">{t('mosqueAdmin.monitor.noRoomSelected')}</h3>
        <p className="text-muted-foreground mb-4">
          {t('mosqueAdmin.monitor.selectRoomDescription')}
        </p>
        <Button onClick={onGoToManagement} variant="outline">
          {t('mosqueAdmin.monitor.goToRoomManagement')}
        </Button>
      </CardContent>
    </Card>
  );
};

export default EmptyMonitorState;


================================================
FILE: src/features/dashboard/components/RoomForm.tsx
================================================
import React from 'react';
import { UseFormReturn } from 'react-hook-form';
import { z } from 'zod';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ChevronDown, ChevronUp, Loader2, Settings2 } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import { LANGUAGE_OPTIONS, SLIDER_CONFIG, SPEECHMATICS_DOMAIN_OPTIONS } from '@/utils/constants';
import { LanguageSelector } from '@/components/ui/language-selector';

type PromptTemplate = Tables<'prompt_templates'>;

const roomSchema = z.object({
  title: z.string().min(2, 'form.validation.titleRequired').max(200, 'form.validation.titleMaxLength'),
  transcription_language: z.string().min(1, 'form.validation.languageRequired'),
  translation_language: z.string().min(1, 'form.validation.languageRequired'),
  max_delay: z.number().min(1.0, 'form.validation.maxDelayRange').max(5.0, 'form.validation.maxDelayRange'),
  punctuation_sensitivity: z.number().min(0.0, 'form.validation.punctuationRange').max(1.0, 'form.validation.punctuationRange'),
  context_window_size: z.number().min(3).max(20),
  prompt_template_id: z.string().optional(),
  speechmatics_domain: z.string().default('broadcast'),
});

export type RoomFormData = z.infer<typeof roomSchema>;

interface RoomFormProps {
  form: UseFormReturn<RoomFormData>;
  onSubmit: (data: RoomFormData) => Promise<void>;
  isCreating: boolean;
  promptTemplates: PromptTemplate[];
  showAdvanced: boolean;
  setShowAdvanced: (show: boolean) => void;
  showRoomForm?: boolean;
  onCancel?: () => void;
}

const RoomForm: React.FC<RoomFormProps> = ({
  form,
  onSubmit,
  isCreating,
  promptTemplates,
  showAdvanced,
  setShowAdvanced,
  showRoomForm = true,
  onCancel,
}) => {
  const { t } = useTranslation();

  return (
    <div className={`transition-all duration-300 ease-in-out overflow-hidden ${
      showRoomForm ? 'max-h-[1200px] opacity-100' : 'max-h-0 opacity-0'
    }`}>
      <Card className="bg-background/40 backdrop-blur-md border border-white/20">
        <CardHeader>
          <CardTitle className="text-lg">{t('mosqueAdmin.rooms.title')}</CardTitle>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.roomTitle')}</FormLabel>
                    <FormControl>
                      <Input placeholder={t('mosqueAdmin.rooms.roomTitlePlaceholder')} {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Language Selection */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <FormField
                  control={form.control}
                  name="transcription_language"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('superAdmin.templates.spokenLanguage')}</FormLabel>
                      <FormControl>
                        <LanguageSelector
                          value={field.value}
                          onChange={field.onChange}
                          placeholder={t('form.validation.selectRequired')}
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.spokenLanguageDescription', 'The language being spoken by the imam')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="translation_language"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('superAdmin.templates.translationLanguage')}</FormLabel>
                      <FormControl>
                        <LanguageSelector
                          value={field.value}
                          onChange={field.onChange}
                          placeholder={t('form.validation.selectRequired')}
                        />
                      </FormControl>
                      <FormDescription className="text-xs">
                        {t('mosqueAdmin.rooms.translationLanguageDescription', 'The language to translate into for attendees')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>

              {/* Translation Style */}
              <FormField
                control={form.control}
                name="prompt_template_id"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('mosqueAdmin.rooms.promptTemplate')}</FormLabel>
                    <Select 
                      onValueChange={field.onChange}
                      value={field.value || 'system-default'}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder={t('mosqueAdmin.rooms.selectPromptTemplate')} />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="system-default">{t('mosqueAdmin.rooms.defaultPrompt')}</SelectItem>
                        {promptTemplates.map((template) => (
                          <SelectItem key={template.id} value={template.id}>
                            <div className="flex flex-col items-start">
                              <span>{template.name}</span>
                              {template.description && (
                                <span className="text-xs text-muted-foreground">{template.description}</span>
                              )}
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription>
                      {t('mosqueAdmin.rooms.promptTemplateDescription')}
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Advanced Settings - Collapsible */}
              <div className={`transition-all duration-300 ease-in-out overflow-hidden ${
                showAdvanced ? 'max-h-[800px] opacity-100' : 'max-h-0 opacity-0'
              }`}>
                <div className="space-y-4 border rounded-lg p-4 bg-muted/50 backdrop-blur-sm mt-2">
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2">
                      <Settings2 className="h-4 w-4 text-muted-foreground" />
                      <h4 className="text-sm font-medium">{t('advanced.title')}</h4>
                    </div>
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() => setShowAdvanced(false)}
                      className="h-auto p-1 hover:bg-transparent"
                    >
                      <ChevronUp className="h-4 w-4" />
                    </Button>
                  </div>

                  <FormField
                    control={form.control}
                    name="speechmatics_domain"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('mosqueAdmin.rooms.contentType')}</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value || 'broadcast'}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder={t('mosqueAdmin.rooms.selectContentType')} />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {SPEECHMATICS_DOMAIN_OPTIONS.map(option => (
                              <SelectItem key={option.value} value={option.value}>
                                {t(`mosqueAdmin.rooms.domain.${option.value}`, option.label)}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormDescription className="text-xs">
                          {t('mosqueAdmin.rooms.contentTypeDescription')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="max_delay"
                    render={({ field }) => (
                      <FormItem className="space-y-3">
                        <div className="flex items-center justify-between">
                          <FormLabel className="text-sm">{t('mosqueAdmin.rooms.maxDelay')}</FormLabel>
                          <span className="text-sm font-medium tabular-nums">{field.value.toFixed(1)}s</span>
                        </div>
                        <FormControl>
                          <div className="px-2">
                            <Slider
                              min={SLIDER_CONFIG.maxDelay.min}
                              max={SLIDER_CONFIG.maxDelay.max}
                              step={SLIDER_CONFIG.maxDelay.step}
                              value={[field.value]}
                              onValueChange={(value) => field.onChange(value[0])}
                              className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                            />
                            <div className="flex justify-between text-xs text-muted-foreground mt-1">
                              <span>{SLIDER_CONFIG.maxDelay.min}s</span>
                              <span>{SLIDER_CONFIG.maxDelay.max}s</span>
                            </div>
                          </div>
                        </FormControl>
                        <FormDescription className="text-xs">
                          {t('mosqueAdmin.rooms.maxDelayDescription')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="punctuation_sensitivity"
                    render={({ field }) => (
                      <FormItem className="space-y-3">
                        <div className="flex items-center justify-between">
                          <FormLabel className="text-sm">{t('mosqueAdmin.rooms.punctuationSensitivity')}</FormLabel>
                          <span className="text-sm font-medium tabular-nums">{(field.value * 100).toFixed(0)}%</span>
                        </div>
                        <FormControl>
                          <div className="px-2">
                            <Slider
                              min={SLIDER_CONFIG.punctuationSensitivity.min}
                              max={SLIDER_CONFIG.punctuationSensitivity.max}
                              step={SLIDER_CONFIG.punctuationSensitivity.step}
                              value={[field.value]}
                              onValueChange={(value) => field.onChange(value[0])}
                              className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                            />
                            <div className="flex justify-between text-xs text-muted-foreground mt-1">
                              <span>0%</span>
                              <span>50%</span>
                              <span>100%</span>
                            </div>
                          </div>
                        </FormControl>
                        <FormDescription className="text-xs">
                          {t('mosqueAdmin.rooms.punctuationSensitivityDescription')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="context_window_size"
                    render={({ field }) => (
                      <FormItem className="space-y-3">
                        <div className="flex items-center justify-between">
                          <FormLabel className="text-sm">{t('mosqueAdmin.rooms.contextWindowSize')}</FormLabel>
                          <span className="text-sm font-medium tabular-nums">{field.value} {t('mosqueAdmin.rooms.sentences')}</span>
                        </div>
                        <FormControl>
                          <div className="px-2">
                            <Slider
                              min={SLIDER_CONFIG.contextWindowSize.min}
                              max={SLIDER_CONFIG.contextWindowSize.max}
                              step={SLIDER_CONFIG.contextWindowSize.step}
                              value={[field.value]}
                              onValueChange={(value) => field.onChange(value[0])}
                              className="[&_[role=slider]]:h-4 [&_[role=slider]]:w-4"
                            />
                            <div className="flex justify-between text-xs text-muted-foreground mt-1">
                              <span>{SLIDER_CONFIG.contextWindowSize.min}</span>
                              <span>10</span>
                              <span>{SLIDER_CONFIG.contextWindowSize.max}</span>
                            </div>
                          </div>
                        </FormControl>
                        <FormDescription className="text-xs">
                          {t('mosqueAdmin.rooms.contextWindowSizeDescription')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>
              </div>

              {/* Form Actions */}
              <div className="flex flex-col sm:flex-row items-center gap-2 pb-2">
                {!showAdvanced && (
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => setShowAdvanced(true)}
                    className="flex items-center gap-2 w-full sm:w-auto"
                  >
                    <Settings2 className="h-4 w-4" />
                    {t('advanced.show')}
                  </Button>
                )}
                <div className="flex gap-2 w-full sm:w-auto sm:ml-auto">
                  {onCancel && (
                    <Button 
                      type="button" 
                      variant="outline" 
                      onClick={onCancel}
                      className="w-full sm:w-auto"
                    >
                      {t('common.cancel')}
                    </Button>
                  )}
                  <Button type="submit" disabled={isCreating} className="w-full sm:w-auto">
                    {isCreating && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                    {t('mosqueAdmin.rooms.createRoom')}
                  </Button>
                </div>
              </div>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
};

export default RoomForm;


================================================
FILE: src/features/dashboard/components/RoomsGrid.tsx
================================================
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Plus, Play, Eye, Share2, Settings, Trash2, Info } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import RoomCodeManager from '@/features/mosque/components/RoomCodeManager';
// import KioskToggle from '@/features/display/components/KioskToggle'; // Hidden as requested
import { getStatusStyle, generatePublicDisplayUrl, formatRoomConfig } from '@/utils/roomHelpers';
import { useToast } from '@/hooks/use-toast';
import { StyledHeader } from '@/components/ui/styled-headers';

type Room = Tables<'rooms'>;

interface RoomsGridProps {
  rooms: Room[];
  onMonitorRoom: (room: Room) => void;
  onEditRoom: (room: Room) => void;
  onDeleteRoom: (room: Room) => void;
  onCreateRoom: () => void;
}

const RoomsGrid: React.FC<RoomsGridProps> = ({
  rooms,
  onMonitorRoom,
  onEditRoom,
  onDeleteRoom,
  onCreateRoom,
}) => {
  const { t } = useTranslation();
  const { toast } = useToast();

  const handleShareRoom = (room: Room) => {
    const url = generatePublicDisplayUrl(room.id);
    navigator.clipboard.writeText(url);
    toast({
      title: t('toast.success.copied'),
      description: t('mosqueAdmin.rooms.urlCopied')
    });
  };

  if (rooms.length === 0) {
    return (
      <div className="text-center py-8">
        <Play className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
        <StyledHeader variant="h3" className="mb-2">{t('mosqueAdmin.rooms.noRoomsFound')}</StyledHeader>
        <p className="text-muted-foreground mb-4">
          {t('mosqueAdmin.rooms.noRoomsDescription')}
        </p>
        <Button onClick={onCreateRoom}>
          <Plus className="mr-2 h-4 w-4" />
          {t('mosqueAdmin.rooms.createRoom')}
        </Button>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
      {rooms.map((room) => (
        <Card key={room.id} className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200">
          <CardHeader className="pb-2">
            <div className="flex items-start justify-between gap-3">
              <div className="flex-1 min-w-0">
                <StyledHeader variant="h4" className="text-base font-semibold truncate mb-1">
                  {room.Title}
                </StyledHeader>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <div className="flex items-center gap-2 cursor-help">
                        <Badge 
                          variant={room.status === 'active' ? 'default' : 'secondary'}
                          className={`flex items-center gap-1 text-xs px-1.5 py-0.5 ${getStatusStyle(room.status).badge}`}
                        >
                          <div className={`h-1.5 w-1.5 rounded-full ${getStatusStyle(room.status).dot}`}></div>
                          {room.status === 'active' ? t('common.active') : 
                           room.status === 'empty' ? 'Available' :
                           room.status === 'pending' ? 'Pending' : 
                           room.status || 'Pending'}
                        </Badge>
                      </div>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>{t('mosqueAdminDashboard.statusTooltip')}</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              
              {/* Toggles - Right Side */}
              <div className="flex flex-col items-end space-y-2">
                {/* KioskToggle hidden as requested */}
                <RoomCodeManager 
                  room={room} 
                  onUpdate={() => {
                    // Room update is handled automatically by real-time subscription in the hook
                  }}
                  className="flex-nowrap"
                />
              </div>
            </div>
          </CardHeader>
          <CardContent className="pt-0 space-y-3">
            {/* Configuration Info - Compact */}
            <div className="space-y-1">
              <div className="text-sm font-medium">
                {formatRoomConfig(room).languages}
              </div>
              <div className="text-xs text-muted-foreground">
                {t('mosqueAdmin.rooms.delayLabel')}: {formatRoomConfig(room).delay} • {t('mosqueAdmin.rooms.punctuationLabel')}: {formatRoomConfig(room).punctuation}
              </div>
            </div>

            {/* Action Buttons - Compact */}
            <div className="flex gap-1.5 pt-1">
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => onMonitorRoom(room)}
                className="flex-1 h-8 text-xs hover:bg-primary hover:text-primary-foreground hover:border-primary transition-colors group-hover:bg-primary group-hover:text-primary-foreground group-hover:border-primary"
              >
                <Eye className="h-3 w-3 mr-1.5" />
                {t('common.monitor')}
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleShareRoom(room)}
                className="h-8 w-8 p-0 hover:bg-primary/10 hover:text-primary transition-colors"
              >
                <Share2 className="h-3 w-3" />
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => onEditRoom(room)}
                className="h-8 w-8 p-0 hover:bg-warning/10 hover:text-warning transition-colors"
              >
                <Settings className="h-3 w-3" />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => onDeleteRoom(room)}
                className="h-8 w-8 p-0 text-destructive hover:text-destructive border-destructive/20 hover:bg-destructive/10 transition-colors"
              >
                <Trash2 className="h-3 w-3" />
              </Button>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
};

export default RoomsGrid;


================================================
FILE: src/features/dashboard/components/StatsHeader.tsx
================================================
import React, { useState } from 'react';
import { Card, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Building, Plus, ShieldCheck, RefreshCw } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

interface StatsHeaderProps {
  mosqueName?: string;
  totalRooms: number;
  activeRooms: number;
  emptyRooms: number;
  loading: boolean;
  showRoomForm: boolean;
  onToggleRoomForm: () => void;
  mosqueId: number;
  onRefresh?: () => void;
}

const StatsHeader: React.FC<StatsHeaderProps> = ({
  mosqueName,
  totalRooms,
  activeRooms,
  emptyRooms,
  loading,
  showRoomForm,
  onToggleRoomForm,
  mosqueId,
  onRefresh,
}) => {
  const { t } = useTranslation();
  const { toast } = useToast();
  const [isResetting, setIsResetting] = useState(false);

  const handleResetRooms = async () => {
    if (!confirm('Are you sure you want to close all active rooms? This will end all active sessions.')) {
      return;
    }
    
    setIsResetting(true);
    try {
      // First, end all active sessions
      const { error: sessionsError } = await supabase
        .from('room_sessions')
        .update({ 
          status: 'completed',
          ended_at: new Date().toISOString(),
        })
        .eq('mosque_id', mosqueId)
        .eq('status', 'active');

      if (sessionsError) throw sessionsError;

      // Then reset all rooms to empty
      const { error: roomsError } = await supabase
        .from('rooms')
        .update({ 
          Status: 'empty',
          updated_at: new Date().toISOString()
        })
        .eq('mosque_id', mosqueId)
        .in('Status', ['in_session', 'live']);

      if (roomsError) throw roomsError;

      toast({
        title: 'Success',
        description: 'All active rooms have been closed successfully',
      });

      // Refresh the room list
      if (onRefresh) {
        onRefresh();
      }
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to reset rooms. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setIsResetting(false);
    }
  };

  return (
    <Card className="w-full border-0 shadow-none">
      <CardHeader className="px-4">
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div className="min-w-0 flex-1">
            <CardTitle className="flex items-center gap-2 text-lg sm:text-xl font-poppins" style={{ letterSpacing: '-0.058em' }}>
              <Building className="h-5 w-5" />
              <span className="truncate">
                <span className="lowercase">{t('dashboard.mosqueAdminTitle')}</span>: {mosqueName}
              </span>
            </CardTitle>
          </div>
          
          {/* Compact Inline Stats */}
          <div className="flex items-center gap-4 px-4 py-2 rounded-lg">
            <div className="flex items-center gap-1.5">
              <Building className="h-3.5 w-3.5" />
              <span className="text-sm font-medium">{loading ? '...' : totalRooms}</span>
              <span className="text-xs text-muted-foreground hidden sm:inline">{t('mosqueAdmin.stats.totalRooms')}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <span className="text-sm font-medium">{loading ? '...' : activeRooms}</span>
              <span className="text-xs text-muted-foreground hidden sm:inline">{t('common.active')}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <span className="text-sm font-medium">{loading ? '...' : emptyRooms}</span>
              <span className="text-xs text-muted-foreground hidden sm:inline">{t('mosqueAdmin.stats.available')}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <ShieldCheck className="h-4 w-4" />
              <span className="text-xs text-muted-foreground hidden sm:inline">{t('mosqueAdminDashboard.health')}</span>
            </div>
          </div>

          {/* Room Actions */}
          <div className="flex items-center gap-2">
            {activeRooms > 0 && (
              <Button
                onClick={handleResetRooms}
                variant="outline"
                size="sm"
                disabled={isResetting}
                title="Close all active rooms"
              >
                <RefreshCw className={`h-4 w-4 ${isResetting ? 'animate-spin' : ''}`} />
              </Button>
            )}
            <Button 
              onClick={onToggleRoomForm} 
              className="flex items-center gap-2"
              variant={showRoomForm ? "outline" : "default"}
              size="sm"
            >
              <Plus className={`h-4 w-4 transition-transform duration-200 ${showRoomForm ? 'rotate-45' : ''}`} />
              {showRoomForm ? t('common.cancel') : t('mosqueAdmin.rooms.createRoom')}
            </Button>
          </div>
        </div>
      </CardHeader>
    </Card>
  );
};

export default StatsHeader;


================================================
FILE: src/features/dashboard/hooks/useCrossMosqueData.ts
================================================
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

type Room = Tables<'rooms'>;
type Session = Tables<'room_sessions'>;
type User = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface RoomWithMosque extends Room {
  mosque?: Mosque;
}

interface SessionWithDetails extends Session {
  room?: Room & { mosque?: Mosque };
}

interface UserWithMosque extends User {
  mosque?: Mosque;
}

export const useCrossMosqueData = () => {
  const { toast } = useToast();
  const { t } = useTranslation();

  // Rooms state
  const [rooms, setRooms] = useState<RoomWithMosque[]>([]);
  const [roomsLoading, setRoomsLoading] = useState(false);
  const [roomsError, setRoomsError] = useState<string | null>(null);

  // Sessions state
  const [sessions, setSessions] = useState<SessionWithDetails[]>([]);
  const [sessionsLoading, setSessionsLoading] = useState(false);
  const [sessionsError, setSessionsError] = useState<string | null>(null);

  // Users state
  const [users, setUsers] = useState<UserWithMosque[]>([]);
  const [usersLoading, setUsersLoading] = useState(false);
  const [usersError, setUsersError] = useState<string | null>(null);

  // Fetch all rooms across mosques
  const fetchRooms = useCallback(async () => {
    try {
      setRoomsLoading(true);
      setRoomsError(null);

      const { data, error } = await supabase
        .from('rooms')
        .select(`
          *,
          mosque:Mosque(
            id,
            name,
            Subdomain
          )
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setRooms(data || []);
    } catch (err) {
      setRoomsError(err instanceof Error ? err.message : 'Failed to fetch rooms');
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchRoomsFailed'),
        variant: 'destructive',
      });
    } finally {
      setRoomsLoading(false);
    }
  }, [t, toast]);

  // Fetch all sessions across mosques
  const fetchSessions = useCallback(async (dateFilter?: 'today' | 'week' | 'month') => {
    try {
      setSessionsLoading(true);
      setSessionsError(null);

      let query = supabase
        .from('room_sessions')
        .select(`
          *,
          room:rooms(
            *,
            mosque:Mosque(
              id,
              name,
              Subdomain
            )
          )
        `)
        .order('started_at', { ascending: false });

      // Apply date filter if provided
      if (dateFilter) {
        const now = new Date();
        let filterDate: Date;

        switch (dateFilter) {
          case 'today':
            filterDate = new Date(now.setHours(0, 0, 0, 0));
            break;
          case 'week':
            filterDate = new Date(now.setDate(now.getDate() - 7));
            break;
          case 'month':
            filterDate = new Date(now.setMonth(now.getMonth() - 1));
            break;
        }

        query = query.gte('started_at', filterDate.toISOString());
      }

      const { data, error } = await query;

      if (error) throw error;
      setSessions(data || []);
    } catch (err) {
      setSessionsError(err instanceof Error ? err.message : 'Failed to fetch sessions');
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchSessionsFailed'),
        variant: 'destructive',
      });
    } finally {
      setSessionsLoading(false);
    }
  }, [t, toast]);

  // Fetch all users across mosques
  const fetchUsers = useCallback(async () => {
    try {
      setUsersLoading(true);
      setUsersError(null);

      const { data, error } = await supabase
        .from('users')
        .select(`
          *,
          mosque:Mosque(
            id,
            name,
            Subdomain
          )
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setUsers(data || []);
    } catch (err) {
      setUsersError(err instanceof Error ? err.message : 'Failed to fetch users');
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchUsersFailed'),
        variant: 'destructive',
      });
    } finally {
      setUsersLoading(false);
    }
  }, [t, toast]);

  // Batch operations
  const updateRoomStatus = useCallback(async (roomIds: number[], status: string) => {
    try {
      const { error } = await supabase
        .from('rooms')
        .update({ status })
        .in('id', roomIds);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.rooms.statusUpdated'),
      });

      await fetchRooms();
      return true;
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
      return false;
    }
  }, [fetchRooms, t, toast]);

  const deleteRooms = useCallback(async (roomIds: number[]) => {
    try {
      const { error } = await supabase
        .from('rooms')
        .delete()
        .in('id', roomIds);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.rooms.roomsDeleted'),
      });

      await fetchRooms();
      return true;
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : t('technical.errors.deleteFailed'),
        variant: 'destructive',
      });
      return false;
    }
  }, [fetchRooms, t, toast]);

  // Set up real-time subscriptions with proper cleanup and debouncing
  useEffect(() => {
    // Debounce timer refs
    let roomsTimer: NodeJS.Timeout;
    let sessionsTimer: NodeJS.Timeout;
    let usersTimer: NodeJS.Timeout;

    // Debounced fetch functions to prevent excessive updates
    const debouncedFetchRooms = () => {
      clearTimeout(roomsTimer);
      roomsTimer = setTimeout(fetchRooms, 500);
    };

    const debouncedFetchSessions = () => {
      clearTimeout(sessionsTimer);
      sessionsTimer = setTimeout(() => fetchSessions(), 500);
    };

    const debouncedFetchUsers = () => {
      clearTimeout(usersTimer);
      usersTimer = setTimeout(fetchUsers, 500);
    };

    // Use a single multiplexed channel instead of multiple channels
    const channel = supabase
      .channel('cross-mosque-realtime')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'rooms' }, debouncedFetchRooms)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'room_sessions' }, debouncedFetchSessions)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'users' }, debouncedFetchUsers)
      .subscribe();

    return () => {
      // Clear all timers
      clearTimeout(roomsTimer);
      clearTimeout(sessionsTimer);
      clearTimeout(usersTimer);
      
      // Properly unsubscribe and remove channel
      channel.unsubscribe();
      supabase.removeChannel(channel);
    };
  }, [fetchRooms, fetchSessions, fetchUsers]);

  return {
    // Rooms
    rooms,
    roomsLoading,
    roomsError,
    fetchRooms,
    updateRoomStatus,
    deleteRooms,

    // Sessions
    sessions,
    sessionsLoading,
    sessionsError,
    fetchSessions,

    // Users
    users,
    usersLoading,
    usersError,
    fetchUsers,
  };
};


================================================
FILE: src/features/dashboard/hooks/useMosqueData.ts
================================================
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';

type Mosque = Tables<'Mosque'>;

interface UseMosqueDataProps {
  mosqueId: number;
}

export const useMosqueData = ({ mosqueId }: UseMosqueDataProps) => {
  const [mosque, setMosque] = useState<Mosque | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchMosque = useCallback(async () => {
    if (!mosqueId) return;

    try {
      setLoading(true);
      setError(null);

      // Check if user is authenticated
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        setError('User not authenticated');
        return;
      }

      // Fetch mosque details
      const { data: mosqueData, error: mosqueError } = await supabase
        .from('Mosque')
        .select('*')
        .eq('id', mosqueId)
        .maybeSingle();

      if (mosqueError) {
        throw mosqueError;
      }
      
      if (!mosqueData) {
        setError(`Mosque with ID ${mosqueId} not found`);
        return;
      }

      setMosque(mosqueData);
      } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch mosque data');
    } finally {
      setLoading(false);
    }
  }, [mosqueId]);

  useEffect(() => {
    fetchMosque();
  }, [fetchMosque]);

  return {
    mosque,
    loading,
    error,
    refetch: fetchMosque,
  };
};


================================================
FILE: src/features/dashboard/hooks/usePromptTemplates.ts
================================================
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';

type PromptTemplate = Tables<'prompt_templates'>;

interface UsePromptTemplatesProps {
  mosqueId?: number;
}

interface UsePromptTemplatesReturn {
  promptTemplates: PromptTemplate[];
  loading: boolean;
  error: Error | null;
}

export const usePromptTemplates = ({ mosqueId }: UsePromptTemplatesProps = {}): UsePromptTemplatesReturn => {
  const [promptTemplates, setPromptTemplates] = useState<PromptTemplate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchPromptTemplates = async () => {
      try {
        setLoading(true);
        setError(null);

        // Fetch prompt templates (mosque-specific and global)
        const { data: promptData, error: promptError } = await supabase
          .from('prompt_templates')
          .select('*')
          .or(`mosque_id.eq.${mosqueId},mosque_id.is.null`)
          .eq('is_active', true)
          .order('is_default', { ascending: false })
          .order('created_at', { ascending: false });

        if (promptError) throw promptError;

        setPromptTemplates((promptData as PromptTemplate[]) || []);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Failed to fetch templates'));
      } finally {
        setLoading(false);
      }
    };

    fetchPromptTemplates();
  }, [mosqueId]);

  return {
    promptTemplates,
    loading,
    error,
  };
};


================================================
FILE: src/features/dashboard/hooks/useRoomManagement.ts
================================================
import { useState, useEffect, useCallback, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

type Room = Tables<'rooms'>;

interface UseRoomManagementProps {
  mosqueId: number;
}

export const useRoomManagement = ({ mosqueId }: UseRoomManagementProps) => {
  const { toast } = useToast();
  const { t } = useTranslation();
  const [rooms, setRooms] = useState<Room[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const updateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Fetch rooms
  const fetchRooms = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const { data: roomsData, error: roomsError } = await supabase
        .from('rooms')
        .select('*')
        .order('created_at', { ascending: false });

      if (roomsError) {
        throw roomsError;
      }
      
      setRooms(roomsData || []);
      } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch rooms');
    } finally {
      setLoading(false);
    }
  }, []);

  // Delete room
  const deleteRoom = useCallback(async (room: Room): Promise<boolean> => {
    if (!confirm(t('mosqueAdmin.rooms.deleteConfirm').replace('{title}', room.Title || ''))) {
      return false;
    }

    try {
      const { error } = await supabase
        .from('rooms')
        .delete()
        .eq('id', room.id);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('mosqueAdmin.rooms.roomDeleted').replace('{title}', room.Title || ''),
      });

      await fetchRooms();
      return true;
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : t('mosqueAdmin.rooms.deleteFailed'),
        variant: "destructive",
      });
      return false;
    }
  }, [fetchRooms, t, toast]);

  // Update room
  const updateRoom = useCallback(async (roomId: number, updates: Partial<Room> & Record<string, any>): Promise<boolean> => {
    try {
      const { error } = await supabase
        .from('rooms')
        .update(updates as any)
        .eq('id', roomId);

      if (error) throw error;

      await fetchRooms();
      return true;
    } catch (err) {
      return false;
    }
  }, [fetchRooms]);

  // Set up realtime subscription
  useEffect(() => {
    if (!mosqueId) return;

    fetchRooms();

    const channel = supabase
      .channel(`room-changes-${mosqueId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'rooms'
        },
        (payload) => {
          // Clear any pending update
          if (updateTimeoutRef.current) {
            clearTimeout(updateTimeoutRef.current);
          }
          
          // For updates, we can be more selective
          if (payload.eventType === 'UPDATE' && payload.new) {
            const updatedRoom = payload.new as Room;
            
            // Update the specific room in the state without refetching all
            setRooms(prevRooms => {
              const index = prevRooms.findIndex(r => r.id === updatedRoom.id);
              if (index !== -1) {
                const newRooms = [...prevRooms];
                // Preserve object reference if only non-critical fields changed
                const existingRoom = newRooms[index];
                const criticalFieldsChanged = 
                  existingRoom.Livekit_room_name !== updatedRoom.Livekit_room_name ||
                  existingRoom.status !== updatedRoom.status ||
                  existingRoom.Title !== updatedRoom.Title;
                
                if (criticalFieldsChanged) {
                  newRooms[index] = updatedRoom;
                } else {
                  // Update only the changed fields to preserve object reference
                  Object.assign(existingRoom, updatedRoom);
                }
                return newRooms;
              }
              return prevRooms;
            });
          } else {
            // For INSERT or DELETE, we need to refetch all rooms
            // Debounce the update to avoid rapid refetches
            updateTimeoutRef.current = setTimeout(() => {
              fetchRooms();
            }, 300);
          }
        }
      )
      .subscribe();

    return () => {
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
      supabase.removeChannel(channel);
    };
  }, [mosqueId, fetchRooms]);

  return {
    rooms,
    loading,
    error,
    deleteRoom,
    updateRoom,
    refetch: fetchRooms,
  };
};


================================================
FILE: src/features/dashboard/hooks/useSuperAdminStats.ts
================================================
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

interface SuperAdminStats {
  totalMosques: number;
  totalUsers: number;
  totalRooms: number;
  activeRooms: number;
  totalSessions: number;
  activeSessions: number;
  totalTemplates: number;
}

export const useSuperAdminStats = (refreshInterval = 30000) => { // Default 30 seconds
  const { toast } = useToast();
  const { t } = useTranslation();
  const [stats, setStats] = useState<SuperAdminStats>({
    totalMosques: 0,
    totalUsers: 0,
    totalRooms: 0,
    activeRooms: 0,
    totalSessions: 0,
    activeSessions: 0,
    totalTemplates: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastRefresh, setLastRefresh] = useState<Date>(new Date());

  const fetchStats = async () => {
    try {
      setLoading(true);
      setError(null);

      // Fetch all stats in parallel
      const [
        mosquesResult,
        usersResult,
        roomsResult,
        activeRoomsResult,
        sessionsResult,
        activeSessionsResult,
        templatesResult,
      ] = await Promise.all([
        supabase.from('Mosque').select('*', { count: 'exact', head: true }),
        supabase.from('users').select('*', { count: 'exact', head: true }),
        supabase.from('rooms').select('*', { count: 'exact', head: true }),
        supabase.from('rooms').select('*', { count: 'exact', head: true }).eq('status', 'active'),
        supabase.from('room_sessions').select('*', { count: 'exact', head: true }),
        supabase.from('room_sessions').select('*', { count: 'exact', head: true }).is('ended_at', null),
        supabase.from('room_templates').select('*', { count: 'exact', head: true }).eq('is_system_template', true),
      ]);

      setStats({
        totalMosques: mosquesResult.count || 0,
        totalUsers: usersResult.count || 0,
        totalRooms: roomsResult.count || 0,
        activeRooms: activeRoomsResult.count || 0,
        totalSessions: sessionsResult.count || 0,
        activeSessions: activeSessionsResult.count || 0,
        totalTemplates: templatesResult.count || 0,
      });
      setLastRefresh(new Date());
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch stats');
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchStatsFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchStats();

    // Debounce timer for real-time updates
    let debounceTimer: NodeJS.Timeout;
    const debouncedFetchStats = () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(fetchStats, 500);
    };

    // Set up single multiplexed channel for all real-time updates
    const channel = supabase
      .channel('super-admin-stats')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'Mosque' }, debouncedFetchStats)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'users' }, debouncedFetchStats)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'rooms' }, debouncedFetchStats)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'room_sessions' }, debouncedFetchStats)
      .subscribe();

    // Set up auto-refresh interval
    let intervalId: NodeJS.Timeout | null = null;
    if (refreshInterval > 0) {
      intervalId = setInterval(fetchStats, refreshInterval);
    }

    return () => {
      // Clear debounce timer
      clearTimeout(debounceTimer);
      // Cleanup subscription
      channel.unsubscribe();
      supabase.removeChannel(channel);
      // Cleanup interval
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [refreshInterval]);

  return {
    stats,
    loading,
    error,
    refetch: fetchStats,
    lastRefresh,
  };
};


================================================
FILE: src/features/dashboard/pages/Billing.tsx
================================================
import { useState, useEffect } from 'react';
import { useOutletContext } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { StyledH1, StyledH2, StyledH3 } from '@/components/ui/styled-headers';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { 
  CreditCard, 
  Clock, 
  TrendingUp, 
  Calendar,
  AlertCircle,
  CheckCircle,
  Download,
  RefreshCw,
  Building,
  ChevronLeft,
  ChevronRight,
  ArrowUpDown,
  ArrowUp,
  ArrowDown,
  CalendarDays
} from 'lucide-react';
import { Tables } from '@/integrations/supabase/types';
import { useTranslation } from '@/hooks/useTranslation';
import { supabase } from '@/integrations/supabase/client';
import { format, startOfMonth, endOfMonth, differenceInMinutes, subMonths, isAfter } from 'date-fns';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

// Package interface
interface BillingPackage {
  slug: string;
  name: string;
  monthly_price: number | null;
  included_hours: number | null;
  overage_rate: number;
  color: string;
  features: any;
}

const Billing = () => {
  const { t } = useTranslation();
  const { userProfile, mosque } = useOutletContext<DashboardContext>();
  const [loading, setLoading] = useState(true);
  const [usageData, setUsageData] = useState({
    currentMonthHours: 0,
    lastMonthHours: 0,
    todayHours: 0,
    sessions: [] as any[]
  });
  const [mosqueUsageData, setMosqueUsageData] = useState<any[]>([]);
  const [selectedPeriod, setSelectedPeriod] = useState('current');
  const [selectedMonth, setSelectedMonth] = useState<Date | null>(null);
  const [availableMonths, setAvailableMonths] = useState<Date[]>([]);
  const [currentPackage, setCurrentPackage] = useState<BillingPackage | null>(null);
  const [allPackages, setAllPackages] = useState<BillingPackage[]>([]);
  const [savedBillingHistory, setSavedBillingHistory] = useState<any[]>([]);
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [sessionsPerPage] = useState(10); // Show 10 sessions per page
  
  // Sorting state
  const [sortField, setSortField] = useState<string>('created_at');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');

  useEffect(() => {
    fetchPackages();
    if (mosque) {
      fetchMosquePackage();
      fetchAvailableMonths();
    }
  }, [mosque]);

  useEffect(() => {
    setCurrentPage(1); // Reset to first page when period changes
    if (selectedPeriod === 'current') {
      fetchUsageData();
    } else if (selectedPeriod === 'custom' && selectedMonth) {
      fetchUsageDataForMonth(selectedMonth);
    } else {
      // For past months, fetch from billing_history
      fetchSavedBillingHistory();
    }
    if (userProfile?.is_super_admin) {
      fetchMosqueUsageData();
    }
  }, [userProfile, mosque, selectedPeriod, selectedMonth]);

  const fetchAvailableMonths = async () => {
    if (!mosque) return;
    
    try {
      // Get the earliest session date to determine available months
      const { data: earliestSession, error } = await supabase
        .from('room_sessions')
        .select('created_at')
        .eq('mosque_id', mosque.id)
        .order('created_at', { ascending: true })
        .limit(1)
        .single();

      if (error || !earliestSession) {
        console.log('No sessions found');
        return;
      }

      // Generate list of available months from earliest session to current month
      const months: Date[] = [];
      const earliestDate = new Date(earliestSession.created_at);
      const currentDate = new Date();
      
      let date = startOfMonth(earliestDate);
      const currentMonthStart = startOfMonth(currentDate);
      
      while (date < currentMonthStart) {
        months.push(new Date(date));
        date = new Date(date.getFullYear(), date.getMonth() + 1, 1);
      }
      
      // Reverse to show most recent first
      setAvailableMonths(months.reverse());
    } catch (error) {
      console.error('Error fetching available months:', error);
    }
  };

  const fetchUsageDataForMonth = async (month: Date) => {
    if (!userProfile) return;
    
    setLoading(true);
    try {
      const startDate = startOfMonth(month);
      const endDate = endOfMonth(month);

      // First check if we have saved billing history for this month
      const { data: billingData } = await supabase
        .from('billing_history')
        .select('*')
        .eq('mosque_id', mosque?.id)
        .eq('period_start', startDate.toISOString())
        .single();

      if (billingData) {
        // Use saved billing data
        setUsageData({
          currentMonthHours: billingData.used_hours || 0,
          lastMonthHours: 0,
          todayHours: 0,
          sessions: []
        });
        setSavedBillingHistory([billingData]);
      } else {
        // Fetch sessions for the selected month
        let query = supabase
          .from('room_sessions')
          .select(`
            *,
            room:rooms(
              *,
              mosque:Mosque(
                id,
                name,
                Subdomain
              )
            )
          `)
          .gte('started_at', startDate.toISOString())
          .lte('started_at', endDate.toISOString())
          .order('started_at', { ascending: false });

        if (!userProfile.is_super_admin && mosque) {
          query = query.eq('room.mosque_id', mosque.id);
        }

        const { data: sessions, error } = await query;
        if (error) throw error;

        // Calculate total hours
        let totalMinutes = 0;
        sessions?.forEach(session => {
          if (session.started_at && session.ended_at) {
            const minutes = differenceInMinutes(
              new Date(session.ended_at),
              new Date(session.started_at)
            );
            totalMinutes += minutes;
          }
        });

        setUsageData({
          currentMonthHours: totalMinutes / 60,
          lastMonthHours: 0,
          todayHours: 0,
          sessions: sessions || []
        });
        setSavedBillingHistory([]);
      }
    } catch (error) {
      console.error('Error fetching usage data for month:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchPackages = async () => {
    try {
      const { data, error } = await supabase
        .from('billing_packages')
        .select('*')
        .eq('is_active', true)
        .order('monthly_price', { ascending: true });

      if (error) throw error;
      setAllPackages(data || []);
    } catch (error) {
      console.error('Error fetching packages:', error);
    }
  };

  const fetchMosquePackage = async () => {
    if (!mosque) return;
    
    try {
      // First get the mosque's package_slug
      const { data: mosqueData, error: mosqueError } = await supabase
        .from('Mosque')
        .select('package_slug')
        .eq('id', mosque.id)
        .single();

      if (mosqueError) throw mosqueError;

      // If mosque has a package_slug, fetch the package details
      if (mosqueData?.package_slug) {
        const { data: packageData, error: packageError } = await supabase
          .from('billing_packages')
          .select('*')
          .eq('slug', mosqueData.package_slug)
          .single();

        if (packageError) throw packageError;
        setCurrentPackage(packageData);
      } else {
        // Default to professional if no package is set
        const { data: defaultPackage } = await supabase
          .from('billing_packages')
          .select('*')
          .eq('slug', 'professional')
          .single();
        
        setCurrentPackage(defaultPackage);
      }
    } catch (error) {
      console.error('Error fetching mosque package:', error);
      // Fallback to a default package structure
      setCurrentPackage({
        slug: 'professional',
        name: 'Professional',
        monthly_price: 99,
        included_hours: 20,
        overage_rate: 5,
        color: 'bg-purple-500',
        features: {}
      });
    }
  };

  const fetchSavedBillingHistory = async () => {
    if (!mosque) return;
    
    setLoading(true);
    try {
      const now = new Date();
      const startDate = startOfMonth(new Date(now.getFullYear(), now.getMonth() - 1));
      const endDate = endOfMonth(new Date(now.getFullYear(), now.getMonth() - 1));

      // Fetch saved billing history for the previous month
      const { data: billingData, error: billingError } = await supabase
        .from('billing_history')
        .select('*')
        .eq('mosque_id', mosque.id)
        .eq('period_start', startDate.toISOString())
        .single();

      if (billingData) {
        // Use saved billing data
        setUsageData({
          currentMonthHours: billingData.used_hours || 0,
          lastMonthHours: 0,
          todayHours: 0,
          sessions: [] // For saved history, we don't show individual sessions
        });
        setSavedBillingHistory([billingData]);
      } else {
        // If no saved data, fall back to calculating from sessions
        fetchUsageData();
      }
    } catch (error) {
      console.error('Error fetching billing history:', error);
      // Fall back to calculating from sessions
      fetchUsageData();
    } finally {
      setLoading(false);
    }
  };

  const fetchUsageData = async () => {
    if (!userProfile) return;
    
    setLoading(true);
    try {
      const now = new Date();
      const startDate = selectedPeriod === 'current' 
        ? startOfMonth(now)
        : startOfMonth(new Date(now.getFullYear(), now.getMonth() - 1));
      const endDate = selectedPeriod === 'current'
        ? endOfMonth(now)
        : endOfMonth(new Date(now.getFullYear(), now.getMonth() - 1));

      // Fetch sessions for the selected period
      let query = supabase
        .from('room_sessions')
        .select(`
          *,
          room:rooms(
            *,
            mosque:Mosque(
              id,
              name,
              Subdomain
            )
          )
        `)
        .gte('started_at', startDate.toISOString())
        .lte('started_at', endDate.toISOString())
        .order('started_at', { ascending: false });

      // Filter by mosque for non-super admins - filter through the room relationship
      if (!userProfile.is_super_admin && mosque) {
        query = query.eq('room.mosque_id', mosque.id);
      }

      const { data: sessions, error } = await query;

      if (error) throw error;

      // Calculate total hours
      let totalMinutes = 0;
      let todayMinutes = 0;
      const today = new Date().toDateString();

      sessions?.forEach(session => {
        // Use started_at and ended_at for room_sessions table
        if (session.started_at && session.ended_at) {
          const start = new Date(session.started_at);
          const end = new Date(session.ended_at);
          const minutes = differenceInMinutes(end, start);
          totalMinutes += minutes;

          if (start.toDateString() === today) {
            todayMinutes += minutes;
          }
        }
      });

      setUsageData({
        currentMonthHours: totalMinutes / 60,
        lastMonthHours: 0, // Would need to fetch last month's data
        todayHours: todayMinutes / 60,
        sessions: sessions || []
      });
    } catch (error) {
      console.error('Error fetching usage data:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchMosqueUsageData = async () => {
    try {
      const now = new Date();
      const startDate = startOfMonth(now);
      const endDate = endOfMonth(now);

      // Fetch all mosques
      const { data: mosques } = await supabase
        .from('Mosque')
        .select('*')
        .order('name');

      if (!mosques) return;

      // Fetch usage for each mosque
      const mosqueData = await Promise.all(
        mosques.map(async (mosque) => {
          const { data: sessions } = await supabase
            .from('room_sessions')
            .select('*')
            .eq('mosque_id', mosque.id)
            .gte('created_at', startDate.toISOString())
            .lte('created_at', endDate.toISOString())
            .eq('status', 'completed');

          let totalMinutes = 0;
          sessions?.forEach(session => {
            if (session.started_at && session.ended_at) {
              const minutes = differenceInMinutes(
                new Date(session.ended_at),
                new Date(session.started_at)
              );
              totalMinutes += minutes;
            }
          });

          const hours = totalMinutes / 60;
          // Use professional as default for calculation
          const tier = { monthly_price: 99, included_hours: 20, overage_rate: 5 };
          const overage = Math.max(0, hours - tier.included_hours);
          const overageCost = overage * tier.overage_rate;
          const totalCost = tier.monthly_price + overageCost;

          return {
            mosque,
            hours,
            sessions: sessions?.length || 0,
            tier,
            overage,
            overageCost,
            totalCost
          };
        })
      );

      setMosqueUsageData(mosqueData);
    } catch (error) {
      console.error('Error fetching mosque usage data:', error);
    }
  };

  const calculateOverage = () => {
    if (!currentPackage || !currentPackage.included_hours) return 0;
    const overage = Math.max(0, usageData.currentMonthHours - currentPackage.included_hours);
    return overage;
  };

  const calculateOverageCost = () => {
    if (!currentPackage) return 0;
    const overage = calculateOverage();
    return overage * currentPackage.overage_rate;
  };

  const usagePercentage = currentPackage?.included_hours 
    ? Math.min(100, (usageData.currentMonthHours / currentPackage.included_hours) * 100)
    : 0;

  // Sorting function
  const handleSort = (field: string) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('desc');
    }
  };

  // Sort sessions
  const sortedSessions = [...usageData.sessions].sort((a, b) => {
    let aVal: any;
    let bVal: any;

    switch (sortField) {
      case 'created_at':
        aVal = new Date(a.created_at).getTime();
        bVal = new Date(b.created_at).getTime();
        break;
      case 'room':
        aVal = a.room?.Title || a.room?.title || '';
        bVal = b.room?.Title || b.room?.title || '';
        break;
      case 'started_at':
        aVal = a.started_at ? new Date(a.started_at).getTime() : 0;
        bVal = b.started_at ? new Date(b.started_at).getTime() : 0;
        break;
      case 'ended_at':
        aVal = a.ended_at ? new Date(a.ended_at).getTime() : 0;
        bVal = b.ended_at ? new Date(b.ended_at).getTime() : 0;
        break;
      case 'duration':
        aVal = a.started_at && a.ended_at 
          ? differenceInMinutes(new Date(a.ended_at), new Date(a.started_at))
          : 0;
        bVal = b.started_at && b.ended_at
          ? differenceInMinutes(new Date(b.ended_at), new Date(b.started_at))
          : 0;
        break;
      case 'transcript_count':
        aVal = a.transcript_count || 0;
        bVal = b.transcript_count || 0;
        break;
      case 'sentence_count':
        aVal = a.sentence_count || 0;
        bVal = b.sentence_count || 0;
        break;
      case 'status':
        aVal = a.status || '';
        bVal = b.status || '';
        break;
      default:
        aVal = a[sortField];
        bVal = b[sortField];
    }

    if (sortDirection === 'asc') {
      return aVal > bVal ? 1 : -1;
    } else {
      return aVal < bVal ? 1 : -1;
    }
  });

  // Get sort icon
  const getSortIcon = (field: string) => {
    if (sortField !== field) {
      return <ArrowUpDown className="h-3 w-3 opacity-50" />;
    }
    return sortDirection === 'asc' 
      ? <ArrowUp className="h-3 w-3" />
      : <ArrowDown className="h-3 w-3" />;
  };

  const exportReport = () => {
    // Generate CSV content
    const csvHeaders = [
      'Session ID',
      'Date',
      'Room',
      'Mosque',
      'Start Time', 
      'End Time',
      'Duration (hours)',
      'Duration (minutes)',
      'Status',
      'Transcript Count',
      'Sentence Count'
    ];

    const csvRows = usageData.sessions.map((session: any) => {
      const startDate = session.started_at ? new Date(session.started_at) : null;
      const endDate = session.ended_at ? new Date(session.ended_at) : null;
      const durationMinutes = startDate && endDate 
        ? differenceInMinutes(endDate, startDate)
        : 0;
      const durationHours = durationMinutes / 60;

      return [
        session.id,
        format(new Date(session.created_at), 'yyyy-MM-dd'),
        session.room?.Title || session.room?.title || 'Untitled Room',
        session.room?.mosque?.name || mosque?.name || 'N/A',
        startDate ? format(startDate, 'yyyy-MM-dd HH:mm:ss') : 'N/A',
        endDate ? format(endDate, 'yyyy-MM-dd HH:mm:ss') : 'Still Active',
        durationHours.toFixed(2),
        durationMinutes.toString(),
        session.status || 'active',
        session.transcript_count || 0,
        session.sentence_count || 0
      ];
    });

    // Add summary rows
    csvRows.push([]);
    csvRows.push(['SUMMARY']);
    csvRows.push(['Period', selectedPeriod === 'current' ? 'Current Month' : 'Last Month']);
    csvRows.push(['Total Sessions', usageData.sessions.length.toString()]);
    csvRows.push(['Total Hours Used', usageData.currentMonthHours.toFixed(2)]);
    csvRows.push(['Included Hours', currentPackage?.included_hours?.toString() || 'Unlimited']);
    csvRows.push(['Overage Hours', calculateOverage().toFixed(2)]);
    csvRows.push(['Plan', currentPackage?.name || 'N/A']);
    csvRows.push(['Monthly Price', currentPackage?.monthly_price ? `€${currentPackage.monthly_price}` : 'Custom']);
    csvRows.push(['Overage Rate', `€${currentPackage?.overage_rate || 0}/hour`]);
    csvRows.push(['Overage Cost', `€${calculateOverageCost().toFixed(2)}`]);
    csvRows.push(['Total Estimated Cost', `€${((currentPackage?.monthly_price || 0) + calculateOverageCost()).toFixed(2)}`]);
    
    if (!userProfile?.is_super_admin && mosque) {
      csvRows.push(['Mosque', mosque.name]);
    }
    
    csvRows.push(['Report Generated', format(new Date(), 'yyyy-MM-dd HH:mm:ss')]);

    // Convert to CSV string
    const csvContent = [
      csvHeaders.join(','),
      ...csvRows.map(row => 
        row.map(cell => {
          // Escape cells containing commas or quotes
          const cellStr = String(cell || '');
          if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
            return `"${cellStr.replace(/"/g, '""')}"`;
          }
          return cellStr;
        }).join(',')
      )
    ].join('\n');

    // Create blob and download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    const fileName = `billing-report-${format(new Date(), 'yyyy-MM-dd')}-${selectedPeriod}.csv`;
    
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <StyledH1 className="text-foreground">{t('dashboard.billing')}</StyledH1>
          <p className="text-muted-foreground">
            {userProfile?.is_super_admin 
              ? 'System-wide usage and billing overview'
              : `Usage and billing for ${mosque?.name || 'your mosque'}`
            }
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={fetchUsageData}
            disabled={loading}
          >
            <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
            Refresh
          </Button>
          <Button 
            variant="outline" 
            size="sm"
            onClick={exportReport}
            disabled={loading || usageData.sessions.length === 0}
          >
            <Download className="h-4 w-4 mr-2" />
            Export Report
          </Button>
        </div>
      </div>

      {/* Current Plan Card */}
      {currentPackage && (
        <Card className="border-primary/20">
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <CardTitle className="text-lg font-medium">Current Plan</CardTitle>
              <Badge className={currentPackage.color + ' text-white'}>
                {currentPackage.name}
              </Badge>
            </div>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <p className="text-sm text-muted-foreground">Monthly Subscription</p>
                <p className="text-2xl font-bold">
                  {currentPackage.monthly_price ? `€${currentPackage.monthly_price}` : 'Custom'}
                </p>
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Included Hours</p>
                <p className="text-2xl font-bold">
                  {currentPackage.included_hours || 'Unlimited'}
                </p>
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Overage Rate</p>
                <p className="text-2xl font-bold">
                  {currentPackage.overage_rate > 0 ? `€${currentPackage.overage_rate}/hour` : 'N/A'}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Usage Statistics Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {/* Current Month Usage */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Current Month Usage</CardTitle>
            <Clock className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {usageData.currentMonthHours.toFixed(1)} hrs
            </div>
            <Progress value={usagePercentage} className="mt-2" />
            <p className="text-xs text-muted-foreground mt-2">
              {usageData.currentMonthHours.toFixed(1)} / {currentPackage?.included_hours || '∞'} hours used
            </p>
          </CardContent>
        </Card>

        {/* Today's Usage */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Today's Usage</CardTitle>
            <Calendar className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {usageData.todayHours.toFixed(1)} hrs
            </div>
            <p className="text-xs text-muted-foreground mt-2">
              {format(new Date(), 'MMMM d, yyyy')}
            </p>
          </CardContent>
        </Card>

        {/* Overage Hours */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Overage Hours</CardTitle>
            {calculateOverage() > 0 ? (
              <AlertCircle className="h-4 w-4 text-warning" />
            ) : (
              <CheckCircle className="h-4 w-4 text-success" />
            )}
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {calculateOverage().toFixed(1)} hrs
            </div>
            <p className="text-xs text-muted-foreground mt-2">
              {calculateOverage() > 0 
                ? `€${calculateOverageCost().toFixed(2)} additional charges`
                : 'Within included allowance'
              }
            </p>
          </CardContent>
        </Card>

        {/* Estimated Total */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Estimated Total</CardTitle>
            <CreditCard className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              €{((currentPackage?.monthly_price || 0) + calculateOverageCost()).toFixed(2)}
            </div>
            <p className="text-xs text-muted-foreground mt-2">
              For {format(new Date(), 'MMMM yyyy')}
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Usage History with Detailed Sessions */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>Usage History</CardTitle>
            <div className="flex gap-2">
              <Button
                variant={selectedPeriod === 'current' ? 'default' : 'outline'}
                size="sm"
                onClick={() => {
                  setSelectedPeriod('current');
                  setSelectedMonth(null);
                }}
              >
                Current Month
              </Button>
              <Button
                variant={selectedPeriod === 'last' ? 'default' : 'outline'}
                size="sm"
                onClick={() => {
                  setSelectedPeriod('last');
                  setSelectedMonth(null);
                }}
              >
                Last Month
              </Button>
              <Select
                value={selectedMonth ? format(selectedMonth, 'yyyy-MM') : ''}
                onValueChange={(value) => {
                  if (value) {
                    const [year, month] = value.split('-');
                    const date = new Date(parseInt(year), parseInt(month) - 1, 1);
                    setSelectedMonth(date);
                    setSelectedPeriod('custom');
                  }
                }}
                disabled={availableMonths.length === 0}
              >
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Select month">
                    <div className="flex items-center gap-2">
                      <CalendarDays className="h-4 w-4" />
                      {selectedMonth ? format(selectedMonth, 'MMMM yyyy') : 'Previous months'}
                    </div>
                  </SelectValue>
                </SelectTrigger>
                <SelectContent>
                  {availableMonths.length > 0 ? (
                    availableMonths.map((month) => (
                      <SelectItem 
                        key={format(month, 'yyyy-MM')} 
                        value={format(month, 'yyyy-MM')}
                      >
                        {format(month, 'MMMM yyyy')}
                      </SelectItem>
                    ))
                  ) : (
                    <div className="px-2 py-4 text-center text-sm text-muted-foreground">
                      No previous months available
                    </div>
                  )}
                </SelectContent>
              </Select>
            </div>
          </div>
          {savedBillingHistory.length > 0 && (selectedPeriod === 'last' || selectedPeriod === 'custom') && (
            <div className="mt-4 p-3 bg-muted/50 rounded-lg">
              <p className="text-sm text-muted-foreground">
                <AlertCircle className="inline h-4 w-4 mr-1" />
                {selectedPeriod === 'custom' && selectedMonth
                  ? `Showing ${savedBillingHistory.length > 0 ? 'saved billing snapshot' : 'usage data'} for ${format(selectedMonth, 'MMMM yyyy')}`
                  : `Showing saved billing snapshot from ${format(new Date(savedBillingHistory[0].period_start), 'MMMM yyyy')}`
                }
              </p>
            </div>
          )}
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="h-48 flex items-center justify-center">
              <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : savedBillingHistory.length > 0 && (selectedPeriod === 'last' || selectedPeriod === 'custom') ? (
            // Show saved billing summary for past months
            <div className="space-y-4">
              {savedBillingHistory.map((billing) => (
                <div key={billing.id} className="border rounded-lg p-4">
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div>
                      <p className="text-sm text-muted-foreground">Total Hours Used</p>
                      <p className="text-xl font-bold">{billing.used_hours?.toFixed(2) || 0} hrs</p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground">Total Sessions</p>
                      <p className="text-xl font-bold">{billing.session_count || 0}</p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground">Transcripts</p>
                      <p className="text-xl font-bold">{billing.transcript_count || 0}</p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground">Translations</p>
                      <p className="text-xl font-bold">{billing.sentence_count || 0}</p>
                    </div>
                  </div>
                  <div className="mt-4 pt-4 border-t">
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                      <div>
                        <p className="text-sm text-muted-foreground">Package</p>
                        <p className="font-medium">{billing.package_name}</p>
                      </div>
                      <div>
                        <p className="text-sm text-muted-foreground">Base Price</p>
                        <p className="font-medium">€{billing.base_price}</p>
                      </div>
                      <div>
                        <p className="text-sm text-muted-foreground">Overage Cost</p>
                        <p className="font-medium text-warning">€{billing.overage_cost?.toFixed(2) || 0}</p>
                      </div>
                      <div>
                        <p className="text-sm text-muted-foreground">Total Cost</p>
                        <p className="text-xl font-bold">€{billing.total_cost?.toFixed(2) || 0}</p>
                      </div>
                      <div>
                        <p className="text-sm text-muted-foreground">Payment Status</p>
                        <Badge variant={billing.payment_status === 'paid' ? 'default' : 'secondary'}>
                          {billing.payment_status || 'Pending'}
                        </Badge>
                      </div>
                      <div>
                        <p className="text-sm text-muted-foreground">Saved On</p>
                        <p className="text-sm">{format(new Date(billing.created_at), 'MMM d, yyyy h:mm a')}</p>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="border-b">
                    <th 
                      className="text-left p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('created_at')}
                    >
                      <div className="flex items-center gap-1">
                        Date
                        {getSortIcon('created_at')}
                      </div>
                    </th>
                    <th 
                      className="text-left p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('room')}
                    >
                      <div className="flex items-center gap-1">
                        Room
                        {getSortIcon('room')}
                      </div>
                    </th>
                    <th 
                      className="text-left p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('started_at')}
                    >
                      <div className="flex items-center gap-1">
                        Start Time
                        {getSortIcon('started_at')}
                      </div>
                    </th>
                    <th 
                      className="text-left p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('ended_at')}
                    >
                      <div className="flex items-center gap-1">
                        End Time
                        {getSortIcon('ended_at')}
                      </div>
                    </th>
                    <th 
                      className="text-right p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('duration')}
                    >
                      <div className="flex items-center justify-end gap-1">
                        Duration
                        {getSortIcon('duration')}
                      </div>
                    </th>
                    <th 
                      className="text-right p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('transcript_count')}
                    >
                      <div className="flex items-center justify-end gap-1">
                        Transcripts
                        {getSortIcon('transcript_count')}
                      </div>
                    </th>
                    <th 
                      className="text-right p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('sentence_count')}
                    >
                      <div className="flex items-center justify-end gap-1">
                        Sentences
                        {getSortIcon('sentence_count')}
                      </div>
                    </th>
                    <th 
                      className="text-right p-2 font-medium text-sm cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort('status')}
                    >
                      <div className="flex items-center justify-end gap-1">
                        Status
                        {getSortIcon('status')}
                      </div>
                    </th>
                  </tr>
                </thead>
                <tbody>
                  {/* Paginate sorted sessions */}
                  {sortedSessions
                    .slice((currentPage - 1) * sessionsPerPage, currentPage * sessionsPerPage)
                    .map((session: any) => {
                    const duration = session.started_at && session.ended_at
                      ? differenceInMinutes(new Date(session.ended_at), new Date(session.started_at)) / 60
                      : 0;
                    
                    return (
                      <tr key={session.id} className="border-b hover:bg-muted/50">
                        <td className="p-2 text-sm">
                          {format(new Date(session.created_at), 'MMM d, yyyy')}
                        </td>
                        <td className="p-2">
                          <p className="text-sm font-medium">
                            {session.room?.Title || session.room?.title || 'Untitled Room'}
                          </p>
                          {userProfile?.is_super_admin && session.room?.mosque?.name && (
                            <p className="text-xs text-muted-foreground">{session.room.mosque.name}</p>
                          )}
                        </td>
                        <td className="p-2 text-sm">
                          {session.started_at 
                            ? format(new Date(session.started_at), 'h:mm a')
                            : '-'
                          }
                        </td>
                        <td className="p-2 text-sm">
                          {session.ended_at 
                            ? format(new Date(session.ended_at), 'h:mm a')
                            : '-'
                          }
                        </td>
                        <td className="text-right p-2">
                          {duration > 0 ? (
                            <div>
                              <p className="text-sm font-medium">{duration.toFixed(2)} hrs</p>
                              <p className="text-xs text-muted-foreground">
                                ({Math.round(duration * 60)} min)
                              </p>
                            </div>
                          ) : (
                            <span className="text-sm text-muted-foreground">-</span>
                          )}
                        </td>
                        <td className="text-right p-2 text-sm">
                          {session.transcript_count || 0}
                        </td>
                        <td className="text-right p-2 text-sm">
                          {session.sentence_count || 0}
                        </td>
                        <td className="text-right p-2">
                          {session.status === 'completed' ? (
                            <Badge variant="outline" className="text-xs">Completed</Badge>
                          ) : session.status === 'active' ? (
                            <Badge variant="default" className="text-xs">Active</Badge>
                          ) : (
                            <Badge variant="secondary" className="text-xs">{session.status || 'In Progress'}</Badge>
                          )}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
                {usageData.sessions.length > 0 && (
                  <tfoot>
                    <tr className="font-medium bg-muted/50">
                      <td colSpan={4} className="p-2 text-sm">
                        Total Hours
                      </td>
                      <td className="text-right p-2 text-sm">
                        {usageData.currentMonthHours.toFixed(2)} hrs
                      </td>
                      <td className="text-right p-2 text-sm">
                        {usageData.sessions.reduce((sum, s) => sum + (s.transcript_count || 0), 0)}
                      </td>
                      <td className="text-right p-2 text-sm">
                        {usageData.sessions.reduce((sum, s) => sum + (s.sentence_count || 0), 0)}
                      </td>
                      <td className="text-right p-2">
                        {currentPackage?.included_hours && usageData.currentMonthHours > currentPackage.included_hours ? (
                          <Badge variant="destructive" className="text-xs">
                            {(usageData.currentMonthHours - currentPackage.included_hours).toFixed(1)} hrs over
                          </Badge>
                        ) : currentPackage?.included_hours ? (
                          <Badge variant="default" className="text-xs">
                            {(currentPackage.included_hours - usageData.currentMonthHours).toFixed(1)} hrs left
                          </Badge>
                        ) : (
                          <Badge variant="default" className="text-xs">Unlimited</Badge>
                        )}
                      </td>
                    </tr>
                  </tfoot>
                )}
              </table>
              {usageData.sessions.length === 0 && !loading && (
                <div className="text-center py-8 text-muted-foreground">
                  <p>No sessions found for this period</p>
                  <p className="text-sm mt-2">Sessions will appear here once you start using the platform</p>
                </div>
              )}
              
              {/* Pagination Controls */}
              {sortedSessions.length > sessionsPerPage && (
                <div className="mt-4 flex items-center justify-between px-2">
                  <div className="text-sm text-muted-foreground">
                    Showing {((currentPage - 1) * sessionsPerPage) + 1} - {Math.min(currentPage * sessionsPerPage, sortedSessions.length)} of {sortedSessions.length} sessions
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-4 w-4 mr-1" />
                      Previous
                    </Button>
                    
                    {/* Page numbers */}
                    {(() => {
                      const totalPages = Math.ceil(sortedSessions.length / sessionsPerPage);
                      const pages = [];
                      const maxVisiblePages = 5;
                      
                      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
                      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                      
                      if (endPage - startPage < maxVisiblePages - 1) {
                        startPage = Math.max(1, endPage - maxVisiblePages + 1);
                      }
                      
                      for (let i = startPage; i <= endPage; i++) {
                        pages.push(
                          <Button
                            key={i}
                            variant={currentPage === i ? "default" : "outline"}
                            size="sm"
                            onClick={() => setCurrentPage(i)}
                            className="w-8 h-8"
                          >
                            {i}
                          </Button>
                        );
                      }
                      
                      return pages;
                    })()}
                    
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(prev => Math.min(Math.ceil(sortedSessions.length / sessionsPerPage), prev + 1))}
                      disabled={currentPage === Math.ceil(sortedSessions.length / sessionsPerPage)}
                    >
                      Next
                      <ChevronRight className="h-4 w-4 ml-1" />
                    </Button>
                  </div>
                </div>
              )}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Mosque Billing Overview for Super Admin */}
      {userProfile?.is_super_admin && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Building className="h-5 w-5" />
              Mosque Billing Overview
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="border-b">
                    <th className="text-left p-2 font-medium text-sm">Mosque</th>
                    <th className="text-right p-2 font-medium text-sm">Plan</th>
                    <th className="text-right p-2 font-medium text-sm">Hours Used</th>
                    <th className="text-right p-2 font-medium text-sm">Sessions</th>
                    <th className="text-right p-2 font-medium text-sm">Overage</th>
                    <th className="text-right p-2 font-medium text-sm">Total Cost</th>
                    <th className="text-right p-2 font-medium text-sm">Status</th>
                  </tr>
                </thead>
                <tbody>
                  {mosqueUsageData.map((data) => (
                    <tr key={data.mosque.id} className="border-b hover:bg-muted/50">
                      <td className="p-2">
                        <div>
                          <p className="font-medium text-sm">{data.mosque.name}</p>
                          <p className="text-xs text-muted-foreground">{data.mosque.subdomain}</p>
                        </div>
                      </td>
                      <td className="text-right p-2">
                        <Badge variant="outline">{data.tier.name}</Badge>
                      </td>
                      <td className="text-right p-2">
                        <div>
                          <p className="text-sm">{data.hours.toFixed(1)} hrs</p>
                          <Progress 
                            value={Math.min(100, (data.hours / data.tier.includedHours) * 100)} 
                            className="w-20 h-2 ml-auto mt-1"
                          />
                        </div>
                      </td>
                      <td className="text-right p-2 text-sm">
                        {data.sessions}
                      </td>
                      <td className="text-right p-2">
                        {data.overage > 0 ? (
                          <div>
                            <p className="text-sm text-warning">{data.overage.toFixed(1)} hrs</p>
                            <p className="text-xs text-muted-foreground">€{data.overageCost.toFixed(2)}</p>
                          </div>
                        ) : (
                          <span className="text-sm text-muted-foreground">-</span>
                        )}
                      </td>
                      <td className="text-right p-2">
                        <p className="font-medium text-sm">€{data.totalCost.toFixed(2)}</p>
                      </td>
                      <td className="text-right p-2">
                        {data.overage > 0 ? (
                          <Badge variant="destructive" className="text-xs">Over Limit</Badge>
                        ) : data.hours / data.tier.includedHours > 0.8 ? (
                          <Badge variant="secondary" className="text-xs">Near Limit</Badge>
                        ) : (
                          <Badge variant="default" className="text-xs">Normal</Badge>
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
                {mosqueUsageData.length > 0 && (
                  <tfoot>
                    <tr className="font-medium">
                      <td className="p-2 text-sm">Total</td>
                      <td className="text-right p-2"></td>
                      <td className="text-right p-2 text-sm">
                        {mosqueUsageData.reduce((sum, d) => sum + d.hours, 0).toFixed(1)} hrs
                      </td>
                      <td className="text-right p-2 text-sm">
                        {mosqueUsageData.reduce((sum, d) => sum + d.sessions, 0)}
                      </td>
                      <td className="text-right p-2 text-sm">
                        €{mosqueUsageData.reduce((sum, d) => sum + d.overageCost, 0).toFixed(2)}
                      </td>
                      <td className="text-right p-2 text-sm">
                        €{mosqueUsageData.reduce((sum, d) => sum + d.totalCost, 0).toFixed(2)}
                      </td>
                      <td></td>
                    </tr>
                  </tfoot>
                )}
              </table>
              {mosqueUsageData.length === 0 && !loading && (
                <div className="text-center py-8 text-muted-foreground">
                  No billing data available for this period
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Upgrade Plan CTA */}
      {currentPackage?.slug !== 'enterprise' && (
        <Card className="bg-gradient-to-r from-primary/10 to-purple-500/10 border-primary/20">
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-lg font-semibold">Need more hours?</h3>
                <p className="text-sm text-muted-foreground mt-1">
                  Upgrade your plan to get more included hours and lower overage rates
                </p>
              </div>
              <Button>
                <TrendingUp className="h-4 w-4 mr-2" />
                Upgrade Plan
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

    </div>
  );
};

export default Billing;


================================================
FILE: src/features/dashboard/pages/Mosques.tsx
================================================
import { useState, useEffect } from 'react';
import { useOutletContext, useNavigate } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { StyledH1, StyledHeader } from '@/components/ui/styled-headers';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Badge } from '@/components/ui/badge';
import { Building, Plus, Search, Loader2, Edit, Trash2, Users, Eye, Download, Upload, CreditCard } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import MosqueCreationWizard from '@/features/mosque/components/MosqueCreationWizard';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;
type BillingPackage = Tables<'billing_packages'>;

interface MosqueWithPackage extends Mosque {
  billing_package?: BillingPackage | null;
}

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

const mosqueSchema = z.object({
  name: z.string().min(2).max(100),
  subdomain: z.string().min(2).max(50).regex(/^[a-z0-9-]+$/, 'Only lowercase letters, numbers, and hyphens allowed'),
});

type MosqueFormData = z.infer<typeof mosqueSchema>;

const Mosques = () => {
  const { t } = useTranslation();
  const navigate = useNavigate();
  const { toast } = useToast();
  const { userProfile } = useOutletContext<DashboardContext>();
  
  const [mosques, setMosques] = useState<MosqueWithPackage[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedMosque, setSelectedMosque] = useState<MosqueWithPackage | null>(null);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isCreating, setIsCreating] = useState(false);

  const form = useForm<MosqueFormData>({
    resolver: zodResolver(mosqueSchema),
    defaultValues: {
      name: '',
      subdomain: '',
    },
  });

  // Check if user is super admin
  if (!userProfile?.is_super_admin) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card>
          <CardContent className="pt-6">
            <p className="text-center text-muted-foreground">
              {t('common.unauthorized')}
            </p>
          </CardContent>
        </Card>
      </div>
    );
  }

  const fetchMosques = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('Mosque')
        .select(`
          *,
          billing_package:billing_packages(
            slug,
            name,
            monthly_price,
            included_hours
          )
        `)
        .order('name');

      if (error) throw error;
      setMosques(data || []);
    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchMosquesFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMosques();

    // Real-time subscription
    const channel = supabase
      .channel('mosques-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'Mosque' },
        () => {
          fetchMosques();
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);

  const onEditSubmit = async (data: MosqueFormData) => {
    if (!selectedMosque) return;
    
    setIsCreating(true);
    try {
      const { error } = await supabase
        .from('Mosque')
        .update({
          name: data.name,
          Subdomain: data.subdomain,
        })
        .eq('id', selectedMosque.id);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.mosques.mosqueUpdated'),
      });

      setIsEditDialogOpen(false);
      form.reset();
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
    } finally {
      setIsCreating(false);
    }
  };

  const handleDelete = async () => {
    if (!selectedMosque) return;
    
    try {
      const { error } = await supabase
        .from('Mosque')
        .delete()
        .eq('id', selectedMosque.id);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.mosques.mosqueDeleted'),
      });

      setIsDeleteDialogOpen(false);
      setSelectedMosque(null);
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.deleteFailed'),
        variant: 'destructive',
      });
    }
  };

  const filteredMosques = mosques.filter(mosque =>
    mosque.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    mosque.Subdomain?.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // Since the database doesn't have is_active field, all mosques are considered active
  const activeMosques = filteredMosques;
  const inactiveMosques: MosqueWithPackage[] = [];

  const displayedMosques = filteredMosques;

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="flex items-center justify-between">
        <div>
          <StyledH1 className="text-foreground">{t('dashboard.mosques')}</StyledH1>
          <p className="text-muted-foreground">
            {t('superAdmin.mosques.description')}
          </p>
        </div>
        <Button onClick={() => setIsCreateDialogOpen(true)}>
          <Plus className="mr-2 h-4 w-4" />
          {t('superAdmin.stats.addNewMosque')}
        </Button>
      </div>

      {/* Search and Filters */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <StyledHeader variant="h2">{t('superAdmin.mosques.title')}</StyledHeader>
            <div className="flex items-center gap-2">
              <Button variant="outline" size="sm">
                <Download className="mr-2 h-4 w-4" />
                {t('common.export')}
              </Button>
              <Button variant="outline" size="sm">
                <Upload className="mr-2 h-4 w-4" />
                {t('common.import')}
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div className="mb-4">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder={t('common.search')}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10"
              />
            </div>
          </div>

          <div>
              {loading ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="h-8 w-8 animate-spin text-primary" />
                  <span className="ml-2 text-muted-foreground">{t('superAdmin.mosques.loadingMosques')}</span>
                </div>
              ) : displayedMosques.length === 0 ? (
                <div className="text-center py-8">
                  <Building className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                  <StyledHeader variant="h3" className="mb-2">{t('superAdmin.mosques.noMosquesFound')}</StyledHeader>
                  <p className="text-muted-foreground mb-4">
                    {searchQuery 
                      ? t('common.noResultsFound')
                      : t('superAdmin.mosques.noMosquesDescription')
                    }
                  </p>
                  {!searchQuery && (
                    <Button onClick={() => setIsCreateDialogOpen(true)}>
                      <Plus className="mr-2 h-4 w-4" />
                      {t('superAdmin.mosques.addFirstMosque')}
                    </Button>
                  )}
                </div>
              ) : (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>{t('superAdmin.mosques.mosqueName')}</TableHead>
                      <TableHead>{t('superAdmin.mosques.subdomain')}</TableHead>
                      <TableHead>
                        <div className="flex items-center gap-1">
                          <CreditCard className="h-4 w-4" />
                          Package
                        </div>
                      </TableHead>
                      <TableHead>{t('common.id')}</TableHead>
                      <TableHead className="text-right">{t('common.actions')}</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {displayedMosques.map((mosque) => (
                      <TableRow key={mosque.id}>
                        <TableCell className="font-medium">{mosque.name}</TableCell>
                        <TableCell>
                          {mosque.Subdomain ? (
                            <code className="bg-muted px-2 py-1 rounded text-sm">
                              {mosque.Subdomain}
                            </code>
                          ) : (
                            <span className="text-muted-foreground">{t('common.notSet')}</span>
                          )}
                        </TableCell>
                        <TableCell>
                          {mosque.billing_package ? (
                            <Badge variant="secondary">
                              {mosque.billing_package.name}
                            </Badge>
                          ) : mosque.package_slug ? (
                            <Badge variant="outline">
                              {mosque.package_slug}
                            </Badge>
                          ) : (
                            <span className="text-muted-foreground">No package</span>
                          )}
                        </TableCell>
                        <TableCell className="text-muted-foreground">
                          {mosque.id}
                        </TableCell>
                        <TableCell className="text-right">
                          <div className="flex items-center justify-end gap-2">
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => navigate(`/dashboard/users?mosque=${mosque.id}`)}
                            >
                              <Users className="h-4 w-4" />
                            </Button>
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setSelectedMosque(mosque);
                                form.reset({
                                  name: mosque.name,
                                  subdomain: mosque.Subdomain || '',
                                });
                                setIsEditDialogOpen(true);
                              }}
                            >
                              <Edit className="h-4 w-4" />
                            </Button>
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setSelectedMosque(mosque);
                                setIsDeleteDialogOpen(true);
                              }}
                              className="text-destructive hover:text-destructive"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </div>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
          </div>
        </CardContent>
      </Card>

      {/* Create Mosque Dialog with Wizard */}
      <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
        <DialogContent className="max-w-3xl max-h-[90vh] overflow-y-auto">
          <MosqueCreationWizard
            onSuccess={() => {
              setIsCreateDialogOpen(false);
              fetchMosques();
            }}
            onCancel={() => setIsCreateDialogOpen(false)}
          />
        </DialogContent>
      </Dialog>

      {/* Edit Mosque Dialog */}
      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="font-poppins lowercase" style={{ letterSpacing: '-0.058em' }}>{t('superAdmin.mosques.editMosque')}</DialogTitle>
            <DialogDescription>
              {t('superAdmin.mosques.editDescription')}
            </DialogDescription>
          </DialogHeader>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onEditSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('superAdmin.onboarding.mosqueName')}</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="subdomain"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{t('superAdmin.mosques.subdomain')}</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <DialogFooter>
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setIsEditDialogOpen(false)}
                  disabled={isCreating}
                >
                  {t('common.cancel')}
                </Button>
                <Button type="submit" disabled={isCreating}>
                  {isCreating ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      {t('common.saving')}
                    </>
                  ) : (
                    t('common.save')
                  )}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="font-poppins lowercase" style={{ letterSpacing: '-0.058em' }}>{t('common.confirmDelete')}</DialogTitle>
            <DialogDescription>
              {t('superAdmin.mosques.deleteConfirmation').replace('{name}', selectedMosque?.name || '')}
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setIsDeleteDialogOpen(false)}
            >
              {t('common.cancel')}
            </Button>
            <Button
              variant="destructive"
              onClick={handleDelete}
            >
              {t('common.delete')}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default Mosques;


================================================
FILE: src/features/dashboard/pages/Overview.tsx
================================================
import { useOutletContext } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Building, Plus, Users, Settings, Activity, History, FileText, Video, MessageSquare, TrendingUp, RefreshCw } from 'lucide-react';
import { Tables } from '@/integrations/supabase/types';
import { useTranslation } from '@/hooks/useTranslation';
import { useNavigate } from 'react-router-dom';
import { useSuperAdminStats } from '@/features/dashboard/hooks/useSuperAdminStats';
import { useMosqueData } from '@/features/dashboard/hooks/useMosqueData';
import { LoadingSkeleton } from '@/components/ui/loading-skeleton';
import { EmptyState } from '@/components/ui/empty-state';
import { Button } from '@/components/ui/button';
import { formatDistanceToNow } from 'date-fns';
import { StyledH1, StyledH2, StyledH3, StyledHeader } from '@/components/ui/styled-headers';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

const Overview = () => {
  const { t } = useTranslation();
  const navigate = useNavigate();
  const { userProfile } = useOutletContext<DashboardContext>();
  
  // Use custom hooks for data fetching with 30-second refresh
  const superAdminStats = useSuperAdminStats(30000);
  const mosqueData = useMosqueData({ mosqueId: userProfile?.mosque_id || 0 });

  // Determine which stats to use based on user role
  const stats = userProfile?.is_super_admin ? {
    totalMosques: superAdminStats.stats.totalMosques,
    totalUsers: superAdminStats.stats.totalUsers,
    activeRooms: superAdminStats.stats.activeRooms,
    totalRooms: superAdminStats.stats.totalRooms,
    activeSessions: superAdminStats.stats.activeSessions,
    totalTemplates: superAdminStats.stats.totalTemplates,
  } : {
    totalMosques: 1,
    totalUsers: 0, // Would need a mosque-specific user count
    activeRooms: 0, // Would need mosque-specific room count
    totalRooms: 0,
    activeSessions: 0,
    totalTemplates: 0,
  };

  const loading = userProfile?.is_super_admin ? superAdminStats.loading : mosqueData.loading;

  const quickActions = userProfile?.is_super_admin ? [
    { 
      title: t('superAdmin.stats.addNewMosque'), 
      icon: Plus, 
      onClick: () => navigate('/dashboard/mosques'),
      color: 'bg-primary dark:bg-primary',
      iconColor: 'text-primary-foreground',
      description: t('superAdmin.onboarding.title')
    },
    { 
      title: t('dashboard.rooms'), 
      icon: Video, 
      onClick: () => navigate('/dashboard/rooms'),
      color: 'bg-blue-500 dark:bg-blue-600',
      iconColor: 'text-white',
      description: t('superAdmin.rooms.description')
    },
    { 
      title: t('dashboard.sessions'), 
      icon: History, 
      onClick: () => navigate('/dashboard/sessions'),
      color: 'bg-green-500 dark:bg-green-600',
      iconColor: 'text-white',
      description: t('superAdmin.sessions.description')
    },
    { 
      title: t('dashboard.users'), 
      icon: Users, 
      onClick: () => navigate('/dashboard/users'),
      color: 'bg-purple-500 dark:bg-purple-600',
      iconColor: 'text-white',
      description: t('superAdmin.users.description')
    }
  ] : [
    { 
      title: t('dashboard.history'), 
      icon: History, 
      onClick: () => navigate('/history'),
      color: 'bg-primary dark:bg-primary',
      iconColor: 'text-primary-foreground'
    },
    { 
      title: t('dashboard.templates'), 
      icon: FileText, 
      onClick: () => navigate('/dashboard/templates'),
      color: 'bg-blue-500 dark:bg-blue-600',
      iconColor: 'text-white'
    },
    { 
      title: t('dashboard.settings'), 
      icon: Settings, 
      onClick: () => navigate('/dashboard/settings'),
      color: 'bg-green-500 dark:bg-green-600',
      iconColor: 'text-white'
    }
  ];

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <StyledH1 className="text-foreground">{t('dashboard.overview')}</StyledH1>
          <p className="text-muted-foreground">
            {userProfile?.is_super_admin 
              ? t('superAdmin.stats.systemOverview')
              : t('mosqueAdmin.stats.mosqueOverview')
            }
          </p>
        </div>
        {userProfile?.is_super_admin && (
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => superAdminStats.refetch()}
              disabled={superAdminStats.loading}
            >
              <RefreshCw className={`h-4 w-4 mr-2 ${superAdminStats.loading ? 'animate-spin' : ''}`} />
              {t('common.refresh')}
            </Button>
            <span className="text-sm text-muted-foreground">
              {t('common.lastUpdated')}: {formatDistanceToNow(superAdminStats.lastRefresh, { addSuffix: true })}
            </span>
          </div>
        )}
      </div>

      {/* Stats Grid */}
      {loading ? (
        <LoadingSkeleton variant="stats" />
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {userProfile?.is_super_admin ? (
          <>
            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer" onClick={() => navigate('/dashboard/mosques')}>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('superAdmin.stats.totalMosques')}</StyledHeader>
                <Building className="h-4 w-4 text-muted-foreground group-hover:text-primary transition-colors" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{loading ? '...' : stats.totalMosques}</div>
                <p className="text-xs text-muted-foreground">
                  {t('superAdmin.stats.activeTenants')}
                </p>
              </CardContent>
            </Card>

            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer" onClick={() => navigate('/dashboard/users')}>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('dashboard.users')}</StyledHeader>
                <Users className="h-4 w-4 text-muted-foreground group-hover:text-primary transition-colors" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{loading ? '...' : stats.totalUsers}</div>
                <p className="text-xs text-muted-foreground">
                  {t('superAdmin.stats.registeredUsers')}
                </p>
              </CardContent>
            </Card>

            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer" onClick={() => navigate('/dashboard/rooms')}>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('dashboard.rooms')}</StyledHeader>
                <Video className="h-4 w-4 text-muted-foreground group-hover:text-primary transition-colors" />
              </CardHeader>
              <CardContent>
                <div className="flex items-baseline gap-2">
                  <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{loading ? '...' : stats.activeRooms}</div>
                  <span className="text-sm text-muted-foreground">/ {stats.totalRooms}</span>
                </div>
                <p className="text-xs text-muted-foreground">
                  {t('mosqueAdmin.stats.currentlyActive')}
                </p>
              </CardContent>
            </Card>

            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer" onClick={() => navigate('/dashboard/sessions')}>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('dashboard.sessions')}</StyledHeader>
                <div className="flex items-center gap-2">
                  {stats.activeSessions > 0 && (
                    <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
                  )}
                  <Activity className="h-4 w-4 text-muted-foreground group-hover:text-primary transition-colors" />
                </div>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{loading ? '...' : stats.activeSessions}</div>
                <p className="text-xs text-muted-foreground">
                  {t('superAdmin.sessions.activeSessions')}
                </p>
              </CardContent>
            </Card>
          </>
        ) : (
          <>
            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer">
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('dashboard.users')}</StyledHeader>
                <Users className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{loading ? '...' : stats.totalUsers}</div>
                <p className="text-xs text-muted-foreground">
                  {t('superAdmin.stats.registeredUsers')}
                </p>
              </CardContent>
            </Card>

            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer">
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('mosqueAdmin.stats.activeRooms')}</StyledHeader>
                <Activity className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{loading ? '...' : stats.activeRooms}</div>
                <p className="text-xs text-muted-foreground">
                  {t('mosqueAdmin.stats.currentlyActive')}
                </p>
              </CardContent>
            </Card>

            <Card className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer">
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <StyledHeader variant='h4' className="text-sm font-medium">{t('dashboard.templates')}</StyledHeader>
                <Settings className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{loading ? '...' : stats.totalTemplates}</div>
                <p className="text-xs text-muted-foreground">
                  {t('superAdmin.stats.configuredTemplates')}
                </p>
              </CardContent>
            </Card>
          </>
        )}
        </div>
      )}

      {/* Quick Actions */}
      <div>
        <StyledH2 className="mb-4">{t('dashboard.quickActions')}</StyledH2>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
          {quickActions.map((action, index) => (
            <Card 
              key={index} 
              className="group cursor-pointer hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200"
              onClick={action.onClick}
            >
              <CardContent className="p-4">
                <div className="flex items-start gap-3">
                  <div className={`p-2 rounded-lg ${action.color} group-hover:scale-110 transition-transform duration-200`}>
                    <action.icon className={`h-5 w-5 ${action.iconColor}`} />
                  </div>
                  <div className="flex-1">
                    <h3 className="font-poppins font-medium text-sm lowercase group-hover:text-primary transition-colors duration-200" style={{ letterSpacing: '-0.058em' }}>
                      {action.title}
                    </h3>
                    {action.description && (
                      <p className="text-xs text-muted-foreground mt-1 line-clamp-2">
                        {action.description}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>

      {/* Recent Activity */}
      <Card className="border-border/50 bg-card/80 backdrop-blur-sm hover:shadow-lg hover:border-primary/50 transition-all duration-200">
        <CardHeader>
          <StyledHeader variant='h2'>{t('dashboard.recentActivity')}</StyledHeader>
        </CardHeader>
        <CardContent>
          <EmptyState
            icon={Activity}
            title={t('dashboard.noRecentActivity')}
            description={t('dashboard.noRecentActivityDescription')}
          />
        </CardContent>
      </Card>
    </div>
  );
};

export default Overview;


================================================
FILE: src/features/dashboard/pages/Prompts.tsx
================================================
import { useOutletContext } from 'react-router-dom';
import { useTranslation } from '@/hooks/useTranslation';
import { Tables } from '@/integrations/supabase/types';
import PromptTemplateManager from '@/features/mosque/components/PromptTemplateManager';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

const Prompts = () => {
  const { t } = useTranslation();
  const { userProfile } = useOutletContext<DashboardContext>();

  if (!userProfile?.is_super_admin) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <p className="text-center text-muted-foreground">
          {t('common.unauthorized')}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div>
        <h1 className="text-2xl font-bold tracking-tight">{t('dashboard.prompts')}</h1>
        <p className="text-muted-foreground">
          {t('superAdmin.prompts.description')}
        </p>
      </div>

      {/* Prompts Content - Reusing existing component */}
      <PromptTemplateManager />
    </div>
  );
};

export default Prompts;


================================================
FILE: src/features/dashboard/pages/Rooms.tsx
================================================
import { useState, useEffect } from 'react';
import { useOutletContext } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Video, Search, Loader2, Users as UsersIcon, Filter, Activity, Pause, Play, ChevronLeft, ChevronRight } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { LoadingSkeleton } from '@/components/ui/loading-skeleton';
import { EmptyState } from '@/components/ui/empty-state';
import { StyledH1, StyledHeader } from '@/components/ui/styled-headers';
import {
  Pagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from '@/components/ui/pagination';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;
type Room = Tables<'rooms'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

interface RoomWithMosque extends Room {
  mosque?: Mosque;
}

const Rooms = () => {
  const { t } = useTranslation();
  const { toast } = useToast();
  const { userProfile } = useOutletContext<DashboardContext>();
  
  const [rooms, setRooms] = useState<RoomWithMosque[]>([]);
  const [mosques, setMosques] = useState<Mosque[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedMosqueFilter, setSelectedMosqueFilter] = useState<string>('all');
  const [selectedStatusFilter, setSelectedStatusFilter] = useState<string>('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [pageSize] = useState(50); // Show 50 items per page
  const totalPages = Math.ceil(totalCount / pageSize);

  // Check if user is super admin
  if (!userProfile?.is_super_admin) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card>
          <CardContent className="pt-6">
            <p className="text-center text-muted-foreground">
              {t('common.unauthorized')}
            </p>
          </CardContent>
        </Card>
      </div>
    );
  }

  useEffect(() => {
    fetchMosques();
  }, []);

  useEffect(() => {
    fetchRooms();
    
    // Real-time subscription
    const channel = supabase
      .channel('all-rooms-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'rooms' },
        () => {
          fetchRooms();
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [currentPage, selectedMosqueFilter, selectedStatusFilter, searchQuery]);

  const fetchRooms = async () => {
    try {
      setLoading(true);
      
      // Build query with filters
      let query = supabase
        .from('rooms')
        .select(`
          *,
          mosque:Mosque(
            id,
            name,
            Subdomain
          )
        `, { count: 'exact' });
      
      // Apply filters
      if (searchQuery) {
        query = query.or(`Title.ilike.%${searchQuery}%,Livekit_room_name.ilike.%${searchQuery}%`);
      }
      
      if (selectedMosqueFilter !== 'all') {
        query = query.eq('mosque_id', selectedMosqueFilter);
      }
      
      if (selectedStatusFilter !== 'all') {
        query = query.eq('status', selectedStatusFilter);
      }
      
      // Apply pagination
      const from = (currentPage - 1) * pageSize;
      const to = from + pageSize - 1;
      
      query = query
        .order('created_at', { ascending: false })
        .range(from, to);

      const { data, error, count } = await query;

      if (error) throw error;
      
      setRooms(data || []);
      setTotalCount(count || 0);
    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchRoomsFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  const fetchMosques = async () => {
    try {
      const { data, error } = await supabase
        .from('Mosque')
        .select('*')
        .order('name');

      if (error) throw error;
      setMosques(data || []);
    } catch (error) {
      }
  };

  const getStatusBadge = (status: string) => {
    const statusConfig = {
      active: { 
        label: 'Live', 
        variant: 'destructive' as const, 
        icon: Play,
        className: 'bg-red-500/10 text-red-600 border-red-500/20 hover:bg-red-500/20 animate-pulse-subtle'
      },
      pending: { 
        label: t('common.pending'), 
        variant: 'secondary' as const, 
        icon: Pause,
        className: ''
      },
      inactive: { 
        label: t('common.inactive'), 
        variant: 'outline' as const, 
        icon: Pause,
        className: ''
      },
    };

    const config = statusConfig[status as keyof typeof statusConfig] || statusConfig.inactive;
    const Icon = config.icon;

    return (
      <Badge 
        variant={config.variant} 
        className={`flex items-center gap-1 ${config.className}`}
      >
        {status === 'active' && (
          <div className="h-2 w-2 bg-red-500 rounded-full animate-pulse-glow mr-1" />
        )}
        <Icon className="h-3 w-3" />
        {config.label}
      </Badge>
    );
  };

  // Handle search with debounce
  const [searchDebounce, setSearchDebounce] = useState<NodeJS.Timeout>();
  
  const handleSearchChange = (value: string) => {
    setSearchQuery(value);
    setCurrentPage(1); // Reset to first page on search
    
    if (searchDebounce) {
      clearTimeout(searchDebounce);
    }
    
    const timeout = setTimeout(() => {
      // Fetch will be triggered by useEffect
    }, 500);
    
    setSearchDebounce(timeout);
  };

  // Handle filter changes
  const handleMosqueFilterChange = (value: string) => {
    setSelectedMosqueFilter(value);
    setCurrentPage(1); // Reset to first page on filter change
  };

  const handleStatusFilterChange = (value: string) => {
    setSelectedStatusFilter(value);
    setCurrentPage(1); // Reset to first page on filter change
  };

  // Stats - fetch separately to show total counts
  const [stats, setStats] = useState({
    total: 0,
    active: 0,
    pending: 0,
    inactive: 0,
  });

  const fetchStats = async () => {
    try {
      const [totalResult, activeResult, pendingResult, inactiveResult] = await Promise.all([
        supabase.from('rooms').select('*', { count: 'exact', head: true }),
        supabase.from('rooms').select('*', { count: 'exact', head: true }).eq('status', 'active'),
        supabase.from('rooms').select('*', { count: 'exact', head: true }).eq('status', 'pending'),
        supabase.from('rooms').select('*', { count: 'exact', head: true }).eq('status', 'inactive'),
      ]);

      setStats({
        total: totalResult.count || 0,
        active: activeResult.count || 0,
        pending: pendingResult.count || 0,
        inactive: inactiveResult.count || 0,
      });
    } catch (error) {
      console.error('Error fetching room stats:', error);
    }
  };

  useEffect(() => {
    fetchStats();
  }, []);

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <StyledH1 className="text-foreground">{t('dashboard.rooms')}</StyledH1>
          <p className="text-muted-foreground">
            {t('superAdmin.rooms.description')}
          </p>
        </div>
      </div>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.total')}</StyledHeader>
            <Video className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.total}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.rooms.totalRooms')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.active')}</StyledHeader>
            <Activity className="h-4 w-4 text-green-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.active}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.rooms.activeRooms')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.pending')}</StyledHeader>
            <Pause className="h-4 w-4 text-yellow-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.pending}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.rooms.pendingRooms')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.inactive')}</StyledHeader>
            <Pause className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.inactive}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.rooms.inactiveRooms')}
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Rooms Table */}
      <Card>
        <CardHeader>
          <StyledHeader variant="h2">{t('superAdmin.rooms.allRooms')}</StyledHeader>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col sm:flex-row gap-4 mb-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder={t('superAdmin.rooms.searchPlaceholder')}
                value={searchQuery}
                onChange={(e) => handleSearchChange(e.target.value)}
                className="pl-10"
              />
            </div>
            <Select value={selectedMosqueFilter} onValueChange={handleMosqueFilterChange}>
              <SelectTrigger className="w-full sm:w-[200px]">
                <Filter className="mr-2 h-4 w-4" />
                <SelectValue placeholder={t('superAdmin.rooms.filterByMosque')} />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">{t('common.allMosques')}</SelectItem>
                {mosques.map((mosque) => (
                  <SelectItem key={mosque.id} value={mosque.id.toString()}>
                    {mosque.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Select value={selectedStatusFilter} onValueChange={handleStatusFilterChange}>
              <SelectTrigger className="w-full sm:w-[150px]">
                <SelectValue placeholder={t('superAdmin.rooms.filterByStatus')} />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">{t('common.allStatuses')}</SelectItem>
                <SelectItem value="active">{t('common.active')}</SelectItem>
                <SelectItem value="pending">{t('common.pending')}</SelectItem>
                <SelectItem value="inactive">{t('common.inactive')}</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {loading ? (
            <LoadingSkeleton variant="table" rows={5} columns={6} />
          ) : rooms.length === 0 ? (
            <EmptyState
              icon={Video}
              title={t('superAdmin.rooms.noRoomsFound')}
              description={
                searchQuery || selectedMosqueFilter !== 'all' || selectedStatusFilter !== 'all'
                  ? t('common.noResultsFound')
                  : t('superAdmin.rooms.noRoomsDescription')
              }
            />
          ) : (
            <div className="overflow-x-auto">
              <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>{t('common.title')}</TableHead>
                  <TableHead>{t('common.mosque')}</TableHead>
                  <TableHead>{t('common.status')}</TableHead>
                  <TableHead>{t('mosqueAdmin.rooms.languages')}</TableHead>
                  <TableHead>{t('common.createdAt')}</TableHead>
                  <TableHead className="text-right">{t('common.actions')}</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {rooms.map((room) => (
                  <TableRow key={room.id}>
                    <TableCell>
                      <div>
                        <div className="font-medium">{room.Title}</div>
                        <div className="text-sm text-muted-foreground">
                          {room.Livekit_room_name}
                        </div>
                      </div>
                    </TableCell>
                    <TableCell>
                      {room.mosque ? (
                        <Badge variant="outline">{room.mosque.name}</Badge>
                      ) : (
                        <span className="text-muted-foreground">{t('common.unknown')}</span>
                      )}
                    </TableCell>
                    <TableCell>{getStatusBadge(room.status || 'inactive')}</TableCell>
                    <TableCell>
                      <div className="text-sm">
                        <div>{t('common.from')}: {room.transcription_language || 'ar'}</div>
                        <div>{t('common.to')}: {room.translation__language || 'nl'}</div>
                      </div>
                    </TableCell>
                    <TableCell className="text-muted-foreground">
                      {new Date(room.created_at).toLocaleDateString()}
                    </TableCell>
                    <TableCell className="text-right">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => {
                          toast({
                            title: t('common.comingSoon'),
                            description: t('superAdmin.rooms.monitoringComingSoon'),
                          });
                        }}
                      >
                        <Activity className="h-4 w-4 mr-2" />
                        {t('common.monitor')}
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
              </Table>
            </div>
          )}
          
          {/* Pagination */}
          {totalPages > 1 && (
            <div className="mt-4 flex items-center justify-between px-2">
              <div className="text-sm text-muted-foreground">
                {t('common.showing')} {((currentPage - 1) * pageSize) + 1} - {Math.min(currentPage * pageSize, totalCount)} {t('common.of')} {totalCount} {t('common.rooms')}
              </div>
              <Pagination>
                <PaginationContent>
                  <PaginationItem>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      {t('common.previous')}
                    </Button>
                  </PaginationItem>
                  
                  {/* Page numbers */}
                  {[...Array(Math.min(5, totalPages))].map((_, idx) => {
                    let pageNum;
                    if (totalPages <= 5) {
                      pageNum = idx + 1;
                    } else if (currentPage <= 3) {
                      pageNum = idx + 1;
                    } else if (currentPage >= totalPages - 2) {
                      pageNum = totalPages - 4 + idx;
                    } else {
                      pageNum = currentPage - 2 + idx;
                    }
                    
                    return (
                      <PaginationItem key={idx}>
                        <Button
                          variant={currentPage === pageNum ? "default" : "outline"}
                          size="sm"
                          onClick={() => setCurrentPage(pageNum)}
                        >
                          {pageNum}
                        </Button>
                      </PaginationItem>
                    );
                  })}
                  
                  <PaginationItem>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                      disabled={currentPage === totalPages}
                    >
                      {t('common.next')}
                      <ChevronRight className="h-4 w-4" />
                    </Button>
                  </PaginationItem>
                </PaginationContent>
              </Pagination>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default Rooms;


================================================
FILE: src/features/dashboard/pages/Sessions.tsx
================================================
import { useState, useEffect } from 'react';
import { useOutletContext, useNavigate } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { StyledH1, StyledHeader } from '@/components/ui/styled-headers';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import { History, Search, Loader2, Play, Calendar, Filter, FileText, ChevronLeft, ChevronRight, MessageSquare } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { format } from 'date-fns';
import { LoadingSkeleton } from '@/components/ui/loading-skeleton';
import { EmptyState } from '@/components/ui/empty-state';
import {
  Pagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from '@/components/ui/pagination';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;
type Session = Tables<'room_sessions'>;
type Room = Tables<'rooms'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

interface SessionWithDetails extends Session {
  room?: Room & { mosque?: Mosque };
}

const Sessions = () => {
  const { t } = useTranslation();
  const { toast } = useToast();
  const navigate = useNavigate();
  const { userProfile } = useOutletContext<DashboardContext>();
  
  const [sessions, setSessions] = useState<SessionWithDetails[]>([]);
  const [mosques, setMosques] = useState<Mosque[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedMosqueFilter, setSelectedMosqueFilter] = useState<string>('all');
  const [dateFilter, setDateFilter] = useState<string>('all');
  const [qualityFilter, setQualityFilter] = useState(false);
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [pageSize] = useState(50); // Show 50 items per page
  const totalPages = Math.ceil(totalCount / pageSize);

  // Check if user is super admin
  if (!userProfile?.is_super_admin) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card>
          <CardContent className="pt-6">
            <p className="text-center text-muted-foreground">
              {t('common.unauthorized')}
            </p>
          </CardContent>
        </Card>
      </div>
    );
  }

  useEffect(() => {
    fetchMosques();
  }, []);
  
  useEffect(() => {
    fetchSessions();
    fetchStats(); // Fetch stats whenever filters change
  }, [currentPage, selectedMosqueFilter, dateFilter, searchQuery, qualityFilter]);

  // Shared filter builder function
  const applyFilters = (query: any, hasRoomJoin: boolean = false) => {
    // Apply search filter
    if (searchQuery) {
      query = query.ilike('id', `%${searchQuery}%`);
    }
    
    // Apply mosque filter - only if we have room join
    if (selectedMosqueFilter !== 'all' && hasRoomJoin) {
      query = query.eq('room.mosque_id', selectedMosqueFilter);
    }

    // Apply date filter
    const now = new Date();
    if (dateFilter === 'today') {
      const startOfDay = new Date(now.setHours(0, 0, 0, 0));
      query = query.gte('started_at', startOfDay.toISOString());
    } else if (dateFilter === 'week') {
      const weekAgo = new Date(now.setDate(now.getDate() - 7));
      query = query.gte('started_at', weekAgo.toISOString());
    } else if (dateFilter === 'month') {
      const monthAgo = new Date(now.setMonth(now.getMonth() - 1));
      query = query.gte('started_at', monthAgo.toISOString());
    }
    
    // Apply quality filter
    if (qualityFilter) {
      // Filter out sessions with:
      // - Duration less than 4 minutes (need ended_at to calculate)
      // - OR transcript_count less than 100
      query = query.gte('transcript_count', 100);
      // For duration filter, we'll handle it in post-processing since it requires calculation
    }
    
    return query;
  };

  const fetchSessions = async () => {
    try {
      setLoading(true);
      
      let query = supabase
        .from('room_sessions')
        .select(`
          *,
          room:rooms(
            *,
            mosque:Mosque(
              id,
              name,
              Subdomain
            )
          )
        `, { count: 'exact' });

      // Apply shared filters (true because fetchSessions has room join)
      query = applyFilters(query, true);
      
      // Apply pagination
      const from = (currentPage - 1) * pageSize;
      const to = from + pageSize - 1;
      
      query = query
        .order('started_at', { ascending: false })
        .range(from, to);

      const { data, error, count } = await query;

      if (error) throw error;
      
      // Post-process for quality filter (duration check)
      let filteredData = data || [];
      if (qualityFilter && filteredData.length > 0) {
        filteredData = filteredData.filter(session => {
          // Check transcript count (already filtered in query, but double-check)
          if ((session.transcript_count || 0) < 100) return false;
          
          // Check duration (only for completed sessions)
          if (session.ended_at) {
            const durationMs = new Date(session.ended_at).getTime() - new Date(session.started_at).getTime();
            const durationMinutes = durationMs / (1000 * 60);
            if (durationMinutes < 4) return false;
          }
          
          return true;
        });
      }
      
      setSessions(filteredData);
      setTotalCount(count || 0);
    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchSessionsFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  const fetchMosques = async () => {
    try {
      const { data, error } = await supabase
        .from('Mosque')
        .select('*')
        .order('name');

      if (error) throw error;
      setMosques(data || []);
    } catch (error) {
      }
  };

  const getSessionDuration = (startTime: string, endTime?: string | null) => {
    const start = new Date(startTime);
    const end = endTime ? new Date(endTime) : new Date();
    const durationMs = end.getTime() - start.getTime();
    const hours = Math.floor(durationMs / (1000 * 60 * 60));
    const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    return `${minutes}m`;
  };

  const getStatusBadge = (endTime?: string | null) => {
    if (endTime) {
      return <Badge variant="secondary">{t('common.completed')}</Badge>;
    }
    return <Badge variant="default">{t('common.active')}</Badge>;
  };

  // Handle search with debounce
  const [searchDebounce, setSearchDebounce] = useState<NodeJS.Timeout>();
  
  const handleSearchChange = (value: string) => {
    setSearchQuery(value);
    setCurrentPage(1); // Reset to first page on search
    
    if (searchDebounce) {
      clearTimeout(searchDebounce);
    }
    
    const timeout = setTimeout(() => {
      // Fetch will be triggered by useEffect
    }, 500);
    
    setSearchDebounce(timeout);
  };

  // Handle filter changes
  const handleMosqueFilterChange = (value: string) => {
    setSelectedMosqueFilter(value);
    setCurrentPage(1); // Reset to first page on filter change
  };

  const handleDateFilterChange = (value: string) => {
    setDateFilter(value);
    setCurrentPage(1); // Reset to first page on filter change
  };

  // Stats - fetch separately to show total counts
  const [stats, setStats] = useState({
    total: 0,
    active: 0,
    completed: 0,
    avgDuration: 0,
    avgSentences: 0,
  });

  const fetchStats = async () => {
    try {
      // Base query with room join for mosque filtering
      const baseSelect = selectedMosqueFilter !== 'all' 
        ? `*, room:rooms!inner(mosque_id)` 
        : '*';
      
      // Create queries with filters
      let totalQuery = supabase
        .from('room_sessions')
        .select(baseSelect, { count: 'exact', head: true });
      
      let activeQuery = supabase
        .from('room_sessions')
        .select(baseSelect, { count: 'exact', head: true })
        .is('ended_at', null);
      
      let completedQuery = supabase
        .from('room_sessions')
        .select(selectedMosqueFilter !== 'all' 
          ? `started_at, ended_at, room:rooms!inner(mosque_id)` 
          : 'started_at, ended_at')
        .not('ended_at', 'is', null)
        .limit(100);

      // Apply shared filters to all queries (true when mosque filter needs room join)
      totalQuery = applyFilters(totalQuery, selectedMosqueFilter !== 'all');
      activeQuery = applyFilters(activeQuery, selectedMosqueFilter !== 'all');
      completedQuery = applyFilters(completedQuery, selectedMosqueFilter !== 'all');

      const [totalResult, activeResult, completedResult] = await Promise.all([
        totalQuery,
        activeQuery,
        completedQuery,
      ]);

      // Calculate average duration from a sample
      let avgDuration = 0;
      if (completedResult.data && completedResult.data.length > 0) {
        const totalDuration = completedResult.data.reduce((acc, s) => {
          const duration = new Date(s.ended_at!).getTime() - new Date(s.started_at).getTime();
          return acc + duration;
        }, 0);
        avgDuration = totalDuration / completedResult.data.length / (1000 * 60); // in minutes
      }

      // Get sentence counts for average calculation
      let sentenceQuery = supabase
        .from('room_sessions')
        .select(selectedMosqueFilter !== 'all' 
          ? `sentence_count, transcript_count, started_at, ended_at, room:rooms!inner(mosque_id)` 
          : 'sentence_count, transcript_count, started_at, ended_at');
      
      sentenceQuery = applyFilters(sentenceQuery, selectedMosqueFilter !== 'all');
      const sentenceResult = await sentenceQuery;
      
      // Filter for quality if needed and calculate average sentences
      let filteredForStats = sentenceResult.data || [];
      if (qualityFilter && filteredForStats.length > 0) {
        filteredForStats = filteredForStats.filter(session => {
          // Check transcript count
          if ((session.transcript_count || 0) < 100) return false;
          
          // Check duration (only for completed sessions)
          if (session.ended_at) {
            const durationMs = new Date(session.ended_at).getTime() - new Date(session.started_at).getTime();
            const durationMinutes = durationMs / (1000 * 60);
            if (durationMinutes < 4) return false;
          }
          
          return true;
        });
      }
      
      // Calculate average sentences per session
      let avgSentences = 0;
      if (filteredForStats.length > 0) {
        const totalSentences = filteredForStats.reduce((sum, session) => 
          sum + (session.sentence_count || 0), 0);
        avgSentences = totalSentences / filteredForStats.length;
      }
      
      // Adjust counts based on quality filter
      const qualityFilteredTotal = qualityFilter ? filteredForStats.length : (totalResult.count || 0);
      const qualityFilteredActive = qualityFilter 
        ? filteredForStats.filter(s => !s.ended_at).length 
        : (activeResult.count || 0);
      const qualityFilteredCompleted = qualityFilteredTotal - qualityFilteredActive;

      setStats({
        total: qualityFilteredTotal,
        active: qualityFilteredActive,
        completed: qualityFilteredCompleted,
        avgDuration: Math.round(avgDuration),
        avgSentences: Math.round(avgSentences),
      });
    } catch (error) {
      console.error('Error fetching session stats:', error);
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <StyledH1 className="text-foreground">{t('dashboard.sessions')}</StyledH1>
          <p className="text-muted-foreground">
            {t('superAdmin.sessions.description')}
          </p>
        </div>
      </div>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.total')}</StyledHeader>
            <History className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.total}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.sessions.totalSessions')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.active')}</StyledHeader>
            <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.active}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.sessions.activeSessions')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.completed')}</StyledHeader>
            <FileText className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.completed}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.sessions.completedSessions')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.avgDuration')}</StyledHeader>
            <Calendar className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{Math.round(stats.avgDuration)}m</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.sessions.averageDuration')}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <StyledHeader variant="h4" className="text-sm font-medium">{t('common.avgSentences')}</StyledHeader>
            <MessageSquare className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold font-poppins" style={{ letterSpacing: '-0.058em' }}>{stats.avgSentences}</div>
            <p className="text-xs text-muted-foreground">
              {t('superAdmin.sessions.averageSentences')}
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Sessions Table */}
      <Card>
        <CardHeader>
          <StyledHeader variant="h2">{t('superAdmin.sessions.sessionHistory')}</StyledHeader>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col sm:flex-row gap-4 mb-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder={t('superAdmin.sessions.searchPlaceholder')}
                value={searchQuery}
                onChange={(e) => handleSearchChange(e.target.value)}
                className="pl-10"
              />
            </div>
            <div className="flex items-center space-x-2">
              <Checkbox 
                id="quality-filter"
                checked={qualityFilter}
                onCheckedChange={(checked) => {
                  setQualityFilter(checked as boolean);
                  setCurrentPage(1); // Reset to first page on filter change
                }}
              />
              <label 
                htmlFor="quality-filter" 
                className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer"
              >
                Hide low quality
              </label>
            </div>
            <Select value={selectedMosqueFilter} onValueChange={handleMosqueFilterChange}>
              <SelectTrigger className="w-full sm:w-[200px]">
                <Filter className="mr-2 h-4 w-4" />
                <SelectValue placeholder={t('superAdmin.sessions.filterByMosque')} />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">{t('common.allMosques')}</SelectItem>
                {mosques.map((mosque) => (
                  <SelectItem key={mosque.id} value={mosque.id.toString()}>
                    {mosque.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Select value={dateFilter} onValueChange={handleDateFilterChange}>
              <SelectTrigger className="w-full sm:w-[150px]">
                <Calendar className="mr-2 h-4 w-4" />
                <SelectValue placeholder={t('superAdmin.sessions.filterByDate')} />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">{t('common.allTime')}</SelectItem>
                <SelectItem value="today">{t('common.today')}</SelectItem>
                <SelectItem value="week">{t('common.lastWeek')}</SelectItem>
                <SelectItem value="month">{t('common.lastMonth')}</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {loading ? (
            <LoadingSkeleton variant="table" rows={5} columns={7} />
          ) : sessions.length === 0 ? (
            <EmptyState
              icon={History}
              title={t('superAdmin.sessions.noSessionsFound')}
              description={
                searchQuery || selectedMosqueFilter !== 'all' || dateFilter !== 'all'
                  ? t('common.noResultsFound')
                  : t('superAdmin.sessions.noSessionsDescription')
              }
            />
          ) : (
            <div className="overflow-x-auto">
              <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>{t('common.room')}</TableHead>
                  <TableHead>{t('common.mosque')}</TableHead>
                  <TableHead>{t('common.status')}</TableHead>
                  <TableHead>{t('common.startTime')}</TableHead>
                  <TableHead>{t('common.duration')}</TableHead>
                  <TableHead>{t('common.transcripts')}</TableHead>
                  <TableHead>{t('common.sentences')}</TableHead>
                  <TableHead className="text-right">{t('common.actions')}</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {sessions.map((session) => (
                  <TableRow key={session.id}>
                    <TableCell>
                      <div>
                        <div className="font-medium">{session.room?.Title || t('common.unknown')}</div>
                        <div className="text-sm text-muted-foreground">
                          ID: {session.id}
                        </div>
                      </div>
                    </TableCell>
                    <TableCell>
                      {session.room?.mosque ? (
                        <Badge variant="outline">{session.room.mosque.name}</Badge>
                      ) : (
                        <span className="text-muted-foreground">{t('common.unknown')}</span>
                      )}
                    </TableCell>
                    <TableCell>{getStatusBadge(session.ended_at)}</TableCell>
                    <TableCell className="text-muted-foreground">
                      {format(new Date(session.started_at), 'MMM d, yyyy HH:mm')}
                    </TableCell>
                    <TableCell>
                      {getSessionDuration(session.started_at, session.ended_at)}
                    </TableCell>
                    <TableCell>
                      <Badge variant="secondary">
                        {session.transcript_count || 0}
                      </Badge>
                    </TableCell>
                    <TableCell>
                      <Badge variant="outline">
                        {session.sentence_count || 0}
                      </Badge>
                    </TableCell>
                    <TableCell className="text-right">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => navigate(`/session/${session.id}`)}
                        disabled={!session.ended_at}
                      >
                        <Play className="h-4 w-4 mr-2" />
                        {t('common.replay')}
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
              </Table>
            </div>
          )}
          
          {/* Pagination */}
          {totalPages > 1 && (
            <div className="mt-4 flex items-center justify-between px-2">
              <div className="text-sm text-muted-foreground">
                {t('common.showing')} {((currentPage - 1) * pageSize) + 1} - {Math.min(currentPage * pageSize, totalCount)} {t('common.of')} {totalCount} {t('common.sessions')}
              </div>
              <Pagination>
                <PaginationContent>
                  <PaginationItem>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      {t('common.previous')}
                    </Button>
                  </PaginationItem>
                  
                  {/* Page numbers */}
                  {[...Array(Math.min(5, totalPages))].map((_, idx) => {
                    let pageNum;
                    if (totalPages <= 5) {
                      pageNum = idx + 1;
                    } else if (currentPage <= 3) {
                      pageNum = idx + 1;
                    } else if (currentPage >= totalPages - 2) {
                      pageNum = totalPages - 4 + idx;
                    } else {
                      pageNum = currentPage - 2 + idx;
                    }
                    
                    return (
                      <PaginationItem key={idx}>
                        <Button
                          variant={currentPage === pageNum ? "default" : "outline"}
                          size="sm"
                          onClick={() => setCurrentPage(pageNum)}
                        >
                          {pageNum}
                        </Button>
                      </PaginationItem>
                    );
                  })}
                  
                  <PaginationItem>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                      disabled={currentPage === totalPages}
                    >
                      {t('common.next')}
                      <ChevronRight className="h-4 w-4" />
                    </Button>
                  </PaginationItem>
                </PaginationContent>
              </Pagination>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default Sessions;


================================================
FILE: src/features/dashboard/pages/Settings.tsx
================================================
import { useState } from 'react';
import { useOutletContext } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { StyledH1, StyledHeader } from '@/components/ui/styled-headers';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Switch } from '@/components/ui/switch';
import { Separator } from '@/components/ui/separator';
import { Settings as SettingsIcon, User, Shield, Bell, Database, Globe, Key, Monitor } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

const profileSchema = z.object({
  full_name: z.string().min(2).max(100),
  email: z.string().email(),
});

const securitySchema = z.object({
  current_password: z.string().min(6),
  new_password: z.string().min(6),
  confirm_password: z.string().min(6),
}).refine((data) => data.new_password === data.confirm_password, {
  message: "Passwords don't match",
  path: ["confirm_password"],
});

const publicDisplaySchema = z.object({
  inactivity_timeout: z.number().min(10).max(600), // 10 seconds to 10 minutes
});

type ProfileFormData = z.infer<typeof profileSchema>;
type SecurityFormData = z.infer<typeof securitySchema>;
type PublicDisplayFormData = z.infer<typeof publicDisplaySchema>;

const Settings = () => {
  const { t } = useTranslation();
  const { toast } = useToast();
  const { userProfile, mosque } = useOutletContext<DashboardContext>();
  const [isUpdating, setIsUpdating] = useState(false);

  const profileForm = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      full_name: userProfile?.full_name || '',
      email: userProfile?.email || '',
    },
  });

  const securityForm = useForm<SecurityFormData>({
    resolver: zodResolver(securitySchema),
    defaultValues: {
      current_password: '',
      new_password: '',
      confirm_password: '',
    },
  });

  const publicDisplayForm = useForm<PublicDisplayFormData>({
    resolver: zodResolver(publicDisplaySchema),
    defaultValues: {
      inactivity_timeout: (mosque?.public_display_settings as any)?.inactivity_timeout || 60, // Default to 60 seconds
    },
  });

  const onProfileSubmit = async (data: ProfileFormData) => {
    if (!userProfile) return;
    
    setIsUpdating(true);
    try {
      const { error } = await supabase
        .from('users')
        .update({
          full_name: data.full_name,
        })
        .eq('id', userProfile.id);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('settings.profileUpdated'),
      });
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
    } finally {
      setIsUpdating(false);
    }
  };

  const onSecuritySubmit = async (data: SecurityFormData) => {
    setIsUpdating(true);
    try {
      const { error } = await supabase.auth.updateUser({
        password: data.new_password,
      });

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('settings.passwordUpdated'),
      });

      securityForm.reset();
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
    } finally {
      setIsUpdating(false);
    }
  };

  const onPublicDisplaySubmit = async (data: PublicDisplayFormData) => {
    if (!mosque) return;
    
    setIsUpdating(true);
    try {
      const { error } = await supabase
        .from('Mosque')
        .update({
          public_display_settings: {
            inactivity_timeout: data.inactivity_timeout
          }
        })
        .eq('id', mosque.id);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('settings.publicDisplayUpdated'),
      });
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
    } finally {
      setIsUpdating(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div>
        <StyledH1 className="text-foreground">{t('dashboard.settings')}</StyledH1>
        <p className="text-muted-foreground">
          {t('settings.description')}
        </p>
      </div>

      <Tabs defaultValue="profile" className="space-y-6">
        <TabsList>
          <TabsTrigger value="profile">
            <User className="mr-2 h-4 w-4" />
            {t('settings.profile')}
          </TabsTrigger>
          <TabsTrigger value="security">
            <Shield className="mr-2 h-4 w-4" />
            {t('settings.security')}
          </TabsTrigger>
          <TabsTrigger value="notifications">
            <Bell className="mr-2 h-4 w-4" />
            {t('settings.notifications')}
          </TabsTrigger>
          <TabsTrigger value="publicDisplay">
            <Monitor className="mr-2 h-4 w-4" />
            {t('settings.publicDisplay')}
          </TabsTrigger>
          {userProfile?.is_super_admin && (
            <TabsTrigger value="system">
              <Database className="mr-2 h-4 w-4" />
              {t('settings.system')}
            </TabsTrigger>
          )}
        </TabsList>

        <TabsContent value="profile">
          <Card>
            <CardHeader>
              <StyledHeader variant="h2">{t('settings.profileSettings')}</StyledHeader>
              <CardDescription>
                {t('settings.profileDescription')}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Form {...profileForm}>
                <form onSubmit={profileForm.handleSubmit(onProfileSubmit)} className="space-y-4">
                  <FormField
                    control={profileForm.control}
                    name="full_name"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('settings.fullName')}</FormLabel>
                        <FormControl>
                          <Input {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={profileForm.control}
                    name="email"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('common.email')}</FormLabel>
                        <FormControl>
                          <Input {...field} disabled />
                        </FormControl>
                        <FormDescription>
                          {t('settings.emailCannotChange')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  {!userProfile?.is_super_admin && mosque && (
                    <div className="space-y-2">
                      <Label>{t('common.mosque')}</Label>
                      <div className="flex items-center gap-2">
                        <Badge variant="outline">{mosque.name}</Badge>
                        {mosque.Subdomain && (
                          <code className="text-sm bg-muted px-2 py-1 rounded">
                            {mosque.Subdomain}
                          </code>
                        )}
                      </div>
                    </div>
                  )}
                  <Button type="submit" disabled={isUpdating}>
                    {isUpdating ? t('common.saving') : t('common.save')}
                  </Button>
                </form>
              </Form>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="security">
          <Card>
            <CardHeader>
              <StyledHeader variant="h2">{t('settings.securitySettings')}</StyledHeader>
              <CardDescription>
                {t('settings.securityDescription')}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Form {...securityForm}>
                <form onSubmit={securityForm.handleSubmit(onSecuritySubmit)} className="space-y-4">
                  <FormField
                    control={securityForm.control}
                    name="current_password"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('settings.currentPassword')}</FormLabel>
                        <FormControl>
                          <Input type="password" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={securityForm.control}
                    name="new_password"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('settings.newPassword')}</FormLabel>
                        <FormControl>
                          <Input type="password" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={securityForm.control}
                    name="confirm_password"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('settings.confirmPassword')}</FormLabel>
                        <FormControl>
                          <Input type="password" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <Button type="submit" disabled={isUpdating}>
                    {isUpdating ? t('common.updating') : t('settings.updatePassword')}
                  </Button>
                </form>
              </Form>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="notifications">
          <Card>
            <CardHeader>
              <StyledHeader variant="h2">{t('settings.notificationSettings')}</StyledHeader>
              <CardDescription>
                {t('settings.notificationDescription')}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label>{t('settings.emailNotifications')}</Label>
                    <p className="text-sm text-muted-foreground">
                      {t('settings.emailNotificationsDescription')}
                    </p>
                  </div>
                  <Switch />
                </div>
                <Separator />
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label>{t('settings.systemAlerts')}</Label>
                    <p className="text-sm text-muted-foreground">
                      {t('settings.systemAlertsDescription')}
                    </p>
                  </div>
                  <Switch defaultChecked />
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="publicDisplay">
          <Card>
            <CardHeader>
              <StyledHeader variant="h2">{t('settings.publicDisplaySettings')}</StyledHeader>
              <CardDescription>
                {t('settings.publicDisplayDescription')}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Form {...publicDisplayForm}>
                <form onSubmit={publicDisplayForm.handleSubmit(onPublicDisplaySubmit)} className="space-y-4">
                  <FormField
                    control={publicDisplayForm.control}
                    name="inactivity_timeout"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('settings.inactivityTimeout')}</FormLabel>
                        <FormControl>
                          <div className="flex items-center gap-2">
                            <Input
                              type="number"
                              {...field}
                              onChange={(e) => field.onChange(parseInt(e.target.value) || 60)}
                              min={10}
                              max={600}
                              className="w-32"
                            />
                            <span className="text-sm text-muted-foreground">
                              {t('settings.seconds')}
                            </span>
                          </div>
                        </FormControl>
                        <FormDescription>
                          {t('settings.inactivityTimeoutDescription')}
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <Button type="submit" disabled={isUpdating}>
                    {isUpdating ? t('common.updating') : t('common.saveChanges')}
                  </Button>
                </form>
              </Form>
            </CardContent>
          </Card>
        </TabsContent>

        {userProfile?.is_super_admin && (
          <TabsContent value="system" className="space-y-4">
            <Card>
              <CardHeader>
                <StyledHeader variant="h2">{t('settings.systemSettings')}</StyledHeader>
                <CardDescription>
                  {t('settings.systemDescription')}
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-6">
                  <div>
                    <StyledHeader variant="h3" className="mb-4">{t('settings.apiConfiguration')}</StyledHeader>
                    <div className="space-y-4">
                      <div className="grid gap-2">
                        <Label htmlFor="livekit-url">{t('settings.livekitUrl')}</Label>
                        <Input
                          id="livekit-url"
                          placeholder="wss://your-livekit-server.com"
                          defaultValue={import.meta.env.VITE_LIVEKIT_URL}
                          disabled
                        />
                      </div>
                      <div className="grid gap-2">
                        <Label htmlFor="webhook-secret">{t('settings.webhookSecret')}</Label>
                        <div className="flex gap-2">
                          <Input
                            id="webhook-secret"
                            type="password"
                            placeholder="••••••••••••••••"
                            disabled
                          />
                          <Button variant="outline" size="icon">
                            <Key className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                    </div>
                  </div>

                  <Separator />

                  <div>
                    <StyledHeader variant="h3" className="mb-4">{t('settings.systemInfo')}</StyledHeader>
                    <div className="space-y-2 text-sm">
                      <div className="flex justify-between">
                        <span className="text-muted-foreground">{t('settings.version')}</span>
                        <span className="font-mono">{t('settings.versionValue')}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-muted-foreground">{t('settings.environment')}</span>
                        <span className="font-mono">{t('settings.environmentValue')}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-muted-foreground">{t('settings.database')}</span>
                        <span className="font-mono">{t('settings.databaseValue')}</span>
                      </div>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <StyledHeader variant="h2">{t('settings.maintenanceMode')}</StyledHeader>
                <CardDescription>
                  {t('settings.maintenanceModeDescription')}
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div className="space-y-0.5 flex-1">
                      <Label>{t('settings.enableMaintenanceMode')}</Label>
                      <p className="text-sm text-muted-foreground">
                        {t('settings.maintenanceModeWarning')}
                      </p>
                    </div>
                    <Switch />
                  </div>
                  <Separator />
                  <div className="space-y-2">
                    <Label htmlFor="maintenance-message">{t('settings.maintenanceMessage')}</Label>
                    <Input
                      id="maintenance-message"
                      placeholder={t('settings.maintenanceMessagePlaceholder')}
                      defaultValue={t('settings.maintenanceMessageDefault')}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <StyledHeader variant="h2">{t('settings.systemHealth')}</StyledHeader>
                <CardDescription>
                  {t('settings.systemHealthDescription')}
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">{t('settings.apiStatus')}</span>
                        <div className="flex items-center gap-2">
                          <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
                          <span className="text-sm text-green-600">{t('common.active')}</span>
                        </div>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">{t('settings.databaseStatus')}</span>
                        <div className="flex items-center gap-2">
                          <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
                          <span className="text-sm text-green-600">{t('common.connected')}</span>
                        </div>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">{t('settings.livekitStatus')}</span>
                        <div className="flex items-center gap-2">
                          <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
                          <span className="text-sm text-green-600">{t('common.connected')}</span>
                        </div>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">{t('settings.cpuUsage')}</span>
                        <span className="text-sm font-mono">23%</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">{t('settings.memoryUsage')}</span>
                        <span className="text-sm font-mono">41%</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">{t('settings.diskUsage')}</span>
                        <span className="text-sm font-mono">67%</span>
                      </div>
                    </div>
                  </div>
                  <Separator />
                  <div className="flex gap-2">
                    <Button variant="outline" className="flex-1">
                      <Database className="mr-2 h-4 w-4" />
                      {t('settings.runDatabaseMaintenance')}
                    </Button>
                    <Button variant="outline" className="flex-1">
                      <Globe className="mr-2 h-4 w-4" />
                      {t('settings.clearCache')}
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        )}
      </Tabs>
    </div>
  );
};

export default Settings;


================================================
FILE: src/features/dashboard/pages/Users.tsx
================================================
import { useState, useEffect } from 'react';
import { useOutletContext, useSearchParams } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { StyledH1, StyledHeader } from '@/components/ui/styled-headers';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Checkbox } from '@/components/ui/checkbox';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Users as UsersIcon, Search, Loader2, Edit, Trash2, Shield, UserCheck, UserX, Filter, Download, MoreHorizontal, UserPlus, Mail, Ban, CheckSquare } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { useImpersonation } from '@/hooks/useImpersonation';
import { LoadingSkeleton } from '@/components/ui/loading-skeleton';
import { EmptyState } from '@/components/ui/empty-state';
import UserCreationDialog from '@/features/auth/components/UserCreationDialog';
import UserMosqueAssignment from '@/features/auth/components/UserMosqueAssignment';

type UserProfile = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface DashboardContext {
  userProfile: UserProfile | null;
  mosque: Mosque | null;
}

interface ExtendedUser extends UserProfile {
  mosque?: Mosque;
}

const Users = () => {
  const { t } = useTranslation();
  const { toast } = useToast();
  const { userProfile } = useOutletContext<DashboardContext>();
  const { impersonate } = useImpersonation();
  const [searchParams] = useSearchParams();
  
  const [users, setUsers] = useState<ExtendedUser[]>([]);
  const [mosques, setMosques] = useState<Mosque[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedUser, setSelectedUser] = useState<ExtendedUser | null>(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [activeTab, setActiveTab] = useState('all');
  const [selectedMosqueFilter, setSelectedMosqueFilter] = useState<string>('all');
  const [selectedUsers, setSelectedUsers] = useState<Set<string>>(new Set());
  const [isBulkOperationInProgress, setIsBulkOperationInProgress] = useState(false);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);

  // Get mosque filter from URL params
  const mosqueIdFromUrl = searchParams.get('mosque');

  // Check if user is authorized
  const isAuthorized = userProfile?.is_super_admin || userProfile?.Role === 'Admin';

  useEffect(() => {
    if (isAuthorized) {
      fetchUsers();
      fetchMosques();
    }
  }, [isAuthorized]);

  useEffect(() => {
    if (mosqueIdFromUrl) {
      setSelectedMosqueFilter(mosqueIdFromUrl);
    }
  }, [mosqueIdFromUrl]);

  const fetchUsers = async () => {
    try {
      setLoading(true);
      
      let query = supabase
        .from('users')
        .select(`
          *,
          mosque:Mosque!users_mosque_id_fkey (
            id,
            name,
            Subdomain
          )
        `)
        .order('created_at', { ascending: false });

      // If not super admin, only show users from their mosque
      if (!userProfile?.is_super_admin && userProfile?.mosque_id) {
        query = query.eq('mosque_id', userProfile.mosque_id);
      }

      const { data, error } = await query;

      if (error) throw error;
      setUsers(data || []);
    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('technical.errors.fetchUsersFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  const fetchMosques = async () => {
    if (!userProfile?.is_super_admin) return;
    
    try {
      const { data, error } = await supabase
        .from('Mosque')
        .select('*')
        .order('name');

      if (error) throw error;
      setMosques(data || []);
    } catch (error) {
      }
  };

  const handleDelete = async () => {
    if (!selectedUser) return;
    
    try {
      const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', selectedUser.id);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.users.userDeleted'),
      });

      setIsDeleteDialogOpen(false);
      setSelectedUser(null);
      fetchUsers();
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.deleteFailed'),
        variant: 'destructive',
      });
    }
  };

  const handleImpersonate = async (user: ExtendedUser) => {
    try {
      await impersonate(user.id);
      toast({
        title: t('common.success'),
        description: t('superAdmin.users.impersonating').replace('{name}', user.full_name || user.email),
      });
    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('technical.errors.impersonationFailed'),
        variant: 'destructive',
      });
    }
  };

  const updateUserRole = async (userId: string, newRole: string) => {
    try {
      const { error } = await supabase
        .from('users')
        .update({ Role: newRole })
        .eq('id', userId);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.users.roleUpdated'),
      });

      fetchUsers();
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
    }
  };

  // Batch operations
  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      const allUserIds = filteredUsers
        .filter(user => !user.is_super_admin) // Can't select super admins
        .map(user => user.id);
      setSelectedUsers(new Set(allUserIds));
    } else {
      setSelectedUsers(new Set());
    }
  };

  const handleSelectUser = (userId: string, checked: boolean) => {
    const newSelected = new Set(selectedUsers);
    if (checked) {
      newSelected.add(userId);
    } else {
      newSelected.delete(userId);
    }
    setSelectedUsers(newSelected);
  };

  const handleBulkDelete = async () => {
    if (selectedUsers.size === 0) return;
    
    const confirmed = window.confirm(
      t('superAdmin.users.bulkDeleteConfirmation').replace('{count}', selectedUsers.size.toString())
    );
    
    if (!confirmed) return;
    
    setIsBulkOperationInProgress(true);
    try {
      // Delete users in batches
      const userIds = Array.from(selectedUsers);
      const batchSize = 10;
      
      for (let i = 0; i < userIds.length; i += batchSize) {
        const batch = userIds.slice(i, i + batchSize);
        const { error } = await supabase
          .from('users')
          .delete()
          .in('id', batch);
          
        if (error) throw error;
      }

      toast({
        title: t('common.success'),
        description: t('superAdmin.users.bulkDeleteSuccess').replace('{count}', selectedUsers.size.toString()),
      });

      setSelectedUsers(new Set());
      fetchUsers();
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.deleteFailed'),
        variant: 'destructive',
      });
    } finally {
      setIsBulkOperationInProgress(false);
    }
  };

  const handleBulkRoleUpdate = async (newRole: string) => {
    if (selectedUsers.size === 0) return;
    
    setIsBulkOperationInProgress(true);
    try {
      const userIds = Array.from(selectedUsers);
      const { error } = await supabase
        .from('users')
        .update({ Role: newRole })
        .in('id', userIds);

      if (error) throw error;

      toast({
        title: t('common.success'),
        description: t('superAdmin.users.bulkRoleUpdateSuccess').replace('{count}', selectedUsers.size.toString()),
      });

      setSelectedUsers(new Set());
      fetchUsers();
    } catch (error) {
      toast({
        title: t('common.error'),
        description: error instanceof Error ? error.message : t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
    } finally {
      setIsBulkOperationInProgress(false);
    }
  };

  const handleExportUsers = () => {
    const exportData = filteredUsers.map(user => ({
      id: user.id,
      email: user.email,
      fullName: user.full_name || '',
      mosque: user.mosque?.name || '',
      role: user.is_super_admin ? 'Super Admin' : user.Role,
      status: user.is_active !== false ? 'Active' : 'Inactive',
      joinedAt: new Date(user.created_at).toLocaleDateString(),
    }));

    const csv = [
      Object.keys(exportData[0]).join(','),
      ...exportData.map(row => Object.values(row).map(v => `"${v}"`).join(','))
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `users-export-${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    toast({
      title: t('common.success'),
      description: t('superAdmin.users.exportSuccess'),
    });
  };

  // Filter users
  let filteredUsers = users.filter(user => {
    const matchesSearch = 
      user.full_name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      user.email.toLowerCase().includes(searchQuery.toLowerCase()) ||
      user.mosque?.name?.toLowerCase().includes(searchQuery.toLowerCase());
    
    const matchesMosque = selectedMosqueFilter === 'all' || 
      user.mosque_id?.toString() === selectedMosqueFilter;
    
    return matchesSearch && matchesMosque;
  });

  // Tab filtering
  if (activeTab === 'admins') {
    filteredUsers = filteredUsers.filter(user => user.Role === 'Admin' || user.is_super_admin);
  } else if (activeTab === 'users') {
    filteredUsers = filteredUsers.filter(user => user.Role === 'User' && !user.is_super_admin);
  }

  if (!isAuthorized) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card>
          <CardContent className="pt-6">
            <p className="text-center text-muted-foreground">
              {t('common.unauthorized')}
            </p>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <StyledH1 className="text-foreground">{t('dashboard.users')}</StyledH1>
          <p className="text-muted-foreground">
            {userProfile?.is_super_admin 
              ? t('superAdmin.users.description')
              : t('mosqueAdmin.users.description')
            }
          </p>
        </div>
        <div className="flex flex-wrap items-center gap-2">
          <Button onClick={() => setIsCreateDialogOpen(true)}>
            <UserPlus className="mr-2 h-4 w-4" />
            Create User
          </Button>
          {userProfile?.is_super_admin && selectedUsers.size > 0 && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" disabled={isBulkOperationInProgress}>
                  <CheckSquare className="mr-2 h-4 w-4" />
                  {t('superAdmin.users.bulkActions')} ({selectedUsers.size})
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => handleBulkRoleUpdate('Admin')}>
                  <Shield className="mr-2 h-4 w-4" />
                  {t('superAdmin.users.makeAdmin')}
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => handleBulkRoleUpdate('User')}>
                  <UserX className="mr-2 h-4 w-4" />
                  {t('superAdmin.users.makeUser')}
                </DropdownMenuItem>
                <DropdownMenuItem 
                  onClick={handleBulkDelete}
                  className="text-destructive focus:text-destructive"
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  {t('superAdmin.users.deleteSelected')}
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          )}
          <Button variant="outline" onClick={handleExportUsers}>
            <Download className="mr-2 h-4 w-4" />
            {t('common.export')}
          </Button>
        </div>
      </div>

      {/* Search and Filters */}
      <Card>
        <CardHeader>
          <StyledHeader variant="h2">{t('superAdmin.users.title')}</StyledHeader>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col sm:flex-row gap-4 mb-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder={t('superAdmin.users.searchPlaceholder')}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10"
              />
            </div>
            {userProfile?.is_super_admin && (
              <Select value={selectedMosqueFilter} onValueChange={setSelectedMosqueFilter}>
                <SelectTrigger className="w-full sm:w-[200px]">
                  <Filter className="mr-2 h-4 w-4" />
                  <SelectValue placeholder={t('superAdmin.users.filterByMosque')} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{t('common.allMosques')}</SelectItem>
                  {mosques.map((mosque) => (
                    <SelectItem key={mosque.id} value={mosque.id.toString()}>
                      {mosque.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            )}
          </div>

          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="mb-4">
              <TabsTrigger value="all">
                {t('common.all')} ({users.length})
              </TabsTrigger>
              <TabsTrigger value="admins">
                {t('common.admins')} ({users.filter(u => u.Role === 'Admin' || u.is_super_admin).length})
              </TabsTrigger>
              <TabsTrigger value="users">
                {t('common.users')} ({users.filter(u => u.Role === 'User' && !u.is_super_admin).length})
              </TabsTrigger>
              {userProfile?.is_super_admin && (
                <TabsTrigger value="assignments">
                  Mosque Assignments
                </TabsTrigger>
              )}
            </TabsList>

            <TabsContent value={activeTab}>
              {loading ? (
                <LoadingSkeleton variant="table" rows={5} columns={7} />
              ) : filteredUsers.length === 0 ? (
                <EmptyState
                  icon={UsersIcon}
                  title={t('superAdmin.users.noUsersFound')}
                  description={
                    searchQuery || selectedMosqueFilter !== 'all'
                      ? t('common.noResultsFound')
                      : t('superAdmin.users.noUsersDescription')
                  }
                />
              ) : (
                <div className="overflow-x-auto">
                  <Table>
                  <TableHeader>
                    <TableRow>
                      {userProfile?.is_super_admin && (
                        <TableHead className="w-12">
                          <Checkbox
                            checked={filteredUsers.filter(u => !u.is_super_admin).length > 0 && 
                                   filteredUsers.filter(u => !u.is_super_admin).every(u => selectedUsers.has(u.id))}
                            onCheckedChange={handleSelectAll}
                            aria-label="Select all"
                          />
                        </TableHead>
                      )}
                      <TableHead>{t('common.user')}</TableHead>
                      <TableHead>{t('common.email')}</TableHead>
                      <TableHead>{t('common.mosque')}</TableHead>
                      <TableHead>{t('common.role')}</TableHead>
                      <TableHead>{t('common.status')}</TableHead>
                      <TableHead>{t('common.joinedAt')}</TableHead>
                      <TableHead className="text-right">{t('common.actions')}</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {filteredUsers.map((user) => (
                      <TableRow key={user.id}>
                        {userProfile?.is_super_admin && (
                          <TableCell>
                            <Checkbox
                              checked={selectedUsers.has(user.id)}
                              onCheckedChange={(checked) => handleSelectUser(user.id, !!checked)}
                              disabled={user.is_super_admin}
                              aria-label={`Select ${user.full_name || user.email}`}
                            />
                          </TableCell>
                        )}
                        <TableCell>
                          <div className="flex items-center gap-3">
                            <Avatar className="h-8 w-8">
                              <AvatarImage src={user.avatar_url || undefined} />
                              <AvatarFallback>
                                {user.full_name?.charAt(0) || user.email.charAt(0).toUpperCase()}
                              </AvatarFallback>
                            </Avatar>
                            <div>
                              <div className="font-medium">{user.full_name || t('common.unnamed')}</div>
                              <div className="text-sm text-muted-foreground">ID: {user.id.slice(0, 8)}</div>
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>{user.email}</TableCell>
                        <TableCell>
                          {user.mosque ? (
                            <Badge variant="outline">{user.mosque.name}</Badge>
                          ) : (
                            <span className="text-muted-foreground">{t('common.noMosque')}</span>
                          )}
                        </TableCell>
                        <TableCell>
                          {userProfile?.is_super_admin ? (
                            <Select
                              value={user.is_super_admin ? 'super_admin' : user.Role}
                              onValueChange={(value) => updateUserRole(user.id, value)}
                              disabled={user.is_super_admin}
                            >
                              <SelectTrigger className="w-[120px]">
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="User">{t('common.user')}</SelectItem>
                                <SelectItem value="Admin">{t('common.admin')}</SelectItem>
                                <SelectItem value="super_admin" disabled>
                                  {t('common.superAdmin')}
                                </SelectItem>
                              </SelectContent>
                            </Select>
                          ) : (
                            <Badge variant={user.is_super_admin ? 'default' : user.Role === 'Admin' ? 'secondary' : 'outline'}>
                              {user.is_super_admin ? t('common.superAdmin') : user.Role}
                            </Badge>
                          )}
                        </TableCell>
                        <TableCell>
                          <Badge variant={user.is_active !== false ? 'default' : 'secondary'}>
                            {user.is_active !== false ? t('common.active') : t('common.inactive')}
                          </Badge>
                        </TableCell>
                        <TableCell className="text-muted-foreground">
                          {new Date(user.created_at).toLocaleDateString()}
                        </TableCell>
                        <TableCell className="text-right">
                          <div className="flex items-center justify-end gap-2">
                            {userProfile?.is_super_admin && !user.is_super_admin && (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handleImpersonate(user)}
                                title={t('superAdmin.users.impersonate')}
                              >
                                <UserCheck className="h-4 w-4" />
                              </Button>
                            )}
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                // TODO: Implement edit user dialog
                                toast({
                                  title: t('common.comingSoon'),
                                  description: t('common.featureNotImplemented'),
                                });
                              }}
                            >
                              <Edit className="h-4 w-4" />
                            </Button>
                            {userProfile?.is_super_admin && !user.is_super_admin && (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => {
                                  setSelectedUser(user);
                                  setIsDeleteDialogOpen(true);
                                }}
                                className="text-destructive hover:text-destructive"
                              >
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            )}
                          </div>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                  </Table>
                </div>
              )}
            </TabsContent>
            
            {userProfile?.is_super_admin && (
              <TabsContent value="assignments">
                <UserMosqueAssignment />
              </TabsContent>
            )}
          </Tabs>
        </CardContent>
      </Card>

      {/* Delete Confirmation Dialog */}
      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="font-poppins lowercase" style={{ letterSpacing: '-0.058em' }}>{t('common.confirmDelete')}</DialogTitle>
            <DialogDescription>
              {t('superAdmin.users.deleteConfirmation').replace(
                '{name}', 
                selectedUser?.full_name || selectedUser?.email || ''
              )}
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setIsDeleteDialogOpen(false)}
            >
              {t('common.cancel')}
            </Button>
            <Button
              variant="destructive"
              onClick={handleDelete}
            >
              {t('common.delete')}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* User Creation Dialog */}
      <UserCreationDialog
        open={isCreateDialogOpen}
        onOpenChange={setIsCreateDialogOpen}
        mosques={mosques}
        onSuccess={() => {
          setIsCreateDialogOpen(false);
          fetchUsers();
        }}
      />
    </div>
  );
};

export default Users;


================================================
FILE: src/features/display/components/KioskToggle.tsx
================================================
import { useState } from 'react';
import { SecureToggle } from '@/components/ui/secure-toggle';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { Monitor } from 'lucide-react';
import { Tables } from '@/integrations/supabase/types';
import { useTranslation } from '@/hooks/useTranslation';

interface KioskToggleProps {
  room: Tables<'rooms'>;
  onUpdate: (updatedRoom: Tables<'rooms'>) => void;
  className?: string;
}

const KioskToggle = ({ room, onUpdate, className }: KioskToggleProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const [optimisticState, setOptimisticState] = useState(room.is_persistent || false);
  const { toast } = useToast();
  const { t } = useTranslation();

  const handleToggleKiosk = async () => {
    const newState = !optimisticState;
    const previousState = optimisticState;
    
    // Optimistic update
    setOptimisticState(newState);
    setIsLoading(true);
    
    try {
      const { data, error } = await supabase
        .from('rooms')
        .update({ is_persistent: newState })
        .eq('id', room.id)
        .select()
        .single();

      if (error) throw error;

      // Update parent with the new room state
      onUpdate(data);

      toast({
        title: t('kioskToggle.updatedTitle'),
        description: newState 
          ? t('kioskToggle.enabledDescription').replace('{name}', room.Title)
          : t('kioskToggle.disabledDescription').replace('{name}', room.Title),
      });
    } catch (error) {
      // Rollback optimistic update on error
      setOptimisticState(previousState);
      toast({
        title: t('common.error'),
        description: t('kioskToggle.updateFailed'),
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <SecureToggle
      icon={Monitor}
      label={t('mosqueAdmin.rooms.kioskMode')}
      checked={optimisticState}
      onCheckedChange={handleToggleKiosk}
      isLoading={isLoading}
      color="data-[state=checked]:bg-green-600"
      className={className}
    />
  );
};

export default KioskToggle;


================================================
FILE: src/features/display/components/PrayerTimesDisplay.tsx
================================================
import { Clock } from 'lucide-react';

interface PrayerTimesDisplayProps {
  mosqueName?: string;
  isDark: boolean;
}

const PrayerTimesDisplay = ({ mosqueName, isDark }: PrayerTimesDisplayProps) => {
  const colors = {
    background: isDark ? 'hsl(210, 35%, 9%)' : '#fdf1f4',
    foreground: isDark ? 'hsl(0, 0%, 95%)' : 'rgba(10, 58, 58, 0.85)',
    card: isDark ? 'hsl(210, 35%, 12%)' : '#ffffff',
    border: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(10, 58, 58, 0.15)',
    muted: isDark ? 'hsl(210, 20%, 70%)' : 'rgba(10, 58, 58, 0.7)',
    primary: isDark ? 'hsl(180, 45%, 35%)' : '#d4a574',
  };

  // Placeholder prayer times
  const prayerTimes = [
    { name: 'Fajr', time: '05:30 AM' },
    { name: 'Dhuhr', time: '12:45 PM' },
    { name: 'Asr', time: '03:30 PM' },
    { name: 'Maghrib', time: '06:15 PM' },
    { name: 'Isha', time: '07:45 PM' },
  ];

  const currentTime = new Date().toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });

  return (
    <div className="h-screen flex flex-col items-center justify-center p-8" style={{ backgroundColor: colors.background }}>
      <div className="w-full max-w-4xl mx-auto text-center">
        {/* Mosque Name */}
        <h1 className="text-5xl font-bold mb-8" style={{ color: colors.foreground }}>
          {mosqueName || 'Mosque Name'}
        </h1>

        {/* Current Time */}
        <div className="mb-12 flex items-center justify-center gap-3">
          <Clock className="w-8 h-8" style={{ color: colors.primary }} />
          <span className="text-6xl font-light" style={{ color: colors.foreground }}>
            {currentTime}
          </span>
        </div>

        {/* Prayer Times Grid */}
        <div className="grid grid-cols-5 gap-6 mb-12">
          {prayerTimes.map((prayer) => (
            <div
              key={prayer.name}
              className="p-6 rounded-xl transition-all hover:scale-105"
              style={{
                backgroundColor: colors.card,
                border: `1px solid ${colors.border}`,
              }}
            >
              <h3 className="text-xl font-semibold mb-2" style={{ color: colors.primary }}>
                {prayer.name}
              </h3>
              <p className="text-2xl font-medium" style={{ color: colors.foreground }}>
                {prayer.time}
              </p>
            </div>
          ))}
        </div>

        {/* Footer Message */}
        <p className="text-xl" style={{ color: colors.muted }}>
          Waiting for live session to begin...
        </p>
      </div>
    </div>
  );
};

export default PrayerTimesDisplay;


================================================
FILE: src/features/display/components/QuranDisplayView.tsx
================================================
import { useState, useEffect, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Moon, Sun, Eye, EyeClosed, ListCollapse, Maximize, Camera, CameraOff, Circle, Wifi, WifiOff, Layers, ArrowDown, LogOut, GripVertical, Type } from 'lucide-react';
import { BroadcastReceiver } from '@/features/livekit/components/BroadcastReceiver';
import { useTranslation } from '@/hooks/useTranslation';
import VideoStream from '@/features/display/components/VideoStream';
import PrayerTimesDisplay from '@/features/display/components/PrayerTimesDisplay';
import { createTranslationBuffer } from '@/features/display/utils/TranslationCommaBuffer';

// Utility functions for text animation
const splitIntoChunks = (text: string, chunkSize: number = 4): string[] => {
  const words = text.trim().split(/\s+/);
  const chunks: string[] = [];
  
  for (let i = 0; i < words.length; i += chunkSize) {
    chunks.push(words.slice(i, i + chunkSize).join(' '));
  }
  
  return chunks;
};

const calculateReadingDelay = (wordCount: number, wpm: number = 240): number => {
  const msPerWord = (60 * 1000) / wpm;
  return Math.max(wordCount * msPerWord, 150);
};

interface Word {
  id: string;
  text: string;
  timestamp: number;
}

type ConnectionState = 'connecting' | 'connected' | 'disconnected';

interface TranslationLine {
  id: string;
  text: string;
  timestamp: number;
}

interface QuranDisplayViewProps {
  roomName?: string | null;
  mosqueId?: number;
  roomId?: number;
  sessionId?: string;
  onDisconnect?: () => void;
  isKioskMode?: boolean;
  mosqueName?: string;
  inactivityTimeout?: number;
}

const QuranDisplayView = ({ 
  roomName, 
  mosqueId, 
  roomId, 
  sessionId,
  onDisconnect,
  isKioskMode = false,
  mosqueName,
  inactivityTimeout = 60
}: QuranDisplayViewProps) => {
  const [words, setWords] = useState<Word[]>([]);
  const [lines, setLines] = useState<TranslationLine[]>([]);
  const [transcriptionLanguage, setTranscriptionLanguage] = useState<string>('ar');
  const [showTranscription, setShowTranscription] = useState(true);
  const [isDark, setIsDark] = useState(() => 
    window.matchMedia('(prefers-color-scheme: dark)').matches
  );
  const [isDevMode, setIsDevMode] = useState(false);
  const [activeLineId, setActiveLineId] = useState<string | null>(null);
  const [isTickerResetting, setIsTickerResetting] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showCamera, setShowCamera] = useState(true);
  const [selectedCameraId, setSelectedCameraId] = useState<string>(() => {
    return localStorage.getItem('selectedCameraId') || '';
  });
  const [connectionStatus, setConnectionStatus] = useState<ConnectionState>('disconnected');
  const [retryCount, setRetryCount] = useState(0);
  const [showScrollIndicator, setShowScrollIndicator] = useState(false);
  const [invertedStacking, setInvertedStacking] = useState(false); // Toggle for inverted card stacking
  const [cameraWidth, setCameraWidth] = useState(20); // Camera width percentage (default 20% - minimum size)
  const [isResizing, setIsResizing] = useState(false);
  const [compactFont, setCompactFont] = useState(false); // Toggle for smaller font size
  const [isActive, setIsActive] = useState(false); // Track if room is active
  const [lastActivityTime, setLastActivityTime] = useState<number>(Date.now());
  const inactivityTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const scrollRef = useRef<HTMLDivElement>(null);
  const translationScrollRef = useRef<HTMLDivElement>(null);
  const modernTranslationRef = useRef<HTMLDivElement>(null);
  const textContainerRef = useRef<HTMLDivElement>(null);
  const textContentRef = useRef<HTMLDivElement>(null);
  const { t } = useTranslation();
  
  // Initialize translation buffer for equal-split text - create once and reuse
  const translationBuffer = useRef<ReturnType<typeof createTranslationBuffer>>();
  if (!translationBuffer.current) {
    translationBuffer.current = createTranslationBuffer({
      enabled: true,
      displayInterval: 3000, // 3 seconds between split segments
      smartPause: true, // Adjust timing based on text length
      maxQueueSize: 100,
      minLengthToSplit: 100 // Split messages over 100 characters
    });
    console.log('[QuranDisplayView] Translation buffer initialized');
  }
  
  const INACTIVITY_TIMEOUT = inactivityTimeout * 1000; // Convert seconds to milliseconds

  // Update activity status
  const updateActivity = () => {
    setIsActive(true);
    setLastActivityTime(Date.now());
    
    // Clear existing timeout
    if (inactivityTimeoutRef.current) {
      clearTimeout(inactivityTimeoutRef.current);
    }
    
    // Set new timeout
    inactivityTimeoutRef.current = setTimeout(() => {
      setIsActive(false);
    }, INACTIVITY_TIMEOUT);
  };

  // Helper function to determine if language is RTL
  const isRTL = (lang: string) => {
    const rtlLanguages = ['ar', 'he', 'fa', 'ur', 'yi', 'ji', 'iw', 'ku', 'ps', 'sd', 'ug'];
    return rtlLanguages.includes(lang.toLowerCase());
  };

  // Handle real-time transcription broadcasts
  const handleTranscription = (text: string, language: string, timestamp: string, messageData?: any) => {
    updateActivity(); // Mark as active when receiving transcription
    
    const isComplete = messageData?.is_complete || false;
    
    // Update transcription language
    if (language) {
      setTranscriptionLanguage(language);
    }
    
    // Ignore complete sentences - we only want fragments/words
    if (isComplete) {
      return;
    }
    
    if (text) {
      // Split text into words and add them to the ticker
      const arabicWords = text.split(' ').filter(word => word.trim());
      
      arabicWords.forEach((word, index) => {
        setTimeout(() => {
          const newWord: Word = {
            id: `word-${timestamp}-${index}`,
            text: word,
            timestamp: new Date(timestamp).getTime(),
          };
          
          setWords(prev => {
            const updated = [...prev, newWord];
            // Auto-reset ticker if it gets too long
            if (updated.length > 15) {
              setIsTickerResetting(true);
              setTimeout(() => {
                setWords([newWord]);
                setIsTickerResetting(false);
              }, 400);
              return updated;
            }
            return updated;
          });
        }, index * 200); // Stagger word appearance
      });
    }
  };

  // Handle real-time translation broadcasts - using useCallback for stability
  const handleTranslation = useCallback((text: string, language: string, timestamp: string) => {
    updateActivity(); // Mark as active when receiving translation
    
    // Generate unique ID to prevent duplicates
    const uniqueId = `line-${timestamp}-${Date.now()}-${Math.random()}`;
    const newLine: TranslationLine = {
      id: uniqueId,
      text: text,
      timestamp: new Date(timestamp).getTime(),
    };
    
    setLines(prev => {
      const updated = [...prev, newLine];
      // Keep only the last 15 lines for display
      const finalLines = updated.slice(-15);
      setActiveLineId(newLine.id);
      return finalLines;
    });
  }, []);

  // Auto-scroll based on stacking mode
  useEffect(() => {
    if (modernTranslationRef.current) {
      if (invertedStacking) {
        modernTranslationRef.current.scrollTop = 0; // Scroll to top for inverted stacking
      } else {
        modernTranslationRef.current.scrollTop = modernTranslationRef.current.scrollHeight; // Scroll to bottom for normal
      }
    }
  }, [lines, invertedStacking]);

  // Check scroll position based on stacking mode
  const checkScrollPosition = () => {
    const container = modernTranslationRef.current;
    if (container) {
      if (invertedStacking) {
        const isAtTop = container.scrollTop < 50;
        setShowScrollIndicator(!isAtTop && lines.length > 0);
      } else {
        const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 50;
        setShowScrollIndicator(!isAtBottom && lines.length > 0);
      }
    }
  };

  // Scroll to latest position based on stacking mode
  const scrollToLatest = () => {
    const container = modernTranslationRef.current;
    if (container) {
      if (invertedStacking) {
        container.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top for inverted
      } else {
        container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' }); // Scroll to bottom for normal
      }
    }
  };

  // Initialize translation buffer with display callback
  useEffect(() => {
    translationBuffer.current.setDisplayCallback(handleTranslation);
    
    // Cleanup on unmount
    return () => {
      translationBuffer.current.clearQueue();
    };
  }, [handleTranslation]); // Update when handleTranslation changes

  // Set connection status based on broadcast receiver
  useEffect(() => {
    if (roomId && mosqueId) {
      setConnectionStatus('connected');
    } else {
      setConnectionStatus('disconnected');
    }
  }, [roomId, mosqueId]);

  // Save selected camera to localStorage
  useEffect(() => {
    console.log('QuranDisplayView: selectedCameraId state updated to:', selectedCameraId);
    if (selectedCameraId) {
      localStorage.setItem('selectedCameraId', selectedCameraId);
    }
  }, [selectedCameraId]);

  // Demo data for dev mode
  const demoWords = [
    "بِسْمِ", "اللَّهِ", "الرَّحْمَنِ", "الرَّحِيم", "الْحَمْدُ", "لِلَّهِ", "رَبِّ", "الْعَالَمِين",
    "الرَّحْمَنِ", "الرَّحِيم", "مَالِكِ", "يَوْمِ", "الدِّين", "إِيَّاكَ", "نَعْبُدُ", "وَإِيَّاكَ"
  ];

  const demoLines = [
    "In the name of Allah, the Most Gracious, the Most Merciful",
    "All praise is due to Allah, Lord of all the worlds",
    "The Most Gracious, the Most Merciful",
    "Master of the Day of Judgment"
  ];

  // Check if text overflows container width
  const checkTextOverflow = () => {
    if (!textContainerRef.current || !textContentRef.current) return false;
    
    const containerWidth = textContainerRef.current.offsetWidth;
    const contentWidth = textContentRef.current.scrollWidth;
    
    return contentWidth > containerWidth;
  };


  // Dev mode simulation
  useEffect(() => {
    if (!isDevMode) return;

    let wordIndex = 0;
    let lineIndex = 0;

    const addWord = () => {
      if (wordIndex < demoWords.length) {
        const newWord: Word = {
          id: `dev-word-${Date.now()}-${wordIndex}`,
          text: demoWords[wordIndex],
          timestamp: Date.now(),
        };
        
        setWords(prev => {
          const updated = [...prev, newWord];
          setTimeout(() => {
            if (checkTextOverflow()) {
              setIsTickerResetting(true);
              setTimeout(() => {
                setWords([newWord]);
                setIsTickerResetting(false);
              }, 400);
            }
          }, 0);
          return updated;
        });
        
        wordIndex++;
      } else {
        wordIndex = 0;
        setWords([]);
      }
    };

    const addLine = () => {
      if (lineIndex < demoLines.length) {
        const newLine: TranslationLine = {
          id: `dev-line-${Date.now()}-${lineIndex}`,
          text: demoLines[lineIndex],
          timestamp: Date.now(),
        };
        
        setLines(prev => {
          const updated = [...prev, newLine];
          const finalLines = updated.slice(-15);
          setActiveLineId(newLine.id);
          return finalLines;
        });
        
        lineIndex++;
      } else {
        lineIndex = 0;
        setLines([]);
      }
    };

    addWord();
    const lineTimeout = setTimeout(addLine, 1000);
    const wordInterval = setInterval(addWord, 800);
    const lineInterval = setInterval(addLine, 4000);
    
    return () => {
      clearTimeout(lineTimeout);
      clearInterval(wordInterval);
      clearInterval(lineInterval);
    };
  }, [isDevMode]);

  // Auto-scroll for Arabic ticker
  useEffect(() => {
    if (textContentRef.current && textContainerRef.current) {
      textContainerRef.current.scrollLeft = textContentRef.current.scrollWidth;
    }
  }, [words]);

  // Apply dark mode class
  useEffect(() => {
    if (isDark) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [isDark]);

  // Cleanup inactivity timeout on unmount
  useEffect(() => {
    return () => {
      if (inactivityTimeoutRef.current) {
        clearTimeout(inactivityTimeoutRef.current);
      }
    };
  }, []);

  const toggleTheme = () => {
    setIsDark(!isDark);
  };

  // Define colors for light and dark modes
  const colors = {
    background: isDark ? 'hsl(210, 40%, 3%)' : '#fdf1f4',
    foreground: isDark ? 'hsl(180, 25%, 95%)' : '#0a3a3a',
    card: isDark ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.5)',
    cardHover: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.7)',
    border: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(10, 58, 58, 0.15)',
    muted: isDark ? 'hsl(210, 20%, 70%)' : 'rgba(10, 58, 58, 0.7)',
    primary: isDark ? 'hsl(180, 45%, 35%)' : '#d4a574',
    cameraBackground: isDark ? 'hsl(210, 35%, 6%)' : 'rgba(10, 58, 58, 0.05)',
  };

  const resetDisplay = () => {
    setIsTickerResetting(true);
    setWords([]);
    setLines([]);
    setActiveLineId(null);
    setTimeout(() => setIsTickerResetting(false), 500);
  };

  return (
    <>
      {/* Real-time Broadcast Receiver - Always active to detect incoming audio */}
      {roomId && mosqueId && (
        <BroadcastReceiver
          roomId={roomId}
          mosqueId={mosqueId}
          onTranscription={handleTranscription}
          onTranslation={(text, language, timestamp) => {
            // Use the translation buffer for sequential display of equal-split segments
            translationBuffer.current.addTranslation(text, language, timestamp);
          }}
          enabled={true}
          isKioskMode={isKioskMode}
          onConnectionStateChange={(state: any, retry: number) => {
            setConnectionStatus(state as ConnectionState);
            setRetryCount(retry);
          }}
        />
      )}

      {/* Show prayer times when inactive, translation view when active */}
      {!isActive && isKioskMode ? (
        <PrayerTimesDisplay mosqueName={mosqueName} isDark={isDark} />
      ) : (
        <div className="h-screen p-6 flex flex-col overflow-hidden" style={{ backgroundColor: colors.background }}>
      
      {/* Header Controls */}
      {!isFullscreen && (
        <>
          {/* Mobile Header - Horizontal scrollable */}
          <div className="fixed top-2 left-2 right-2 sm:hidden z-10">
            <div className="flex gap-2 overflow-x-auto scrollbar-hide p-2 rounded-lg" 
              style={{ 
                backgroundColor: colors.card,
                border: `1px solid ${colors.border}`,
              }}>
              {/* Connection Status */}
              <div className="flex items-center gap-1.5 px-2 flex-shrink-0" style={{ color: colors.muted }}>
               {connectionStatus === 'connected' ? (
                  <Wifi className="w-3.5 h-3.5" style={{ color: `${colors.primary}99` }} />
               ) : connectionStatus === 'connecting' || connectionStatus === 'disconnected' ? (
                  <Wifi className="w-3.5 h-3.5 animate-pulse" style={{ color: `${colors.muted}80` }} />
                ) : (
                  <WifiOff className="w-3.5 h-3.5" style={{ color: `${colors.muted}66` }} />
                )}
               {isKioskMode && connectionStatus === 'connecting' && (
                  <span className="text-[10px]" style={{ color: colors.muted }}>
                    Retry {retryCount}
                  </span>
                )}
                {roomName && <span className="text-xs hidden">{roomName}</span>}
              </div>
              
              <div className="w-px h-6 bg-current opacity-20 flex-shrink-0" />
              
              
              <button
                onClick={() => setIsFullscreen(!isFullscreen)}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ backgroundColor: 'transparent' }}
              >
                <Maximize className="w-4 h-4" style={{ color: colors.foreground }} />
              </button>
              
              <button
                onClick={() => setIsDevMode(!isDevMode)}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ 
                  backgroundColor: isDevMode ? `${colors.primary}33` : 'transparent',
                }}
              >
                <ListCollapse className="w-4 h-4" style={{ color: isDevMode ? colors.primary : colors.foreground }} />
              </button>
              
              <button
                onClick={() => setShowCamera(!showCamera)}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ backgroundColor: 'transparent' }}
              >
                {showCamera ? <Camera className="w-4 h-4" style={{ color: colors.foreground }} /> : <CameraOff className="w-4 h-4" style={{ color: colors.foreground }} />}
              </button>
              
              <button
                onClick={() => setShowTranscription(!showTranscription)}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ backgroundColor: 'transparent' }}
              >
                {showTranscription ? <Eye className="w-4 h-4" style={{ color: colors.foreground }} /> : <EyeClosed className="w-4 h-4" style={{ color: colors.foreground }} />}
              </button>
              
              <button
                onClick={() => setInvertedStacking(!invertedStacking)}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ 
                  backgroundColor: invertedStacking ? `${colors.primary}33` : 'transparent',
                }}
                title={invertedStacking ? "Switch to Normal Stacking" : "Switch to Inverted Stacking"}
              >
                <ArrowDown 
                  className="w-4 h-4 transition-transform duration-300" 
                  style={{ 
                    color: invertedStacking ? colors.primary : colors.foreground,
                    transform: invertedStacking ? 'rotate(180deg)' : 'rotate(0deg)'
                  }} 
                />
              </button>
              
              <button
                onClick={toggleTheme}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ backgroundColor: 'transparent' }}
              >
                {isDark ? <Sun className="w-4 h-4" style={{ color: colors.foreground }} /> : <Moon className="w-4 h-4" style={{ color: colors.foreground }} />}
              </button>
              
              <button
                onClick={() => setCompactFont(!compactFont)}
                className="p-2 rounded-lg transition-colors flex-shrink-0"
                style={{ 
                  backgroundColor: compactFont ? `${colors.primary}33` : 'transparent',
                }}
                title={compactFont ? "Switch to Normal Font Size" : "Switch to Compact Font Size"}
              >
                <Type 
                  className={`w-4 h-4 transition-transform ${compactFont ? 'scale-75' : 'scale-100'}`} 
                  style={{ color: compactFont ? colors.primary : colors.foreground }} 
                />
              </button>
            </div>
          </div>
          
          {/* Desktop Header - Individual buttons */}
          <div className="hidden sm:block">
            <button
              onClick={toggleTheme}
              className="fixed top-6 right-4 p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.card}
            >
              {isDark ? <Sun className="w-5 h-5" style={{ color: colors.foreground }} /> : <Moon className="w-5 h-5" style={{ color: colors.foreground }} />}
            </button>

            <button
              onClick={() => setCompactFont(!compactFont)}
              className="fixed top-6 right-[4.5rem] p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: compactFont ? `${colors.primary}33` : colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = compactFont ? `${colors.primary}4d` : colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = compactFont ? `${colors.primary}33` : colors.card}
              title={compactFont ? "Switch to Normal Font Size" : "Switch to Compact Font Size"}
            >
              <Type 
                className={`w-5 h-5 transition-transform ${compactFont ? 'scale-75' : 'scale-100'}`} 
                style={{ color: compactFont ? colors.primary : colors.foreground }} 
              />
            </button>

            <button
              onClick={() => setShowTranscription(!showTranscription)}
              className="fixed top-6 right-[8.5rem] p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.card}
            >
              {showTranscription ? <Eye className="w-5 h-5" style={{ color: colors.foreground }} /> : <EyeClosed className="w-5 h-5" style={{ color: colors.foreground }} />}
            </button>


            <button
              onClick={() => setShowCamera(!showCamera)}
              className="fixed top-6 right-[12.5rem] p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.card}
            >
              {showCamera ? <Camera className="w-5 h-5" style={{ color: colors.foreground }} /> : <CameraOff className="w-5 h-5" style={{ color: colors.foreground }} />}
            </button>


            <button
              onClick={() => setIsDevMode(!isDevMode)}
              className="fixed top-6 right-[16.5rem] p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: isDevMode ? `${colors.primary}33` : colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = isDevMode ? `${colors.primary}4d` : colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = isDevMode ? `${colors.primary}33` : colors.card}
            >
              <ListCollapse className="w-5 h-5" style={{ color: isDevMode ? colors.primary : colors.foreground }} />
            </button>

            <button
              onClick={() => setIsFullscreen(!isFullscreen)}
              className="fixed top-6 right-[20.5rem] p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.card}
            >
              <Maximize className="w-5 h-5" style={{ color: colors.foreground }} />
            </button>

            <button
              onClick={() => setInvertedStacking(!invertedStacking)}
              className="fixed top-6 right-[24.5rem] p-3 rounded-full transition-colors z-10"
              style={{ 
                backgroundColor: invertedStacking ? `${colors.primary}33` : colors.card,
                border: `1px solid ${colors.border}`,
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = invertedStacking ? `${colors.primary}4d` : colors.cardHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = invertedStacking ? `${colors.primary}33` : colors.card}
              title={invertedStacking ? "Switch to Normal Stacking" : "Switch to Inverted Stacking"}
            >
              <ArrowDown 
                className="w-5 h-5 transition-transform duration-300" 
                style={{ 
                  color: invertedStacking ? colors.primary : colors.foreground,
                  transform: invertedStacking ? 'rotate(180deg)' : 'rotate(0deg)'
                  }} 
              />
            </button>
            
            {onDisconnect && (
              <button
                onClick={onDisconnect}
                className="fixed top-6 left-6 p-3 rounded-full transition-colors z-10"
                style={{ 
                  backgroundColor: colors.card,
                  border: `1px solid ${colors.border}`,
                }}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.cardHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.card}
                title={t('publicDisplay.disconnect')}
              >
                <LogOut className="w-5 h-5" style={{ color: colors.foreground }} />
              </button>
            )}
          </div>

          {/* Desktop Connection Status */}
          <div className="fixed top-6 left-20 p-2 z-10 hidden sm:block">
            <div className="flex items-center gap-2 text-xs" style={{ color: colors.muted }}>
              {connectionStatus === 'connected' ? (
                <Wifi className="w-3 h-3" style={{ color: `${colors.primary}99` }} />
              ) : connectionStatus === 'connecting' || connectionStatus === 'disconnected' ? (
                <Wifi className="w-3 h-3 animate-pulse" style={{ color: `${colors.muted}80` }} />
              ) : (
                <WifiOff className="w-3 h-3" style={{ color: `${colors.muted}66` }} />
              )}
              {isKioskMode && connectionStatus === 'connecting' && (
                <span>Kiosk Mode - Retry {retryCount}</span>
              )}
              <span className="text-xs">{roomName}</span>
            </div>
          </div>
        </>
      )}

      {/* Fullscreen exit button */}
      {isFullscreen && (
        <button
          onClick={() => setIsFullscreen(false)}
          className="fixed top-4 right-4 p-2 rounded-full transition-all opacity-60 hover:opacity-100 z-20"
          style={{ 
            backgroundColor: colors.card,
            border: `1px solid ${colors.border}`,
          }}
          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.cardHover}
          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.card}
        >
          <Circle className="w-4 h-4" style={{ color: colors.muted }} />
        </button>
      )}

      {/* Main Display Container */}
      <div className={`${isFullscreen ? 'mt-0 h-screen' : 'mt-16 h-[calc(100vh-4rem)]'} flex flex-col gap-4 p-4`}>
        
        {/* Arabic Transcription */}
        <AnimatePresence>
          {showTranscription && (
            <motion.div 
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.3, ease: "easeOut" }}
              className="lg:h-[15vh]"
            >
              <div className="transcription-container w-[calc(100vw-3rem)] mx-auto p-3 sm:p-4 md:p-6">
                <div ref={textContainerRef} className="h-full overflow-hidden flex items-center justify-center">
                  <div 
                    className={`w-full ${isRTL(transcriptionLanguage) ? 'text-right' : 'text-left'}`} 
                    dir={isRTL(transcriptionLanguage) ? 'rtl' : 'ltr'}
                  >
                    <motion.div 
                      ref={textContentRef} 
                      className={`inline-flex flex-wrap gap-2 ${
                        isRTL(transcriptionLanguage) ? 'justify-end' : 'justify-start'
                      }`}
                      animate={{ opacity: isTickerResetting ? 0 : 1, y: isTickerResetting ? -5 : 0 }}
                      transition={{ duration: 0.4, ease: 'easeInOut' }}
                    >
                      <AnimatePresence>
                        {words.map((word, index) => (
                          <motion.span
                            key={word.id}
                            initial={{ opacity: 0, scale: 0.8, y: 20 }}
                            animate={{ 
                              opacity: 1, 
                              scale: 1, 
                              y: 0,
                              transition: {
                                type: "spring",
                                stiffness: 400,
                                damping: 20
                              }
                            }}
                            exit={{ 
                              opacity: 0, 
                              scale: 0.8, 
                              y: -20,
                              transition: { duration: 0.2 }
                            }}
                            className="inline-block"
                            style={{
                              fontSize: compactFont ? 'clamp(0.875rem, 2vw, 1.25rem)' : 'clamp(1rem, 2.5vw, 1.5rem)',
                              color: colors.foreground,
                              fontWeight: 600,
                              textShadow: isDark 
                                ? '0 2px 8px rgba(0, 0, 0, 0.3)' 
                                : '0 2px 8px rgba(0, 0, 0, 0.1)'
                            }}
                          >
                            {word.text}
                          </motion.span>
                        ))}
                      </AnimatePresence>
                    </motion.div>
                    
                    {words.length === 0 && (
                      <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        className="translation-text text-center w-full"
                        style={{ color: colors.muted }}
                      >
                        {connectionStatus === 'connected' ? t('quranDisplay.waitingForArabic') : t('quranDisplay.demoArabic')}
                      </motion.div>
                    )}
                  </div>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Bottom Section */}
        <div className={`${showTranscription ? 'h-[calc(100%-15vh-1rem)]' : 'h-full'} flex flex-col lg:flex-row gap-4`}>
          
          {/* Camera Feed */}
          {showCamera && (
            <div 
              className="relative h-[30vh] lg:h-full rounded-xl shadow-inner overflow-hidden transition-[width] duration-75 flex-shrink-0" 
              style={{ 
                backgroundColor: colors.cameraBackground,
                width: window.innerWidth >= 1024 ? `${cameraWidth}%` : '100%', // Only apply custom width on desktop
                minHeight: '200px' // Ensure minimum height
              }}
            >
              <VideoStream 
                deviceId={selectedCameraId}
                className="w-full h-full"
                onCameraChange={(id) => {
                  console.log('QuranDisplayView: Camera changed to:', id);
                  setSelectedCameraId(id);
                  localStorage.setItem('selectedCameraId', id);
                }}
              />
              
              {/* Resize Handle - Only on desktop */}
              <div className="hidden lg:block">
                <div
                  className="absolute top-0 right-0 bottom-0 w-2 cursor-ew-resize group"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    setIsResizing(true);
                    
                    const startX = e.pageX;
                    const startWidth = cameraWidth;
                    
                    const handleMouseMove = (e: MouseEvent) => {
                      const deltaX = e.pageX - startX;
                      const parentWidth = (e.target as HTMLElement).closest('.flex')?.querySelector('div')?.offsetWidth || window.innerWidth;
                      const deltaPercent = (deltaX / parentWidth) * 100;
                      const newWidth = Math.min(70, Math.max(20, startWidth + deltaPercent));
                      setCameraWidth(newWidth);
                    };
                    
                    const handleMouseUp = () => {
                      setIsResizing(false);
                      document.removeEventListener('mousemove', handleMouseMove);
                      document.removeEventListener('mouseup', handleMouseUp);
                    };
                    
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                  }}
                >
                  <div 
                    className={`absolute top-1/2 right-1 -translate-y-1/2 p-1 rounded bg-background/80 backdrop-blur-sm transition-opacity ${
                      isResizing ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'
                    }`}
                    style={{ 
                      border: `1px solid ${colors.border}`,
                      cursor: 'ew-resize'
                    }}
                  >
                    <GripVertical className="w-4 h-4" style={{ color: isResizing ? colors.primary : colors.muted }} />
                  </div>
                </div>
              </div>
            </div>
          )}


          {/* Scroll to Bottom Indicator */}
          <AnimatePresence>
            {showScrollIndicator && (
              <motion.button
                initial={{ opacity: 0, y: invertedStacking ? -20 : 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: invertedStacking ? -20 : 20 }}
                onClick={scrollToLatest}
                className={`absolute ${invertedStacking ? 'top-8' : 'bottom-8'} right-8 p-3 rounded-full shadow-lg transition-all z-20`}
                style={{ 
                  backgroundColor: colors.primary,
                  color: isDark ? 'hsl(210, 40%, 3%)' : '#ffffff'
                }}
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.95 }}
              >
                <ArrowDown className={`w-5 h-5 ${invertedStacking ? 'rotate-180' : ''}`} />
              </motion.button>
            )}
          </AnimatePresence>

          {/* Translation Display */}
          <div 
            ref={translationScrollRef}
            className="h-full flex flex-col overflow-hidden transition-[width] duration-75"
            style={{
              width: showCamera && window.innerWidth >= 1024 ? `${100 - cameraWidth}%` : '100%'
            }}
          >
            {/* Translation Cards */}
            <div 
              ref={modernTranslationRef} 
              className="flex-1 overflow-y-auto px-6 pb-6 space-y-4 scroll-smooth scrollbar-hide"
              onScroll={checkScrollPosition}
            >
              <AnimatePresence mode="popLayout">
                {lines.length > 0 ? (
                  (invertedStacking ? [...lines].reverse() : lines).map((line, index) => {
                    const originalIndex = invertedStacking ? lines.length - 1 - index : index;
                    const isLatest = originalIndex === lines.length - 1;
                    const isActive = activeLineId === line.id;
                    
                    return (
                      <motion.div
                        key={line.id}
                        layout
                        initial={{ opacity: 0, y: invertedStacking ? -20 : 20, scale: 0.95 }}
                        animate={{ 
                          opacity: isLatest ? 1 : 0.7,
                          y: 0,
                          scale: 1
                        }}
                        exit={{ opacity: 0, y: invertedStacking ? 20 : -20, scale: 0.95 }}
                        transition={{ 
                          type: "spring",
                          stiffness: 500,
                          damping: 30
                        }}
                        className="relative"
                      >
                        <div 
                          className="rounded-2xl p-6 backdrop-blur-sm transition-all duration-300"
                          style={{ 
                            backgroundColor: isDark 
                              ? isLatest ? 'rgba(255, 255, 255, 0.08)' : 'rgba(255, 255, 255, 0.04)'
                              : isLatest ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.6)',
                            border: `1px solid ${isDark 
                              ? isLatest ? 'rgba(255, 255, 255, 0.15)' : 'rgba(255, 255, 255, 0.08)'
                              : isLatest ? 'rgba(10, 58, 58, 0.2)' : 'rgba(10, 58, 58, 0.1)'}`,
                            boxShadow: isLatest 
                              ? isDark 
                                ? '0 4px 20px rgba(138, 180, 248, 0.15)' 
                                : '0 4px 20px rgba(212, 165, 116, 0.2)'
                              : 'none'
                          }}
                        >
                          {/* Golden Indicator Bar */}
                          {isLatest && (
                            <motion.div
                              className="absolute left-0 top-0 bottom-0 w-1 rounded-l-2xl"
                              style={{ backgroundColor: colors.primary }}
                              initial={{ scaleY: 0 }}
                              animate={{ scaleY: 1 }}
                              transition={{ delay: 0.2, duration: 0.3 }}
                            />
                          )}
                          
                          
                          {/* Translation Text */}
                          <p 
                            className="leading-relaxed"
                            style={{ 
                              color: colors.foreground,
                              opacity: isLatest ? 1 : 0.8,
                              fontSize: compactFont ? 'clamp(1rem, 2vw, 1.5rem)' : 'clamp(1.2rem, 2.5vw, 2rem)' // Responsive font size for mosque displays
                            }}
                          >
                            {line.text}
                          </p>
                        </div>
                      </motion.div>
                    );
                  })
                ) : (
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="flex items-center justify-center h-full"
                  >
                    <div className="text-center">
                      <motion.div
                        animate={{ scale: [1, 1.2, 1] }}
                        transition={{ duration: 2, repeat: Infinity }}
                        className="w-16 h-16 mx-auto mb-4 rounded-full"
                        style={{ backgroundColor: `${colors.primary}20` }}
                      >
                        <div 
                          className="w-full h-full rounded-full flex items-center justify-center"
                          style={{ backgroundColor: `${colors.primary}40` }}
                        >
                          <Circle className="w-8 h-8" style={{ color: colors.primary }} />
                        </div>
                      </motion.div>
                      <p style={{ color: colors.muted }}>
                        {connectionStatus === 'connected' ? t('quranDisplay.waitingForTranslation') : t('quranDisplay.demoTranslation')}
                      </p>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>
      </div>
    </div>
      )}
    </>
  );
};

export default QuranDisplayView; 


================================================
FILE: src/features/display/components/TypewriterView.tsx
================================================
import { useEffect, useState, useRef } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';
import { useTranslation } from '@/hooks/useTranslation';

interface TypewriterViewProps {
  currentSentence: {
    id: string;
    transcription: string;
    timestamp: string;
    isComplete?: boolean;
  } | null;
  sentences: Array<{
    id: string;
    transcription: string;
    translation: string;
    isComplete: boolean;
    timestamp: string;
  }>;
  room: {
    transcription_language?: string;
    translation__language?: string;
  };
  isMonitoring: boolean;
  displayedTranscription: string;
  displayedTranslation: string;
  onTranscriptionUpdate: (text: string) => void;
  onTranslationUpdate: (text: string) => void;
  skipAnimation?: boolean;
}

// Language utilities (copied from LiveMonitor for consistency)
const getLanguageDisplayName = (code: string): string => {
  const languageMap: Record<string, string> = {
    'ar': 'Arabic',
    'en': 'English', 
    'nl': 'Dutch',
    'fr': 'French',
    'de': 'German',
    'es': 'Spanish',
    'it': 'Italian',
    'pt': 'Portuguese',
    'ru': 'Russian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'hi': 'Hindi',
    'ur': 'Urdu',
    'tr': 'Turkish'
  };
  
  return languageMap[code?.toLowerCase()] || code?.toUpperCase() || 'Unknown';
};

const isRTLLanguage = (code: string): boolean => {
  const rtlLanguages = ['ar', 'ur', 'fa', 'he'];
  return rtlLanguages.includes(code?.toLowerCase());
};

const TypewriterView = ({ 
  currentSentence, 
  sentences, 
  room, 
  isMonitoring,
  displayedTranscription,
  displayedTranslation,
  onTranscriptionUpdate,
  onTranslationUpdate,
  skipAnimation = false
}: TypewriterViewProps) => {
  const { t } = useTranslation();
  const transcriptionScrollRef = useRef<HTMLDivElement>(null);
  const translationScrollRef = useRef<HTMLDivElement>(null);
  
  // State to store accumulated text
  const [accumulatedTranscription, setAccumulatedTranscription] = useState('');
  const [accumulatedTranslation, setAccumulatedTranslation] = useState('');
  const [isTypingTranscription, setIsTypingTranscription] = useState(false);
  const [isTypingTranslation, setIsTypingTranslation] = useState(false);
  
  const transcriptionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const translationTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Build the complete text from all sentences
  useEffect(() => {
    // Build transcription text from all completed sentences (reverse to get chronological order)
    const completedTranscriptions = [...sentences]
      .reverse()
      .map(s => s.transcription)
      .filter(text => text && text.trim())
      .join(' ');
    
    // Add current sentence if it exists
    let fullTranscription = completedTranscriptions;
    if (currentSentence?.transcription) {
      fullTranscription = fullTranscription 
        ? `${fullTranscription} ${currentSentence.transcription}` 
        : currentSentence.transcription;
    }
    
    // Update accumulated transcription
    setAccumulatedTranscription(fullTranscription);
    
    // Build translation text (only from sentences with translations)
    const completedTranslations = [...sentences]
      .reverse()
      .filter(s => s.translation && s.translation.trim())
      .map(s => s.translation)
      .join(' ');
    
    setAccumulatedTranslation(completedTranslations);
  }, [sentences, currentSentence]);

  // Typewriter effect for transcription - only animate NEW content
  useEffect(() => {
    // Clear any existing timeout
    if (transcriptionTimeoutRef.current) {
      clearTimeout(transcriptionTimeoutRef.current);
    }

    // If accumulated text is longer than displayed, type the difference
    if (accumulatedTranscription.length > displayedTranscription.length) {
      // Make sure displayed text matches the beginning of accumulated text
      if (!accumulatedTranscription.startsWith(displayedTranscription)) {
        // If text changed completely, update to match
        onTranscriptionUpdate(accumulatedTranscription);
        return;
      }
      
      setIsTypingTranscription(true);
      
      const typeNextChar = () => {
        const nextLength = displayedTranscription.length + 1;
        if (nextLength <= accumulatedTranscription.length) {
          onTranscriptionUpdate(accumulatedTranscription.slice(0, nextLength));
          transcriptionTimeoutRef.current = setTimeout(typeNextChar, 30);
        } else {
          setIsTypingTranscription(false);
        }
      };
      
      transcriptionTimeoutRef.current = setTimeout(typeNextChar, 30);
    } else {
      setIsTypingTranscription(false);
    }
    
    return () => {
      if (transcriptionTimeoutRef.current) {
        clearTimeout(transcriptionTimeoutRef.current);
      }
    };
  }, [accumulatedTranscription, displayedTranscription, onTranscriptionUpdate]);

  // Typewriter effect for translation - only animate NEW content
  useEffect(() => {
    // Clear any existing timeout
    if (translationTimeoutRef.current) {
      clearTimeout(translationTimeoutRef.current);
    }

    // If accumulated text is longer than displayed, type the difference
    if (accumulatedTranslation.length > displayedTranslation.length) {
      // Make sure displayed text matches the beginning of accumulated text
      if (!accumulatedTranslation.startsWith(displayedTranslation)) {
        // If text changed completely, update to match
        onTranslationUpdate(accumulatedTranslation);
        return;
      }
      
      setIsTypingTranslation(true);
      
      const typeNextChar = () => {
        const nextLength = displayedTranslation.length + 1;
        if (nextLength <= accumulatedTranslation.length) {
          onTranslationUpdate(accumulatedTranslation.slice(0, nextLength));
          translationTimeoutRef.current = setTimeout(typeNextChar, 40);
        } else {
          setIsTypingTranslation(false);
        }
      };
      
      translationTimeoutRef.current = setTimeout(typeNextChar, 40);
    } else {
      setIsTypingTranslation(false);
    }
    
    return () => {
      if (translationTimeoutRef.current) {
        clearTimeout(translationTimeoutRef.current);
      }
    };
  }, [accumulatedTranslation, displayedTranslation, onTranslationUpdate]);

  // Auto-scroll effect
  useEffect(() => {
    if (transcriptionScrollRef.current && isTypingTranscription) {
      transcriptionScrollRef.current.scrollTop = transcriptionScrollRef.current.scrollHeight;
    }
  }, [displayedTranscription, isTypingTranscription]);

  useEffect(() => {
    if (translationScrollRef.current && isTypingTranslation) {
      translationScrollRef.current.scrollTop = translationScrollRef.current.scrollHeight;
    }
  }, [displayedTranslation, isTypingTranslation]);

  return (
    <div className="flex flex-col h-full space-y-4">
      {/* Transcription Section */}
      <Card className="flex-1 bg-card/50 backdrop-blur-sm">
        <CardContent className="h-full flex flex-col p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold">
              {t('liveMonitor.liveTranscription')} ({getLanguageDisplayName(room.transcription_language || 'ar')})
            </h3>
            {isTypingTranscription && (
              <div className="flex items-center gap-2">
                <div className="h-2 w-2 bg-yellow-500 rounded-full animate-pulse" />
                <span className="text-xs text-muted-foreground">{t('liveMonitor.typing')}</span>
              </div>
            )}
          </div>
          
          <div 
            ref={transcriptionScrollRef}
            className="flex-1 overflow-y-auto pr-2"
            style={{ scrollBehavior: 'smooth' }}
          >
            <p 
              className="text-xl leading-relaxed font-medium min-h-[100px] whitespace-pre-wrap"
              dir={isRTLLanguage(room.transcription_language || 'ar') ? 'rtl' : 'ltr'}
              style={{
                textAlign: isRTLLanguage(room.transcription_language || 'ar') ? 'right' : 'left'
              }}
            >
              {displayedTranscription || (isMonitoring ? '' : t('liveMonitor.waitingForActivity'))}
              {isTypingTranscription && (
                <span className="inline-block w-[3px] h-6 bg-primary animate-blink ml-1" />
              )}
            </p>
          </div>
        </CardContent>
      </Card>

      <Separator />

      {/* Translation Section */}
      <Card className="flex-1 bg-card/50 backdrop-blur-sm">
        <CardContent className="h-full flex flex-col p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold">
              {t('liveMonitor.liveTranslation')} ({getLanguageDisplayName(room.translation__language || 'nl')})
            </h3>
            {isTypingTranslation && (
              <div className="flex items-center gap-2">
                <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
                <span className="text-xs text-muted-foreground">{t('liveMonitor.typing')}</span>
              </div>
            )}
          </div>
          
          <div 
            ref={translationScrollRef}
            className="flex-1 overflow-y-auto pr-2"
            style={{ scrollBehavior: 'smooth' }}
          >
            {!isMonitoring ? (
              <p className="text-lg text-muted-foreground italic">
                {t('liveMonitor.startMonitoringPrompt')}
              </p>
            ) : (
              <p 
                className="text-xl leading-relaxed font-medium min-h-[100px] whitespace-pre-wrap"
                dir={isRTLLanguage(room.translation__language || 'nl') ? 'rtl' : 'ltr'}
                style={{
                  textAlign: isRTLLanguage(room.translation__language || 'nl') ? 'right' : 'left'
                }}
              >
                {displayedTranslation || 
                  (!displayedTranscription ? '' : 
                    <span className="text-muted-foreground italic">{t('liveMonitor.waitingForTranslation')}</span>
                  )
                }
                {isTypingTranslation && (
                  <span className="inline-block w-[3px] h-6 bg-primary animate-blink ml-1" />
                )}
              </p>
            )}
          </div>
        </CardContent>
      </Card>
      
      <style jsx>{`
        @keyframes blink {
          0%, 50% { opacity: 1; }
          51%, 100% { opacity: 0; }
        }
        
        .animate-blink {
          animation: blink 1s infinite;
        }
      `}</style>
    </div>
  );
};

export default TypewriterView;


================================================
FILE: src/features/display/components/VideoStream.tsx
================================================
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { Camera, CameraOff, AlertCircle } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';

interface VideoStreamProps {
  deviceId?: string;
  className?: string;
  onCameraChange?: (deviceId: string) => void;
}

const VideoStream: React.FC<VideoStreamProps> = ({ deviceId, className, onCameraChange }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [streamReady, setStreamReady] = useState(false);
  const [pendingStream, setPendingStream] = useState<MediaStream | null>(null);
  const [availableCameras, setAvailableCameras] = useState<MediaDeviceInfo[]>([]);
  const [videoState, setVideoState] = useState<{
    isPlaying: boolean;
    hasMetadata: boolean;
    dimensions: { width: number; height: number };
  }>({
    isPlaying: false,
    hasMetadata: false,
    dimensions: { width: 0, height: 0 }
  });

  const { t } = useTranslation();

  // Cleanup function to stop all tracks
  const stopAllTracks = useCallback(() => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => {
        track.stop();
      });
      streamRef.current = null;
    }
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
    setStreamReady(false);
    setPendingStream(null);
    setVideoState({
      isPlaying: false,
      hasMetadata: false,
      dimensions: { width: 0, height: 0 }
    });
  }, []);

  // Get available cameras
  const getAvailableCameras = useCallback(async () => {
    try {
      // First, try to get camera permission if not already granted
      // This ensures we get proper device labels
      try {
        const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
        tempStream.getTracks().forEach(track => track.stop());
      } catch (permErr) {
        console.log('Could not get camera permission for enumeration:', permErr);
      }
      
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cameras = devices.filter(device => device.kind === 'videoinput');
      setAvailableCameras(cameras);
      console.log('Available cameras:', cameras);
    } catch (err) {
      console.error('Error enumerating cameras:', err);
      setError('Failed to detect cameras');
    }
  }, []);

  // Start camera stream
  const startStream = useCallback(async () => {
    if (!deviceId) {
      console.log('No deviceId provided, skipping stream start');
      return;
    }

    console.log('Starting stream with deviceId:', deviceId);
    setIsLoading(true);
    setError(null); // Clear any previous errors when starting a new stream

    try {
      // Stop any existing stream first
      stopAllTracks();

      // Check if we're in a secure context (HTTPS or localhost)
      if (!window.isSecureContext) {
        throw new Error('Camera access requires HTTPS or localhost. Current protocol: ' + window.location.protocol);
      }

      // Check if mediaDevices API is available
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Camera API not available in this browser');
      }

      const constraints = {
        video: {
          deviceId: deviceId ? { ideal: deviceId } : undefined,
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      };

      console.log('Requesting camera with constraints:', constraints);
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      console.log('Got stream:', stream.id, 'with tracks:', stream.getTracks().length);

      // Store stream reference
      streamRef.current = stream;
      setPendingStream(stream);
      setIsLoading(false);
      setError(null); // Clear any previous errors
      
      // Get fresh camera list after successful connection
      getAvailableCameras();
    } catch (err) {
      let errorMessage = 'Failed to access camera';
      
      if (err instanceof DOMException) {
        switch (err.name) {
          case 'NotAllowedError':
            errorMessage = 'Camera access denied. Please allow camera permissions in your browser settings.';
            break;
          case 'NotFoundError':
            errorMessage = 'No camera found. Please check your camera connection.';
            break;
          case 'NotReadableError':
            errorMessage = 'Camera is already in use by another application.';
            break;
          case 'OverconstrainedError':
            errorMessage = 'Camera does not support the requested settings.';
            break;
          case 'SecurityError':
            errorMessage = 'Camera access requires HTTPS. Please use a secure connection.';
            break;
          default:
            errorMessage = `Camera error: ${err.message}`;
        }
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }
      
      setError(errorMessage);
      stopAllTracks();
      setIsLoading(false);
      // Get available cameras when error occurs
      getAvailableCameras();
    }
  }, [deviceId, stopAllTracks, getAvailableCameras]);

  // Effect to get available cameras and handle device changes
  useEffect(() => {
    console.log('VideoStream mounted, getting available cameras...');
    // Get available cameras on mount
    getAvailableCameras();
    
    // Listen for device changes (camera plug/unplug)
    const handleDeviceChange = () => {
      console.log('Device change detected, refreshing camera list...');
      getAvailableCameras();
    };
    
    navigator.mediaDevices?.addEventListener('devicechange', handleDeviceChange);
    
    return () => {
      navigator.mediaDevices?.removeEventListener('devicechange', handleDeviceChange);
    };
  }, [getAvailableCameras]);
  
  // Effect to start/restart stream when deviceId changes
  useEffect(() => {
    console.log('VideoStream deviceId effect triggered. deviceId:', deviceId);
    if (deviceId) {
      console.log('DeviceId exists, starting stream...');
      startStream();
    } else {
      console.log('No deviceId, stopping all tracks...');
      stopAllTracks();
    }
    
    // Cleanup on unmount
    return () => {
      stopAllTracks();
    };
  }, [deviceId, startStream, stopAllTracks]); // Include dependencies properly

  // Effect to attach pending stream to video element
  useEffect(() => {
    if (pendingStream && videoRef.current && !error) {
      videoRef.current.srcObject = pendingStream;
      setStreamReady(true);
      setPendingStream(null);
      }
  }, [pendingStream, error]);

  // Handle video element events
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleLoadedMetadata = () => {
      setVideoState(prev => ({
        ...prev,
        hasMetadata: true,
        dimensions: { width: video.videoWidth, height: video.videoHeight }
      }));

      // Try to play automatically after metadata is loaded
      video.play()
        .then(() => {
          setVideoState(prev => ({ ...prev, isPlaying: true }));
        })
        .catch(err => {
          // Autoplay might be blocked, user will need to click play button
        });
    };

    const handlePlay = () => {
      setVideoState(prev => ({ ...prev, isPlaying: true }));
    };

    const handlePause = () => {
      setVideoState(prev => ({ ...prev, isPlaying: false }));
    };

    const handleError = (e: Event) => {
      const videoError = video.error;
      if (videoError) {
        let message = 'Video playback error';
        switch (videoError.code) {
          case videoError.MEDIA_ERR_ABORTED:
            message = 'Video playback aborted';
            break;
          case videoError.MEDIA_ERR_NETWORK:
            message = 'Network error during video playback';
            break;
          case videoError.MEDIA_ERR_DECODE:
            message = 'Video decode error';
            break;
          case videoError.MEDIA_ERR_SRC_NOT_SUPPORTED:
            message = 'Video source not supported';
            break;
        }
        setError(message);
      }
    };

    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('play', handlePlay);
    video.addEventListener('pause', handlePause);
    video.addEventListener('error', handleError);

    return () => {
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('play', handlePlay);
      video.removeEventListener('pause', handlePause);
      video.removeEventListener('error', handleError);
    };
  }, [streamReady]);

  // Manual play function for button
  const handleManualPlay = async () => {
    if (!videoRef.current) return;
    
    try {
      await videoRef.current.play();
      } catch (err) {
      // If play fails, try restarting the stream
      await startStream();
    }
  };

  if (!deviceId) {
    return (
      <div className={`flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-800 rounded-lg p-4 ${className}`}>
        <CameraOff className="w-8 h-8 sm:w-12 sm:h-12 text-gray-400 mb-2" />
        <p className="text-gray-600 dark:text-gray-400 text-xs sm:text-sm mb-2">{t('videoStream.noCameraSelected')}</p>
        
        {/* Compact camera selector */}
        {onCameraChange && (
          <>
            {availableCameras.length > 0 ? (
              <select
                onChange={(e) => {
                  console.log('Camera selection changed to:', e.target.value);
                  if (e.target.value) {
                    onCameraChange(e.target.value);
                  }
                }}
                className="mt-2 px-2 py-1 text-xs sm:text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                defaultValue=""
              >
                <option value="">{t('videoStream.selectCamera')}</option>
                {availableCameras.map((camera, index) => (
                  <option key={camera.deviceId} value={camera.deviceId}>
                    {camera.label || `${t('videoStream.camera')} ${index + 1}`}
                  </option>
                ))}
              </select>
            ) : (
              <button
                onClick={async () => {
                  console.log('Manually requesting camera permission...');
                  await getAvailableCameras();
                }}
                className="mt-2 px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white text-xs sm:text-sm rounded transition-colors"
              >
                {t('videoStream.enableCamera')}
              </button>
            )}
          </>
        )}
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className={`flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-800 rounded-lg ${className}`}>
        <div className="animate-pulse">
          <Camera className="w-12 h-12 text-gray-400 mb-2" />
        </div>
        <p className="text-gray-600 dark:text-gray-400 text-sm">{t('videoStream.connectingToCamera')}</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className={`flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-800 rounded-lg p-4 ${className}`}>
        <CameraOff className="w-8 h-8 sm:w-12 sm:h-12 text-gray-400 mb-2" />
        
        {/* Simplified error message */}
        <p className="text-gray-600 dark:text-gray-400 text-xs sm:text-sm text-center mb-2">
          {error.includes('No camera found') ? t('videoStream.noCameraFound') : 
           error.includes('denied') ? t('videoStream.accessDenied') :
           error.includes('in use') ? t('videoStream.cameraInUse') :
           t('videoStream.cameraUnavailable')}
        </p>
        
        {/* Compact camera selector or retry button */}
        {onCameraChange && availableCameras.length > 0 ? (
          <select
            value={deviceId || ''}
            onChange={(e) => onCameraChange(e.target.value)}
            className="mt-2 px-2 py-1 text-xs sm:text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
          >
            <option value="">{t('videoStream.selectCamera')}</option>
            {availableCameras.map((camera, index) => (
              <option key={camera.deviceId} value={camera.deviceId}>
                {camera.label || `${t('videoStream.camera')} ${index + 1}`}
              </option>
            ))}
          </select>
        ) : (
          <button
            onClick={startStream}
            className="mt-2 px-3 py-1 bg-gray-500 hover:bg-gray-600 text-white text-xs sm:text-sm rounded transition-colors"
          >
            {t('common.retry')}
          </button>
        )}
      </div>
    );
  }

  return (
    <div className="relative w-full h-full rounded-lg overflow-hidden bg-black">
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted
        controls={false}
        className="absolute inset-0 w-full h-full object-cover"
        style={{ 
          transform: 'scaleX(-1)', // Mirror the video like a selfie camera
          minHeight: '100px' // Ensure minimum height
        }}
      />
      
      {/* Debug overlay */}
      {process.env.NODE_ENV === 'development' && streamReady && (
        <div className="absolute top-2 left-2 bg-black bg-opacity-75 text-white text-xs p-2 rounded">
          <div>Stream: {streamReady ? '✓' : '✗'}</div>
          <div>Metadata: {videoState.hasMetadata ? '✓' : '✗'}</div>
          <div>Playing: {videoState.isPlaying ? '✓' : '✗'}</div>
          <div>Size: {videoState.dimensions.width}x{videoState.dimensions.height}</div>
          <div>Device: {deviceId ? deviceId.substring(0, 8) + '...' : 'none'}</div>
        </div>
      )}
      
      {/* Manual play button - shown when stream is ready but not playing */}
      {streamReady && !videoState.isPlaying && (
        <button
          onClick={handleManualPlay}
          className="absolute bottom-4 right-4 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow-lg transition-colors flex items-center gap-2"
        >
          <Camera className="w-4 h-4" />
          {t('videoStream.startCamera')}
        </button>
      )}
    </div>
  );
};

export default VideoStream;


================================================
FILE: src/features/display/pages/DisplayPage.tsx
================================================
import { useEffect } from 'react';
import { useSearchParams } from 'react-router-dom';
import QuranDisplayView from '@/features/display/components/QuranDisplayView';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';

const DisplayPage = () => {
  const [searchParams] = useSearchParams();
  const roomName = searchParams.get('room');
  const mosqueId = searchParams.get('mosque_id');
  const roomId = searchParams.get('room_id');
  const sessionId = searchParams.get('session_id');
  const { t } = useTranslation();

  useEffect(() => {
    // Hide browser UI elements for clean display
    document.body.style.margin = '0';
    document.body.style.padding = '0';
    document.body.style.overflow = 'hidden';
    
    return () => {
      // Cleanup on unmount
      document.body.style.margin = '';
      document.body.style.padding = '';
      document.body.style.overflow = '';
    };
  }, []);

  if (!roomName && !roomId && !sessionId) {
    return (
      <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex items-center justify-center p-4">
        <Card className="max-w-md w-full text-center shadow-lg border-2 border-red-500/50 bg-white dark:bg-gray-800">
          <CardHeader>
            <AlertCircle className="h-16 w-16 text-red-500 mx-auto mb-4" />
            <CardTitle className="text-3xl font-bold text-red-600 dark:text-red-400">
              {t('displayPage.notConnectedTitle')}
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-lg mb-6">
              {t('displayPage.notConnectedDescription')}
            </p>
            <div className="bg-gray-200 dark:bg-gray-700 p-4 rounded-lg">
              <code className="text-sm font-mono break-all">
                {t('displayPage.exampleUrl')}
              </code>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen w-full" style={{ backgroundColor: '#fdf1f4' }}>
      <QuranDisplayView 
        roomName={roomName}
        mosqueId={mosqueId ? parseInt(mosqueId) : undefined}
        roomId={roomId ? parseInt(roomId) : undefined}
        sessionId={sessionId || undefined}
      />
    </div>
  );
};

export default DisplayPage;


================================================
FILE: src/features/display/pages/PublicDisplayPage.tsx
================================================
import { useState } from 'react';
import { supabase } from '@/integrations/supabase/client';
import QuranDisplayView from '@/features/display/components/QuranDisplayView';
import { Loader2, AlertCircle, Play } from 'lucide-react';
import { useTranslation } from '@/hooks/useTranslation';

interface RoomData {
  room_id: number;
  room_title: string;
  mosque_id: number;
  mosque_name: string;
  livekit_room_name: string;
  transcription_language: string;
  translation_language: string;
}


const PublicDisplayPage = () => {
  const [roomCode, setRoomCode] = useState('');
  const [roomData, setRoomData] = useState<RoomData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [connected, setConnected] = useState(false);
  const [inactivityTimeout, setInactivityTimeout] = useState<number>(60);
  const { t } = useTranslation();

  const handleConnect = async () => {
    if (!roomCode.trim()) {
      setError(t('publicDisplay.connectError'));
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Call the database function to get room info by code
      const { data, error: rpcError } = await supabase.rpc('get_room_by_code', {
        room_code: parseInt(roomCode.trim())
      });

      if (rpcError) {
        setError(t('publicDisplay.validationError'));
        setLoading(false);
        return;
      }

      if (!data || data.length === 0) {
        setError(t('publicDisplay.invalidCode'));
        setLoading(false);
        return;
      }

      setRoomData(data[0]);
      
      // Fetch mosque settings for public display timeout
      const { data: mosqueData, error: mosqueError } = await supabase
        .from('Mosque')
        .select('public_display_settings')
        .eq('id', data[0].mosque_id)
        .single();
      
      if (!mosqueError && mosqueData?.public_display_settings) {
        const settings = mosqueData.public_display_settings as any;
        if (settings.inactivity_timeout) {
          setInactivityTimeout(settings.inactivity_timeout);
        }
      }
      
      setConnected(true);
      setLoading(false);
    } catch (err) {
      setError(t('publicDisplay.connectionFailed'));
      setLoading(false);
    }
  };

  const handleDisconnect = () => {
    setConnected(false);
    setRoomData(null);
    setRoomCode('');
    setError(null);
  };

  if (connected && roomData) {
    return (
      <div className="min-h-screen w-full relative" style={{ backgroundColor: '#fdf1f4' }}>
        <QuranDisplayView 
          roomName={roomData.livekit_room_name}
          mosqueId={roomData.mosque_id}
          roomId={roomData.room_id}
          onDisconnect={handleDisconnect}
          isKioskMode={true}
          mosqueName={roomData.mosque_name}
          inactivityTimeout={inactivityTimeout}
        />
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center p-4" style={{ backgroundColor: '#fdf1f4' }}>
      <div className="w-full max-w-md rounded-lg shadow-lg" style={{ backgroundColor: '#fef5f7' }}>
        <div className="text-center p-6 border-b" style={{ borderColor: 'rgba(10, 58, 58, 0.1)' }}>
          <h2 className="flex items-center justify-center gap-2 text-xl font-semibold" style={{ color: '#0a3a3a' }}>
            <Play className="h-6 w-6" style={{ color: '#d4a574' }} />
            {t('publicDisplay.title')}
          </h2>
          <p className="mt-2" style={{ color: '#0a3a3a', opacity: 0.7 }}>
            {t('publicDisplay.description')}
          </p>
        </div>
        <div className="p-6 space-y-4">
          <div className="space-y-2">
            <label htmlFor="roomCode" className="text-sm font-medium" style={{ color: '#0a3a3a' }}>
              {t('publicDisplay.roomCodeLabel')}
            </label>
            <input
              id="roomCode"
              type="text"
              placeholder={t('publicDisplay.roomCodePlaceholder')}
              value={roomCode}
              onChange={(e) => setRoomCode(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleConnect()}
              disabled={loading}
              className="w-full px-3 py-2 rounded-md border transition-colors"
              style={{ 
                backgroundColor: 'white',
                borderColor: 'rgba(10, 58, 58, 0.2)',
                color: '#0a3a3a'
              }}
            />
          </div>

          {error && (
            <div className="flex items-center gap-2 text-sm" style={{ color: '#dc2626' }}>
              <AlertCircle className="h-4 w-4" />
              {error}
            </div>
          )}

          <button 
            onClick={handleConnect}
            disabled={loading || !roomCode.trim()}
            className="w-full py-2.5 px-4 rounded-md font-medium transition-colors disabled:opacity-50"
            style={{ 
              backgroundColor: '#0a3a3a',
              color: '#fdf1f4'
            }}
            onMouseEnter={(e) => !loading && (e.currentTarget.style.backgroundColor = '#083030')}
            onMouseLeave={(e) => !loading && (e.currentTarget.style.backgroundColor = '#0a3a3a')}
          >
            {loading ? (
              <span className="flex items-center justify-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                {t('publicDisplay.connecting')}
              </span>
            ) : (
              t('publicDisplay.connectButton')
            )}
          </button>

          <div className="text-xs text-center" style={{ color: '#0a3a3a', opacity: 0.6 }}>
            {t('publicDisplay.instructions')}
          </div>
        </div>
      </div>
    </div>
  );
};

export default PublicDisplayPage;


================================================
FILE: src/features/display/utils/TranslationCommaBuffer.test.ts
================================================
/**
 * Test suite for TranslationCommaBuffer
 * Verifies that comma-separated translations are split and displayed sequentially
 * without interruption from new incoming messages.
 */

import { TranslationCommaBuffer } from './TranslationCommaBuffer';

describe('TranslationCommaBuffer', () => {
  let buffer: TranslationCommaBuffer;
  let displayedMessages: Array<{ text: string; timestamp: number }>;
  
  beforeEach(() => {
    displayedMessages = [];
    buffer = new TranslationCommaBuffer({
      displayInterval: 100, // Fast for testing
      enabled: true
    });
    
    // Set up mock display callback
    buffer.setDisplayCallback((text, language, timestamp) => {
      displayedMessages.push({ text, timestamp: Date.now() });
      console.log(`Displayed: "${text}" at ${Date.now()}`);
    });
  });
  
  afterEach(() => {
    buffer.clearQueue();
  });
  
  test('does not split short text (under 100 chars)', async () => {
    const shortInput = 'This is a short message that should not be split even though it has some text'; // 78 chars
    
    buffer.addTranslation(shortInput, 'en', '2024-01-01T00:00:00');
    
    // Wait to ensure it's processed
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Should NOT be split
    expect(displayedMessages).toHaveLength(1);
    expect(displayedMessages[0].text).toBe(shortInput);
  });
  
  test('splits long text (over 100 chars) into two equal parts', async () => {
    // 120 chars total - should split around char 60
    const longInput = 'This is a very long message that exceeds one hundred characters and will be split into two roughly equal parts for display';
    
    buffer.addTranslation(longInput, 'en', '2024-01-01T00:00:00');
    
    // Wait for all segments to be displayed
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Should be split into exactly 2 parts near the middle
    expect(displayedMessages).toHaveLength(2);
    
    // Check that parts are roughly equal in length
    const part1Length = displayedMessages[0].text.length;
    const part2Length = displayedMessages[1].text.length;
    const totalLength = part1Length + part2Length + 1; // +1 for the space between
    
    expect(totalLength).toBeCloseTo(longInput.length, 0);
    expect(Math.abs(part1Length - part2Length)).toBeLessThan(20); // Parts should be within 20 chars of each other
    
    // Check timing between segments
    const timeDiff = displayedMessages[1].timestamp - displayedMessages[0].timestamp;
    expect(timeDiff).toBeGreaterThanOrEqual(90);
  });
  
  test('prevents interruption during multi-segment display', async () => {
    // Long message that will be split into 2 equal parts (110 chars)
    const longMessage = 'This is the first part of a very long message that exceeds one hundred chars and this is the second part here';
    buffer.addTranslation(longMessage, 'en', '2024-01-01T00:00:00');
    
    // Wait 50ms (during first segment display)
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Try to add a rogue message
    buffer.addTranslation('ROGUE MESSAGE', 'en', '2024-01-01T00:00:01');
    
    // Wait for all messages to complete
    await new Promise(resolve => setTimeout(resolve, 400));
    
    // Verify the order - all segments from first message should appear before rogue
    expect(displayedMessages).toHaveLength(3);
    // First message should be split into 2 roughly equal parts
    expect(displayedMessages[0].text.length).toBeGreaterThan(40);
    expect(displayedMessages[1].text.length).toBeGreaterThan(40);
    expect(displayedMessages[2].text).toBe('ROGUE MESSAGE');
    
    console.log('Display order:', displayedMessages.map(m => m.text));
  });
  
  test('handles multiple messages in queue correctly', async () => {
    // Short message (won't be split)
    buffer.addTranslation('Short message, with comma', 'en', '2024-01-01T00:00:00');
    
    // Long message (will be split at first comma)
    const longMsg = 'This is a very long message that definitely exceeds seventy characters, and it has multiple commas, see';
    buffer.addTranslation(longMsg, 'en', '2024-01-01T00:00:01');
    
    // Another short message
    buffer.addTranslation('Final short message', 'en', '2024-01-01T00:00:02');
    
    // Wait for all to complete
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Check all messages appear in correct order
    expect(displayedMessages).toHaveLength(4);
    
    // First message (not split - too short)
    expect(displayedMessages[0].text).toBe('Short message, with comma');
    
    // Second message (split into 2 parts)
    expect(displayedMessages[1].text).toBe('This is a very long message that definitely exceeds seventy characters,');
    expect(displayedMessages[2].text).toBe('and it has multiple commas, see');
    
    // Third message (no comma)
    expect(displayedMessages[3].text).toBe('Final short message');
  });
  
  test('respects 100-character threshold precisely', async () => {
    // Exactly 100 chars - should NOT split
    const exactly100 = 'This is a message that is exactly one hundred characters long for testing the split threshold here!!'; // 100 chars
    buffer.addTranslation(exactly100, 'en', '2024-01-01T00:00:00');
    
    // 101 chars - should split
    const hundred01 = 'This is a message that is exactly one hundred and one characters long for testing the threshold now!'; // 101 chars
    buffer.addTranslation(hundred01, 'en', '2024-01-01T00:00:01');
    
    await new Promise(resolve => setTimeout(resolve, 400));
    
    // First message not split (exactly 100)
    expect(displayedMessages[0].text).toBe(exactly100);
    
    // Second message should be split (101 chars)
    expect(displayedMessages.length).toBe(3); // First message + 2 parts of second
    expect(displayedMessages[1].text.length).toBeGreaterThan(30); // Part 1
    expect(displayedMessages[2].text.length).toBeGreaterThan(30); // Part 2
  });
  
  test('respects disabled state', async () => {
    buffer.setEnabled(false);
    
    // Mock direct callback for disabled mode
    const directMessages: string[] = [];
    buffer.setDisplayCallback((text) => {
      directMessages.push(text);
    });
    
    // Should pass through without splitting when disabled
    buffer.addTranslation('Should not, be split', 'en', '2024-01-01T00:00:00');
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    expect(directMessages).toHaveLength(1);
    expect(directMessages[0]).toBe('Should not, be split');
  });
  
  test('maintains group atomicity under rapid fire messages', async () => {
    // Simulate rapid incoming messages
    for (let i = 0; i < 5; i++) {
      buffer.addTranslation(`Message ${i} part A, Message ${i} part B`, 'en', `2024-01-01T00:00:0${i}`);
      // Very short delay between messages
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    
    // Wait for all processing
    await new Promise(resolve => setTimeout(resolve, 1200));
    
    // Each message's parts should stay together
    for (let i = 0; i < 5; i++) {
      const baseIndex = i * 2;
      expect(displayedMessages[baseIndex].text).toBe(`Message ${i} part A,`);
      expect(displayedMessages[baseIndex + 1].text).toBe(`Message ${i} part B`);
    }
    
    console.log('Group atomicity test - All messages:', 
      displayedMessages.map((m, idx) => `${idx}: ${m.text}`));
  });
});

// Example usage demonstration
function demonstrateUsage() {
  console.log('\n=== TranslationCommaBuffer Usage Demo ===\n');
  
  const buffer = new TranslationCommaBuffer({
    displayInterval: 2500,
    smartPause: true
  });
  
  // Set display callback
  buffer.setDisplayCallback((text, language, timestamp) => {
    console.log(`[Display] ${new Date().toISOString()} - "${text}" (${language})`);
  });
  
  // Simulate incoming translations
  console.log('Adding: "Peace be upon you, welcome to our mosque, may Allah bless you"');
  buffer.addTranslation(
    'Peace be upon you, welcome to our mosque, may Allah bless you',
    'en',
    new Date().toISOString()
  );
  
  setTimeout(() => {
    console.log('\nAdding: "The prayer will begin soon"');
    buffer.addTranslation(
      'The prayer will begin soon',
      'en',
      new Date().toISOString()
    );
  }, 1000);
  
  setTimeout(() => {
    console.log('\nAdding: "Please stand in rows, fill the gaps, straighten the lines"');
    buffer.addTranslation(
      'Please stand in rows, fill the gaps, straighten the lines',
      'en',
      new Date().toISOString()
    );
  }, 2000);
  
  // Check status
  setTimeout(() => {
    const status = buffer.getStatus();
    console.log('\nBuffer Status:', status);
  }, 3000);
}

// Uncomment to run demo
// demonstrateUsage();


================================================
FILE: src/features/display/utils/TranslationCommaBuffer.ts
================================================
/**
 * TranslationCommaBuffer - A minimalist buffer for splitting long translations
 * and displaying them sequentially without interruption.
 * 
 * Features:
 * - Splits long translations (>100 chars) into two equal parts
 * - Ensures sequential display with no interruptions
 * - Maintains atomic display of split segments (no rogue messages in between)
 * - Configurable display intervals
 * - Non-breaking integration with existing code
 * 
 * Note: Despite the name, this no longer splits on commas but instead splits
 * long messages into equal halves for better visual balance.
 */

interface QueueItem {
  text: string;
  language: string;
  timestamp: string;
  groupId: string; // Groups segments from same original message
  segmentIndex: number; // Position within group
  totalSegments: number; // Total segments in group
}

interface BufferConfig {
  enabled: boolean;           // Toggle buffer on/off
  displayInterval: number;    // Default: 2000ms between segments
  maxQueueSize: number;       // Default: 100 items
  smartPause: boolean;        // Adjust pause based on text length
  minLengthToSplit: number;   // Minimum characters required to split (Default: 100)
}

export class TranslationCommaBuffer {
  private queue: QueueItem[] = [];
  private isProcessing = false;
  private displayCallback: ((text: string, language: string, timestamp: string) => void) | null = null;
  private config: BufferConfig;
  private messageCounter = 0; // For generating unique group IDs
  private currentGroupId: string | null = null; // Track currently displaying group
  private recentMessages = new Set<string>(); // Track recent messages to prevent duplicates
  private MAX_RECENT_MESSAGES = 50;
  
  constructor(config?: Partial<BufferConfig>) {
    this.config = {
      enabled: true,
      displayInterval: 2000,
      maxQueueSize: 100,
      smartPause: true,
      minLengthToSplit: 100,
      ...config
    };
  }

  /**
   * Set the display callback function
   */
  setDisplayCallback(callback: (text: string, language: string, timestamp: string) => void) {
    this.displayCallback = callback;
  }

  /**
   * Main entry point - receives raw translations and processes them
   */
  addTranslation(text: string, language: string, timestamp: string) {
    // If buffer is disabled, pass through directly
    if (!this.config.enabled && this.displayCallback) {
      this.displayCallback(text, language, timestamp);
      return;
    }

    // Check for duplicate message
    const messageKey = `${text}-${timestamp}`;
    if (this.recentMessages.has(messageKey)) {
      console.log(`[TranslationCommaBuffer] Duplicate message ignored: "${text.substring(0, 50)}..."`);
      return;
    }
    
    // Add to recent messages set
    this.recentMessages.add(messageKey);
    
    // Clean up old messages from set
    if (this.recentMessages.size > this.MAX_RECENT_MESSAGES) {
      const firstKey = this.recentMessages.values().next().value;
      this.recentMessages.delete(firstKey);
    }

    // Check queue size limit
    if (this.queue.length >= this.config.maxQueueSize) {
      console.warn('[TranslationCommaBuffer] Queue limit reached, dropping oldest items');
      // Remove oldest non-processing group
      this.removeOldestGroup();
    }

    // Generate unique group ID for this message
    const groupId = `msg-${this.messageCounter++}-${Date.now()}`;
    
    // Check if text should be split (meets length requirement)
    const shouldSplit = text.length > this.config.minLengthToSplit;
    
    if (shouldSplit) {
      // Find the midpoint of the text
      const midpoint = Math.floor(text.length / 2);
      
      // Find the nearest space to the midpoint for a cleaner break
      let splitPoint = midpoint;
      const searchRadius = 15; // Look within ±15 chars of midpoint
      
      // Search for the nearest space
      for (let i = 0; i <= searchRadius; i++) {
        // Check right of midpoint
        if (midpoint + i < text.length && text[midpoint + i] === ' ') {
          splitPoint = midpoint + i;
          break;
        }
        // Check left of midpoint
        if (midpoint - i >= 0 && text[midpoint - i] === ' ') {
          splitPoint = midpoint - i;
          break;
        }
      }
      
      // Split into two equal parts
      const part1 = text.substring(0, splitPoint).trim();
      const part2 = text.substring(splitPoint).trim();
      
      const segments: string[] = [];
      if (part1.length > 0) segments.push(part1);
      if (part2.length > 0) segments.push(part2);
      
      // Queue the segments
      if (segments.length > 0) {
        segments.forEach((segment, index) => {
          this.queue.push({
            text: segment,
            language,
            timestamp,
            groupId,
            segmentIndex: index,
            totalSegments: segments.length
          });
        });
        
        console.log(`[TranslationCommaBuffer] Split message (${text.length} chars) into ${segments.length} equal parts at position ${splitPoint} (group: ${groupId})`);
      }
    } else {
      // Text is too short - queue as single item
      this.queue.push({
        text,
        language,
        timestamp,
        groupId,
        segmentIndex: 0,
        totalSegments: 1
      });
      
      console.log(`[TranslationCommaBuffer] Message not split (${text.length} chars < ${this.config.minLengthToSplit}). Queued as single item.`);
    }
    
    // Start processing if not already running
    this.processQueue();
  }

  /**
   * Process queued items sequentially with atomic group guarantee
   */
  private async processQueue() {
    // Prevent concurrent processing
    if (this.isProcessing || this.queue.length === 0 || !this.displayCallback) {
      return;
    }
    
    this.isProcessing = true;
    
    try {
      while (this.queue.length > 0) {
        const item = this.queue[0]; // Peek at first item
        
        // If we're starting a new group, we need to display all segments atomically
        if (this.currentGroupId !== item.groupId) {
          this.currentGroupId = item.groupId;
          
          // Check if there are more items in queue BEFORE extracting
          const hasMoreItemsAfterThisGroup = this.queue.filter(q => q.groupId !== item.groupId).length > 0;
          
          // Find all segments of this group
          const groupSegments = this.extractGroup(item.groupId);
          
          // Display all segments of this group sequentially
          for (let i = 0; i < groupSegments.length; i++) {
            const segment = groupSegments[i];
            
            console.log(`[TranslationCommaBuffer] Displaying segment ${i + 1}/${groupSegments.length}: "${segment.text}"`);
            
            // Display the segment
            this.displayCallback(segment.text, segment.language, segment.timestamp);
            
            // Always wait after displaying a segment
            const delay = this.getDisplayDuration(segment.text);
            const isLastSegment = i === groupSegments.length - 1;
            
            // Wait after every segment EXCEPT:
            // - The last segment when there are NO more messages (to avoid unnecessary final delay)
            if (!isLastSegment || hasMoreItemsAfterThisGroup) {
              if (isLastSegment) {
                console.log(`[TranslationCommaBuffer] Last segment displayed. Waiting ${delay}ms before next message`);
              } else {
                console.log(`[TranslationCommaBuffer] Waiting ${delay}ms before next segment`);
              }
              await this.sleep(delay);
            } else {
              // Last segment with no more messages - skip wait
              console.log(`[TranslationCommaBuffer] Last segment with no more messages. Not waiting.`);
            }
          }
          
          // Group complete, reset
          this.currentGroupId = null;
        }
      }
    } catch (error) {
      console.error('[TranslationCommaBuffer] Error processing queue:', error);
    } finally {
      this.isProcessing = false;
      
      // Check if new items were added while processing
      if (this.queue.length > 0) {
        // Small delay before restarting to prevent tight loops
        setTimeout(() => this.processQueue(), 100);
      }
    }
  }

  /**
   * Extract all segments belonging to a group and remove them from queue
   */
  private extractGroup(groupId: string): QueueItem[] {
    const groupSegments: QueueItem[] = [];
    
    // Extract all segments with this groupId
    this.queue = this.queue.filter(item => {
      if (item.groupId === groupId) {
        groupSegments.push(item);
        return false; // Remove from queue
      }
      return true; // Keep in queue
    });
    
    // Sort by segment index to ensure correct order
    groupSegments.sort((a, b) => a.segmentIndex - b.segmentIndex);
    
    return groupSegments;
  }

  /**
   * Remove the oldest complete group from queue (for overflow management)
   */
  private removeOldestGroup() {
    if (this.queue.length === 0) return;
    
    // Find the first group that's not currently being processed
    const firstItem = this.queue.find(item => item.groupId !== this.currentGroupId);
    if (firstItem) {
      const removedCount = this.queue.filter(item => item.groupId === firstItem.groupId).length;
      this.queue = this.queue.filter(item => item.groupId !== firstItem.groupId);
      console.log(`[TranslationCommaBuffer] Removed ${removedCount} items from group ${firstItem.groupId}`);
    }
  }

  /**
   * Calculate display duration based on text characteristics
   */
  private getDisplayDuration(text: string): number {
    if (!this.config.smartPause) {
      return this.config.displayInterval;
    }
    
    let duration = this.config.displayInterval;
    
    // Adjust based on text length
    if (text.length > 100) {
      duration *= 1.3; // 30% longer for long text
    } else if (text.length > 50) {
      duration *= 1.15; // 15% longer for medium text
    }
    
    // Adjust for questions
    if (text.endsWith('?')) {
      duration *= 1.2; // 20% longer for questions
    }
    
    // Adjust for exclamations or important statements
    if (text.endsWith('!')) {
      duration *= 1.1; // 10% longer for exclamations
    }
    
    return Math.round(duration);
  }

  /**
   * Sleep utility
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Clear the queue (useful for cleanup or reset)
   */
  clearQueue() {
    this.queue = [];
    this.currentGroupId = null;
    this.recentMessages.clear();
    console.log('[TranslationCommaBuffer] Queue and duplicate tracking cleared');
  }

  /**
   * Get current queue status
   */
  getStatus() {
    return {
      queueLength: this.queue.length,
      isProcessing: this.isProcessing,
      currentGroupId: this.currentGroupId,
      enabled: this.config.enabled
    };
  }

  /**
   * Update configuration
   */
  updateConfig(config: Partial<BufferConfig>) {
    this.config = { ...this.config, ...config };
    console.log('[TranslationCommaBuffer] Config updated:', this.config);
  }

  /**
   * Enable/disable the buffer
   */
  setEnabled(enabled: boolean) {
    this.config.enabled = enabled;
    if (!enabled) {
      this.clearQueue();
    }
  }
}

// Export a factory function for easy creation
export const createTranslationBuffer = (config?: Partial<BufferConfig>) => {
  return new TranslationCommaBuffer(config);
};


================================================
FILE: src/features/livekit/components/README.md
================================================
# LiveKit Styled Components

Modern, clean styled components for LiveKit React SDK that maintain all existing functionality while providing a superior visual experience.

## Components

### StyledHostControls
The main component that provides a complete host interface with modern styling.

```tsx
import { StyledHostControls } from '@/components/livekit-styled';

<StyledHostControls
  token={token}
  serverUrl={serverUrl}
  loading={loading}
  error={error}
  roomName={room.Livekit_room_name}
  roomTitle={room.Title}
  onGenerateToken={generateToken}
  onDisconnect={handleDisconnect}
/>
```

### StyledMediaDeviceMenu
A styled version of the MediaDeviceMenu with variants and icon support.

```tsx
import { StyledMediaDeviceMenu } from '@/components/livekit-styled';

<StyledMediaDeviceMenu 
  kind="audioinput"
  variant="default" // 'default' | 'compact' | 'minimal'
  showIcon={true}
/>
```

### StyledTrackToggle
Enhanced mic/camera toggle with multiple variants and sizes.

```tsx
import { StyledTrackToggle } from '@/components/livekit-styled';

<StyledTrackToggle 
  source={Track.Source.Microphone}
  variant="default" // 'default' | 'ghost' | 'minimal' | 'destructive'
  size="default" // 'default' | 'sm' | 'lg' | 'icon'
  showLabel={true}
  customLabel="Mic"
/>
```

### StyledDisconnectButton
A styled disconnect button with icon options and variants.

```tsx
import { StyledDisconnectButton } from '@/components/livekit-styled';

<StyledDisconnectButton 
  variant="destructive" // 'default' | 'destructive' | 'outline' | 'ghost'
  size="default"
  icon="phone" // 'phone' | 'logout' | 'x'
  customLabel="End Call"
/>
```

### StyledParticipantInfo
Displays participant count and active microphones with different layouts.

```tsx
import { StyledParticipantInfo } from '@/components/livekit-styled';

<StyledParticipantInfo 
  variant="compact" // 'default' | 'compact' | 'detailed'
  showLabels={false}
/>
```

## Features

- 🎨 Modern, clean design with glassmorphism effects
- 🌗 Full dark mode support
- 📱 Responsive design for all screen sizes
- 🎭 Multiple variants for different use cases
- 🔧 Fully customizable with Tailwind classes
- ♿ Maintains all accessibility features from LiveKit
- 🎯 Zero breaking changes - drop-in replacement
- 🚀 Smooth animations with Framer Motion

## Integration

Replace your existing LiveKit components with the styled versions:

```tsx
// Before
import { LiveKitHostInterface } from '@/components/LiveKitHostInterface';

// After
import { LiveKitHostInterface } from '@/components/LiveKitHostInterface';
// The component now uses StyledHostControls internally
```

## Customization

All components accept standard className props for further customization:

```tsx
<StyledTrackToggle 
  source={Track.Source.Microphone}
  className="custom-class"
/>
```

## CSS Variables

The components use your existing CSS variables from the theme system:
- `--primary`: Main brand color
- `--card`: Card background
- `--border`: Border colors
- `--destructive`: Error/disconnect states
- `--success`: Active/connected states


================================================
FILE: src/features/livekit/components/BroadcastReceiver.tsx
================================================
import { useEffect, useRef, useCallback } from 'react';
import { useBroadcastChannel } from '@/hooks/useBroadcastChannel';
import { ConnectionState } from '@/lib/broadcastChannelManager';

interface BroadcastMessage {
  type: 'transcription' | 'translation';
  room_id: number;
  mosque_id: number;
  data: {
    text: string;
    language: string;
    timestamp: string;
    msg_id?: string;
    // New sentence tracking fields
    sentence_id?: string;
    is_complete?: boolean;
    is_fragment?: boolean;
  };
}

interface BroadcastReceiverProps {
  roomId: number;
  mosqueId: number;
  onTranscription?: (text: string, language: string, timestamp: string, messageData?: BroadcastMessage['data']) => void;
  onTranslation?: (text: string, language: string, timestamp: string, messageData?: BroadcastMessage['data']) => void;
  enabled?: boolean;
  isKioskMode?: boolean;
  onConnectionStateChange?: (state: ConnectionState, retryCount: number) => void;
}

// Re-export ConnectionState for backward compatibility
export { ConnectionState } from '@/lib/broadcastChannelManager';

export const BroadcastReceiver = ({
  roomId,
  mosqueId,
  onTranscription,
  onTranslation,
  enabled = true,
  isKioskMode = false,
  onConnectionStateChange
}: BroadcastReceiverProps) => {
  const channelName = `live-transcription-${roomId}-${mosqueId}`;
  const listenerId = `receiver-${roomId}-${mosqueId}`;
  const retryCountRef = useRef(0);
  
  // Store all callbacks in a single ref to update atomically
  const callbacksRef = useRef({
    onTranscription,
    onTranslation,
    onConnectionStateChange
  });
  
  // Update callbacks ref when they change
  useEffect(() => {
    callbacksRef.current = {
      onTranscription,
      onTranslation,
      onConnectionStateChange
    };
  }, [onTranscription, onTranslation, onConnectionStateChange]);

  // Stable connection state handler
  const handleConnectionStateChange = useCallback((state: ConnectionState) => {
    // Track retry count for kiosk mode
    if (state === ConnectionState.RECONNECTING) {
      retryCountRef.current++;
    } else if (state === ConnectionState.CONNECTED) {
      retryCountRef.current = 0;
    }

    // Handle kiosk mode page refresh
    if (isKioskMode && retryCountRef.current >= 10) {
      setTimeout(() => {
        window.location.reload();
      }, 1000);
      return;
    }

    // Notify parent component
    callbacksRef.current.onConnectionStateChange?.(state, retryCountRef.current);
  }, [isKioskMode]);

  // Use the new broadcast channel hook
  const { subscribe } = useBroadcastChannel(
    channelName,
    listenerId,
    {
      enabled,
      onConnectionStateChange: handleConnectionStateChange
    }
  );

  // Stable message handlers
  const handleTranscriptionMessage = useCallback((message: BroadcastMessage) => {
    if (message.room_id === roomId && message.mosque_id === mosqueId) {
      callbacksRef.current.onTranscription?.(
        message.data.text,
        message.data.language,
        message.data.timestamp,
        message.data
      );
    }
  }, [roomId, mosqueId]);

  const handleTranslationMessage = useCallback((message: BroadcastMessage) => {
    if (message.room_id === roomId && message.mosque_id === mosqueId) {
      callbacksRef.current.onTranslation?.(
        message.data.text,
        message.data.language,
        message.data.timestamp,
        message.data
      );
    }
  }, [roomId, mosqueId]);

  // Single effect to manage subscriptions
  useEffect(() => {
    if (!enabled) return;

    // Subscribe to events
    const cleanupTranscription = subscribe('transcription', handleTranscriptionMessage);
    const cleanupTranslation = subscribe('translation', handleTranslationMessage);

    // Return cleanup function
    return () => {
      cleanupTranscription();
      cleanupTranslation();
    };
  }, [enabled, subscribe, handleTranscriptionMessage, handleTranslationMessage]);

  // Return null as this is a headless component
  return null;
};


================================================
FILE: src/features/livekit/components/EnhancedMediaDeviceMenu.tsx
================================================
import React, { useState, useEffect } from 'react';
import { useMediaDeviceSelect, useMediaDevices } from '@livekit/components-react';
import { Settings2, ChevronDown, Mic, Check } from 'lucide-react';
import { cn } from '@/lib/utils';
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { motion, AnimatePresence } from 'framer-motion';

interface EnhancedMediaDeviceMenuProps {
  kind: MediaDeviceKind;
  className?: string;
  variant?: 'default' | 'compact';
}

export const EnhancedMediaDeviceMenu: React.FC<EnhancedMediaDeviceMenuProps> = ({
  kind,
  className,
  variant = 'default'
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [nativeDevices, setNativeDevices] = useState<MediaDeviceInfo[]>([]);
  
  // Still use LiveKit hooks for integration
  const livekitDevices = useMediaDevices({ kind });
  const { activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({ kind });
  
  // Fetch devices natively to get proper labels
  useEffect(() => {
    const fetchDevices = async () => {
      try {
        // First request permission if needed
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop());
        
        // Then enumerate devices
        const allDevices = await navigator.mediaDevices.enumerateDevices();
        const audioDevices = allDevices.filter(d => d.kind === kind);
        setNativeDevices(audioDevices);
        } catch (err) {
        }
    };
    
    fetchDevices();
    
    // Listen for device changes
    navigator.mediaDevices.addEventListener('devicechange', fetchDevices);
    return () => {
      navigator.mediaDevices.removeEventListener('devicechange', fetchDevices);
    };
  }, [kind]);
  
  // Use native devices if they have labels, otherwise fall back to LiveKit devices
  const devices = nativeDevices.length > 0 && nativeDevices[0].label ? nativeDevices : livekitDevices;
  
  // Debug logging
  useEffect(() => {
    // Debug logging removed
  }, [devices, activeDeviceId, nativeDevices]);
  
  // Find the currently active device
  const activeDevice = devices.find(device => device.deviceId === activeDeviceId) || 
                      devices.find(device => device.deviceId === 'default') ||
                      devices[0];
  
  // Get display name from active device
  const displayName = activeDevice?.label || 'Select microphone';
  
  // Additional debug
  useEffect(() => {
    }, [displayName, activeDevice]);
  
  // Extract actual device name from label
  const getCleanDeviceName = (label: string) => {
    if (!label || label.trim() === '') {
      return 'Unknown Device';
    }
    
    // Extract text from within parentheses if present
    const parenthesesMatch = label.match(/\(([^)]+)\)/);
    if (parenthesesMatch && parenthesesMatch[1]) {
      return parenthesesMatch[1].trim();
    }
    
    // If no parentheses, try to clean up common prefixes
    const cleaned = label
      .replace(/^(Default - |Communications - |Microphone Array - )/, '')
      .replace(/^Microfoonmatrix - /, '') // Remove Dutch prefix
      .replace(/^Microphone - /, '')
      .replace(/\s+/g, ' ')
      .trim();
    
    return cleaned || label; // Fallback to original if cleaning results in empty string
  };

  // Handle dropdown open/close
  const handleDropdownOpen = (open: boolean) => {
    setIsOpen(open);
  };
  
  // Auto-select first device if none selected
  useEffect(() => {
    if (!activeDeviceId && devices.length > 0) {
      setActiveMediaDevice(devices[0].deviceId);
    }
  }, [devices, activeDeviceId, setActiveMediaDevice]);

  const handleDeviceSelect = (deviceId: string) => {
    setActiveMediaDevice(deviceId);
    setIsOpen(false);
  };

  const buttonStyles = cn(
    "relative inline-flex items-center justify-between gap-2 w-full",
    "bg-background/80 backdrop-blur-sm",
    "border border-border/50",
    "rounded-lg",
    "text-sm font-medium",
    "transition-all duration-200",
    "hover:bg-card/50 hover:border-border",
    "focus:outline-none focus:ring-2 focus:ring-primary/50 focus:ring-offset-2 focus:ring-offset-background",
    variant === 'compact' ? "h-10 px-2 sm:px-3 min-w-[120px] sm:min-w-[180px]" : "h-10 px-3 sm:px-4 min-w-[160px] sm:min-w-[240px]",
    className
  );

  return (
    <DropdownMenu.Root open={isOpen} onOpenChange={handleDropdownOpen}>
      <DropdownMenu.Trigger asChild>
        <button className={buttonStyles}>
          <div className="flex items-center gap-1 sm:gap-2 flex-1 text-left truncate">
            <Mic className="h-4 w-4 text-muted-foreground shrink-0" />
            <span className="truncate text-foreground text-xs sm:text-sm">
              {devices.length === 0 ? 'Loading...' : getCleanDeviceName(displayName)}
            </span>
          </div>
          <ChevronDown className={cn(
            "h-3 w-3 sm:h-4 sm:w-4 text-muted-foreground transition-transform duration-200",
            isOpen && "rotate-180"
          )} />
        </button>
      </DropdownMenu.Trigger>

      <AnimatePresence>
        {isOpen && (
          <DropdownMenu.Portal forceMount>
            <DropdownMenu.Content asChild>
              <motion.div
                className={cn(
                  "z-50 min-w-[200px] sm:min-w-[240px] max-w-[280px] sm:max-w-[320px]",
                  "bg-background/95 backdrop-blur-xl",
                  "border border-border/50 rounded-lg shadow-xl",
                  "p-1 mt-2",
                  "text-foreground", // Ensure text color is explicitly set
                  "max-h-[60vh] overflow-y-auto" // Add max height and scroll for mobile
                )}
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.15 }}
                align="start"
                sideOffset={5}
              >
                {devices.length === 0 ? (
                  <div className="px-3 py-2 text-sm text-muted-foreground/90 text-center">
                    No microphones found
                  </div>
                ) : (
                  devices.map((device, index) => {
                    const isActive = device.deviceId === activeDeviceId;
                    const cleanName = getCleanDeviceName(device.label || `Device ${index + 1}`);
                    
                    return (
                      <DropdownMenu.Item key={device.deviceId} asChild>
                        <motion.button
                          className={cn(
                            "flex items-center gap-2 w-full px-3 py-2 rounded-md",
                            "text-sm font-medium transition-colors",
                            "text-foreground/90", // Explicit text color for all items
                            "hover:bg-accent hover:text-accent-foreground",
                            "focus:bg-accent focus:text-accent-foreground focus:outline-none",
                            isActive && "bg-primary/10 text-primary hover:text-primary"
                          )}
                          onClick={() => handleDeviceSelect(device.deviceId)}
                          whileHover={{ x: 2 }}
                          whileTap={{ scale: 0.98 }}
                        >
                          <div className="flex items-center gap-2 flex-1">
                            <div className={cn(
                              "w-2 h-2 rounded-full",
                              isActive ? "bg-primary animate-pulse" : "bg-muted-foreground/30"
                            )} />
                            <span className="truncate text-inherit">{cleanName}</span>
                          </div>
                          {isActive && (
                            <Check className="h-4 w-4 text-primary shrink-0" />
                          )}
                        </motion.button>
                      </DropdownMenu.Item>
                    );
                  })
                )}
                
                {/* Device info section */}
                <div className="mt-1 pt-1 border-t border-border/30">
                  <div className="px-3 py-2 text-xs text-muted-foreground/90">
                    <div className="flex items-center gap-1">
                      <Settings2 className="h-3 w-3" />
                      <span className="text-inherit">{devices.length} device{devices.length !== 1 ? 's' : ''} available</span>
                    </div>
                  </div>
                </div>
              </motion.div>
            </DropdownMenu.Content>
          </DropdownMenu.Portal>
        )}
      </AnimatePresence>
    </DropdownMenu.Root>
  );
};


================================================
FILE: src/features/livekit/components/index.ts
================================================
export { StyledMediaDeviceMenu } from './StyledMediaDeviceMenu';
export { StyledTrackToggle } from './StyledTrackToggle';
export { StyledMicToggle } from './StyledMicToggle';
export { EnhancedMediaDeviceMenu } from './EnhancedMediaDeviceMenu';
export { StyledDisconnectButton } from './StyledDisconnectButton';
export { StyledParticipantInfo } from './StyledParticipantInfo';
export { StyledHostControls } from './StyledHostControls';


================================================
FILE: src/features/livekit/components/LiveKitCleanupHandler.tsx
================================================
import { useEffect } from 'react';
import { useRoomContext } from '@livekit/components-react';

interface LiveKitCleanupHandlerProps {
  sessionId: string | null;
  roomId: number;
  onCleanupRequested?: () => void;
}

/**
 * Component that runs inside LiveKitRoom context to handle cleanup signaling
 */
export const LiveKitCleanupHandler = ({ 
  sessionId, 
  roomId, 
  onCleanupRequested 
}: LiveKitCleanupHandlerProps) => {
  const room = useRoomContext();

  // Function to send cleanup signal to backend via LiveKit RPC
  const signalBackendCleanup = async (reason: string) => {
    if (!room || !sessionId) return;

    try {
      const payload = JSON.stringify({
        session_id: sessionId,
        room_id: roomId,
        reason: reason
      });

      // Use LiveKit RPC to signal the backend
      const response = await room.localParticipant.performRpc({
        destinationIdentity: 'agent', // The backend agent identity
        method: 'request/cleanup',
        payload: payload
      });

      const result = JSON.parse(response);
      if (result.success) {
        onCleanupRequested?.();
      }
    } catch (error) {
      }
  };

  // Expose cleanup function globally for other components to use
  useEffect(() => {
    if (!room || !sessionId) return;

    // Store cleanup function on window for emergency use
    (window as any).__liveKitCleanup = () => signalBackendCleanup('emergency');

    return () => {
      delete (window as any).__liveKitCleanup;
    };
  }, [room, sessionId]);

  return null; // This is a utility component, no UI
};

// Export helper to trigger cleanup from outside LiveKitRoom context
export const triggerLiveKitCleanup = async (reason: string = 'user_requested') => {
  const cleanupFn = (window as any).__liveKitCleanup;
  if (cleanupFn) {
    await cleanupFn();
  } else {
    }
};


================================================
FILE: src/features/livekit/components/LiveMonitor.tsx
================================================
import { useState, useEffect, useRef, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { Switch } from '@/components/ui/switch';
import { 
  Play, 
  Pause, 
  Users, 
  Wifi, 
  WifiOff, 
  Activity,
  MessageSquare,
  Clock,
  AlertCircle,
  Monitor,
  ExternalLink,
  Circle,
  Mic,
  MicOff,
  Volume2,
  Settings,
  LogOut,
  Loader2,
  ChevronDown,
  ChevronUp,
  Type,
  Layers,
  Maximize,
  Minimize,
  Eye,
  EyeOff,
  ArrowDown,
  Sun,
  Moon
} from 'lucide-react';
// WebSocket removed - using only Supabase Broadcast
import { Tables } from '@/integrations/supabase/types';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { BroadcastReceiver } from '@/features/livekit/components/BroadcastReceiver';
import TypewriterView from '@/features/display/components/TypewriterView';
import { HostControlFooterV3 as HostControlFooter } from '@/components/HostControlFooterV3';
import { AnimatePresence } from 'framer-motion';
import { cleanupSession } from '@/utils/sessionCleanupCoordinator';
import { useSessionCleanup } from '@/hooks/useSessionCleanup';
import { useTheme } from 'next-themes';
import { format } from 'date-fns';
// LiveKit imports for integrated host interface
import { 
  LiveKitRoom, 
  RoomAudioRenderer, 
  DisconnectButton,
  useParticipants,
  useTracks,
  MediaDeviceMenu,
  TrackToggle,
  useRoomContext
} from '@livekit/components-react';
import '@livekit/components-styles';
import { Track, RpcInvocationData } from 'livekit-client';

type Room = Tables<'rooms'>;

interface LiveMonitorProps {
  room: Room;
  mosque_id: number;
  websocketUrl?: string;
  onStopMonitoring?: () => void;
  isConversationMode?: boolean;
}

// Integrated ParticipantInfo component for host interface
const ParticipantInfo = () => {
  const participants = useParticipants();
  const tracks = useTracks([Track.Source.Microphone]);
  const activeMics = tracks.filter(track => track.publication.isMuted === false).length;

  return (
    <div className="flex items-center gap-4 py-1">
      <div className="flex items-center gap-1 text-sm">
        <Users className="h-4 w-4 text-primary" />
        <span className="font-medium">{participants.length}</span>
      </div>
      <div className="flex items-center gap-1 text-sm">
        <Volume2 className="h-4 w-4 text-green-600" />
        <span className="font-medium">{activeMics}</span>
      </div>
    </div>
  );
};

// Language mapping utility
const getLanguageDisplayName = (code: string): string => {
  const languageMap: Record<string, string> = {
    'ar': 'Arabic',
    'en': 'English', 
    'nl': 'Dutch',
    'fr': 'French',
    'de': 'German',
    'es': 'Spanish',
    'it': 'Italian',
    'pt': 'Portuguese',
    'ru': 'Russian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'hi': 'Hindi',
    'ur': 'Urdu',
    'tr': 'Turkish'
  };
  
  return languageMap[code?.toLowerCase()] || code?.toUpperCase() || 'Unknown';
};

// RTL language detection
const isRTLLanguage = (code: string): boolean => {
  const rtlLanguages = ['ar', 'ur', 'fa', 'he'];
  return rtlLanguages.includes(code?.toLowerCase());
};

const LiveMonitor = ({ room, mosque_id, websocketUrl = 'wss://bpsahvbdlkzemwjdgxmq.functions.supabase.co/functions/v1/websocket-bridge', onStopMonitoring, isConversationMode = false }: LiveMonitorProps) => {
  const [monitorSessionId] = useState(`monitor-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`);
  const [isMonitoring, setIsMonitoring] = useState(() => {
    // Restore monitoring state from sessionStorage
    return sessionStorage.getItem(`monitoring-${room.id}`) === 'true';
  });
  const [viewMode, setViewMode] = useState<'card' | 'typewriter'>('card');
  // Typewriter view state persistence
  const [typewriterTranscriptionDisplay, setTypewriterTranscriptionDisplay] = useState('');
  const [typewriterTranslationDisplay, setTypewriterTranslationDisplay] = useState('');
  const [hasViewedTypewriter, setHasViewedTypewriter] = useState(false);
  const [participantCount, setParticipantCount] = useState(0);
  const [translationActivity, setTranslationActivity] = useState<any[]>([]);
  const [sentences, setSentences] = useState<Array<{
    id: string;
    transcription: string;
    translation: string;
    isComplete: boolean;
    timestamp: string;
  }>>([]);
  const [currentSentence, setCurrentSentence] = useState<{
    id: string;
    transcription: string;
    timestamp: string;
    isComplete?: boolean;
  } | null>(null);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(() => {
    // Restore session ID from sessionStorage
    if (!room?.id) return null;
    return sessionStorage.getItem(`session-${room.id}`) || null;
  });
  const [transcriptCount, setTranscriptCount] = useState(() => {
    // Restore transcript count from sessionStorage
    if (!room?.id) return 0;
    const saved = sessionStorage.getItem(`transcripts-${room.id}`);
    return saved ? parseInt(saved, 10) : 0;
  });
  
  // LiveKit host interface state
  const [token, setToken] = useState<string | null>(null);
  const [serverUrl, setServerUrl] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);
  
  // Display control states
  const [showTranscription, setShowTranscription] = useState(true);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [invertedStacking, setInvertedStacking] = useState(false);
  const [compactFont, setCompactFont] = useState(false);
  
  // Animation state management
  const animatedCardsRef = useRef<Set<string>>(new Set());
  const translationStatesRef = useRef<Map<string, boolean>>(new Map());
  const completionStatesRef = useRef<Map<string, boolean>>(new Map());
  
  const { toast } = useToast();
  const { t } = useTranslation();
  const { theme, setTheme } = useTheme();
  const isUnloadingRef = useRef(false);
  const previousRoomIdRef = useRef(room.id);
  
  // Use session cleanup hook - must be called unconditionally
  const { performCleanup = () => {} } = useSessionCleanup({
    sessionId: currentSessionId,
    roomId: room?.id || 0,
    isActive: isMonitoring,
    room: room,
    onCleanup: () => {
      setIsMonitoring(false);
      setCurrentSessionId(null);
    }
  }) || {};

  // Track room changes to prevent unnecessary disruptions
  useEffect(() => {
    // Only react to actual room ID changes, not just prop updates
    if (previousRoomIdRef.current !== room.id) {
      previousRoomIdRef.current = room.id;
      
      // If monitoring a different room, we need to reset
      // This will be handled by the cleanup in other effects
    }
  }, [room.id]); // Only depend on room.id, not the entire room object

  // Broadcast when monitor opens/closes and respond to status requests
  useEffect(() => {
    const channel = supabase.channel('live-monitor-status');
    
    // Function to broadcast current status
    const broadcastStatus = () => {
      channel.send({
        type: 'broadcast',
        event: 'monitor-opened',
        payload: {
          sessionId: monitorSessionId,
          roomId: room.id,
          roomName: room.Title || `Room ${room.id}`,
          timestamp: Date.now()
        }
      });
    };
    
    // Subscribe the status channel first to ensure broadcasts work
    channel.subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        // Broadcast immediately when subscribed
        broadcastStatus();
      }
    });
    
    // Listen for status requests from remote page
    const commandChannel = supabase.channel('live-monitor-requests');
    commandChannel
      .on('broadcast', { event: 'request-status' }, () => {
        console.log('[LiveMonitor] Received status request, broadcasting...');
        // When remote page requests status, broadcast it
        broadcastStatus();
      })
      .subscribe();
    
    // Cleanup: broadcast monitor closed
    return () => {
      commandChannel.unsubscribe();
      channel.send({
        type: 'broadcast',
        event: 'monitor-closed',
        payload: {
          roomId: room.id
        }
      });
      channel.unsubscribe();
    };
  }, [room.id, room.Title, monitorSessionId]);

  // Remove WebSocket - using only Supabase Broadcast

  // Database subscription for logging/persistence only (no UI updates)
  useEffect(() => {
    if (!currentSessionId || !isMonitoring) return;

    const channel = supabase
      .channel('transcripts-logging')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'transcripts',
        filter: `session_id=eq.${currentSessionId}`
      }, (payload) => {
        // Only increment transcript count for logging purposes
        setTranscriptCount(prev => {
          const newCount = prev + 1;
          return newCount;
          });
      })
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [currentSessionId, isMonitoring]);

  // Remove WebSocket participant count handling

  // Browser event protection - only handle beforeunload, no visibility handlers
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (isMonitoring && !isUnloadingRef.current) {
        e.preventDefault();
        e.returnValue = t('dialogs.browserWarning');
        return t('dialogs.browserWarning');
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [isMonitoring]);

  // Persist state to sessionStorage
  useEffect(() => {
    sessionStorage.setItem(`monitoring-${room.id}`, isMonitoring.toString());
  }, [isMonitoring, room.id]);

  useEffect(() => {
    if (currentSessionId) {
      sessionStorage.setItem(`session-${room.id}`, currentSessionId);
    } else {
      sessionStorage.removeItem(`session-${room.id}`);
    }
  }, [currentSessionId, room.id]);

  useEffect(() => {
    sessionStorage.setItem(`transcripts-${room.id}`, transcriptCount.toString());
  }, [transcriptCount, room.id]);

  // Remove saveTranscriptToDatabase - not needed with direct DB subscription

  const startRecordingSession = async (retryCount = 0): Promise<string | null> => {
    const maxRetries = 3;
    const retryDelays = [500, 1000, 2000]; // Exponential backoff
    
    console.log(`[LiveMonitor] Starting recording session for room ${room.id} (${room.Title}), attempt ${retryCount + 1}/${maxRetries + 1}`);
    
    try {
      // Validate room data first
      if (!room.id) {
        toast({
          title: t('common.error'),
          description: 'Invalid room data',
          variant: 'destructive'
        });
        return null;
      }
      
      // First cleanup any existing sessions for this room
      try {
        console.log(`[LiveMonitor] Checking for existing active sessions for room ${room.id}`);
        // Use the cleanup function to end any active sessions
        const { data: existingSessions } = await supabase
          .from('room_sessions')
          .select('id')
          .eq('room_id', room.id)
          .eq('status', 'active');
          
        if (existingSessions && existingSessions.length > 0) {
          console.log(`[LiveMonitor] Found ${existingSessions.length} active sessions, cleaning up...`);
          // Clean up existing sessions
          for (const session of existingSessions) {
            await cleanupSession({
              sessionId: session.id,
              roomId: room.id,
              source: 'user',
              skipTranscriptWait: true // Skip waiting when cleaning up before new session
            });
          }
          console.log(`[LiveMonitor] Cleanup completed`);
        } else {
          console.log(`[LiveMonitor] No existing active sessions found`);
        }
      } catch (cleanupError) {
        console.warn(`[LiveMonitor] Cleanup error (continuing anyway):`, cleanupError);
        // Continue anyway - cleanup is best effort
      }
      
      // Now create a new session
      console.log(`[LiveMonitor] Creating new session for room ${room.id}`);
      // Create session manually
      const { data, error } = await supabase
        .from('room_sessions')
        .insert({
          room_id: room.id,
          mosque_id: mosque_id,
          status: 'active',
          logging_enabled: true
        })
        .select()
        .single();

      if (error) {
        console.error(`[LiveMonitor] Session creation error:`, error);
        // Check if it's a unique constraint violation
        if (error.code === '23505' && retryCount < maxRetries) {
          
          // Show user-friendly message
          if (retryCount === 0) {
            toast({
              title: t('common.preparing'),
              description: "Preparing room, please wait...",
            });
          }
          
          // Wait with exponential backoff
          await new Promise(resolve => setTimeout(resolve, retryDelays[retryCount]));
          
          // Retry
          return startRecordingSession(retryCount + 1);
        }
        
        toast({
          title: t('common.error'),
          description: retryCount >= maxRetries 
            ? "Room is busy, please try again in a moment"
            : t('technical.errors.createFailed'),
          variant: "destructive"
        });
        return null;
      }

      console.log(`[LiveMonitor] Session created successfully: ${data.id}`);
      return data.id;
    } catch (err) {
      return null;
    }
  };

  const endRecordingSession = async () => {
    if (!currentSessionId) {
      return;
    }

    // Use the consolidated cleanup coordinator
    const result = await cleanupSession({
      sessionId: currentSessionId,
      roomId: room.id,
      source: 'user',
      room: room,
      skipTranscriptWait: true // Skip waiting for user-initiated stop to prevent UI lag
    });

    if (!result.success) {
      toast({
        title: t('toast.warning.dataLoss'),
        description: "Session ended but room status may need manual cleanup",
        variant: "destructive"
      });
    } else {
      // Double-check room status update
      const { error: roomUpdateError } = await supabase
        .from('rooms')
        .update({ 
          status: 'empty',
          updated_at: new Date().toISOString()
        })
        .eq('id', room.id);
        
      if (roomUpdateError) {
        } else {
        }
    }
  };

  // LiveKit token generation
  const generateToken = useCallback(async (sessionId?: string) => {
    console.log(`[LiveMonitor] Generating LiveKit token for room ${room.id} (${room.Title}), LiveKit room name: ${room.Livekit_room_name}`);
    
    if (!room.Livekit_room_name) {
      setError('Room not configured for LiveKit');
      console.error(`[LiveMonitor] Room ${room.id} has no LiveKit room name configured`);
      return;
    }

    setLoading(true);
    setIsConnecting(true);
    setError(null);

    try {
      // Check if we're in conversation mode and adjust participant name accordingly
      const isConversationMode = room.Title?.includes('Primary Speaker') || room.Title?.includes('Secondary Speaker');
      const participantName = isConversationMode 
        ? (room.Title?.includes('Primary') ? 'Host_Primary' : 'Host_Secondary')
        : 'Host';
      
      const tokenPayload = {
        room_id: room.id,
        participant_name: participantName,
        permissions: 'speaker',
        session_id: sessionId || currentSessionId
      };
      console.log(`[LiveMonitor] Token request payload:`, tokenPayload);
      
      const { data, error: tokenError } = await supabase.functions.invoke('generate-livekit-token', {
        body: tokenPayload
      });

      if (tokenError) {
        console.error(`[LiveMonitor] Token generation error:`, tokenError);
        throw tokenError;
      }

      if (!data || !data.token) {
        console.error(`[LiveMonitor] Invalid token response:`, data);
        throw new Error('Failed to get valid token from server');
      }

      console.log(`[LiveMonitor] Token generated successfully, server URL: ${data.server_url}`);
      setToken(data.token);
      
      if (data.server_url) {
        setServerUrl(data.server_url);
      }
      
      toast({
        title: "Connected to room",
        description: `Joined ${room.Title} as host`,
      });

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to generate token';
      console.error(`[LiveMonitor] Token generation failed:`, err);
      setError(errorMessage);
      
      toast({
        title: "Connection failed",
        description: "Could not connect to LiveKit room",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
      setIsConnecting(false);
    }
  }, [room.id, room.Title, room.Livekit_room_name, toast, t]);

  const handleGoLive = async () => {
    const sessionId = await startRecordingSession();
    if (!sessionId) return;
    
    setCurrentSessionId(sessionId);
    setIsMonitoring(true);
    setTranslationActivity([]);
    setSentences([]);
    setCurrentSentence(null);
    
    // Auto-generate token if room is configured
    if (room.Livekit_room_name) {
      // Pass sessionId directly to avoid race condition with state update
      await generateToken(sessionId);
    }
    
    toast({
      title: t('mosqueAdmin.monitor.goLive'),
      description: "LiveKit host interface is now active",
    });
  };

  // Listen for commands from remote control
  useEffect(() => {
    const channel = supabase.channel('live-monitor-commands');
    
    channel
      .on('broadcast', { event: 'go-live' }, (payload) => {
        const command = payload.payload;
        // Check if this command is for our session
        if (command.sessionId === monitorSessionId && command.roomId === room.id) {
          // Trigger go live if not already monitoring
          if (!isMonitoring) {
            handleGoLive();
          }
        }
      })
      .on('broadcast', { event: 'stop-monitoring' }, (payload) => {
        const command = payload.payload;
        // Check if this command is for our session
        if (command.sessionId === monitorSessionId && command.roomId === room.id) {
          // Stop monitoring if currently monitoring
          if (isMonitoring) {
            handleStopRecording();
          }
        }
      })
      .on('broadcast', { event: 'toggle-mic' }, (payload) => {
        const command = payload.payload;
        // Check if this command is for our session
        if (command.sessionId === monitorSessionId && command.roomId === room.id) {
          // Find and click the mic toggle button
          const micButton = document.querySelector('[data-lk-source="microphone"]') as HTMLButtonElement;
          if (micButton) {
            micButton.click();
          }
        }
      })
      .subscribe();
    
    return () => {
      channel.unsubscribe();
    };
  }, [monitorSessionId, room.id, isMonitoring]);

  const handleHostDisconnect = useCallback(async () => {
    // Clear LiveKit state
    setToken(null);
    setServerUrl('');
    setError(null);
    
    // Don't automatically end the monitoring session - just disconnect audio
    // This allows the user to stay in the monitoring view and potentially reconnect
    
    toast({
      title: "Audio broadcast ended",
      description: "You can start a new broadcast or leave the room",
    });
  }, [toast]);

  // Create the onConnect callback outside of the render
  const handleConnect = useCallback(() => {
    generateToken(currentSessionId || undefined);
  }, [generateToken, currentSessionId]);

  const handleStopRecording = async () => {
    isUnloadingRef.current = true;
    
    // Trigger backend cleanup via LiveKit
    if (currentSessionId) {
      try {
        // Try to signal backend cleanup via LiveKit RPC
        const { triggerLiveKitCleanup } = await import('./LiveKitCleanupHandler');
        await triggerLiveKitCleanup('user_stop');
      } catch (error) {
        }
    }
    
    await endRecordingSession();
    setIsMonitoring(false);
    setCurrentSessionId(null);
    
    // Clean up sessionStorage when stopping monitoring
    sessionStorage.removeItem(`monitoring-${room.id}`);
    sessionStorage.removeItem(`session-${room.id}`);
    sessionStorage.removeItem(`transcripts-${room.id}`);
    
    toast({
      title: t('mosqueAdmin.rooms.stopMonitoring'),
      description: `Session ended with ${transcriptCount} transcript segments captured`,
    });
    
    // Notify parent component to reset dashboard state
    if (onStopMonitoring) {
      onStopMonitoring();
    }
    
    isUnloadingRef.current = false;
  };

  // Fullscreen toggle
  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

  // Listen for fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, []);

  const handleLaunchDisplay = (e: React.MouseEvent) => {
    // Prevent any default button behavior that could cause page reload
    e.preventDefault();
    e.stopPropagation();
    
    try {
      const displayUrl = new URL('/display', window.location.origin);
      
      if (room.Livekit_room_name) {
        displayUrl.searchParams.set('room', room.Livekit_room_name);
      }
      displayUrl.searchParams.set('mosque_id', mosque_id.toString());
      displayUrl.searchParams.set('room_id', room.id.toString());
      
      // Add session_id for real-time broadcasting
      if (currentSessionId) {
        displayUrl.searchParams.set('session_id', currentSessionId);
      }
      
      // Open in new window without affecting main window
      const displayWindow = window.open(
        displayUrl.toString(),
        'mosque-display',
        'width=1920,height=1080,fullscreen=yes,menubar=no,toolbar=no,location=no,status=no,scrollbars=no,noopener=yes,noreferrer=yes'
      );
      
      // Ensure main window stays focused to prevent state changes
      if (displayWindow) {
        // Small delay to ensure the new window is opened before refocusing
        setTimeout(() => {
          if (!displayWindow.closed) {
            window.focus();
          }
        }, 50);
      }
    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('technical.errors.createFailed'),
        variant: "destructive"
      });
    }
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString();
  };

  const getConnectionStatus = () => {
    // Simplified connection status for Supabase-only architecture
    if (isMonitoring) return { text: 'Live', color: 'bg-success', icon: Wifi };
    return { text: 'Offline', color: 'bg-muted-foreground', icon: WifiOff };
  };

  const connectionStatus = getConnectionStatus();
  const StatusIcon = connectionStatus.icon;

  return (
    <>
      <div className={`w-full h-screen lg:h-[87vh] flex flex-col ${isMonitoring ? 'pb-20' : ''}`}>
      
      {/* Control Bar */}
      <div className="flex-shrink-0 bg-card/50 backdrop-blur-sm border-b border-border/50 px-4 py-3">
        <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-3">
          {/* Left Section: Room Info */}
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 flex-wrap">
              <h2 className="text-lg font-semibold flex items-center gap-2">
                <Activity className="h-5 w-5" />
                <span className="truncate">{room.Title}</span>
              </h2>
              <Badge variant="outline" className="flex items-center gap-1">
                <StatusIcon className="h-3 w-3" />
                {connectionStatus.text}
              </Badge>
            </div>
            <div className="flex items-center gap-2 text-sm text-muted-foreground mt-1">
              <span>{t('mosqueAdmin.monitor.roomId')}: {room.id}</span>
              <span>•</span>
              <span>{t('mosqueAdmin.monitor.status')}: {room.status}</span>
              <span>•</span>
              <span>{getLanguageDisplayName(room.transcription_language || 'en')} → {getLanguageDisplayName(room.translation__language || 'ar')}</span>
            </div>
          </div>

          {/* Center Section: Stats (Desktop) */}
          <div className="hidden lg:flex items-center gap-4 px-4 py-2 bg-muted/30 rounded-lg">
            <div className="flex items-center gap-1.5">
              <Users className="h-3.5 w-3.5 text-muted-foreground" />
              <span className="text-sm font-medium">{participantCount}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <MessageSquare className="h-3.5 w-3.5 text-muted-foreground" />
              <span className="text-sm font-medium">{translationActivity.length}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <Circle className={`h-3.5 w-3.5 ${currentSessionId ? 'text-error animate-pulse' : 'text-muted-foreground'}`} />
              <span className="text-sm font-medium">{transcriptCount}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <div className={`h-2 w-2 rounded-full ${connectionStatus.color}`}></div>
              <span className="text-sm font-medium">{isMonitoring ? 'Live' : 'Offline'}</span>
            </div>
          </div>

          {/* Right Section: Actions */}
          <div className="flex items-center gap-2 flex-shrink-0">
            {/* Action Buttons First */}
            <Button 
              type="button" 
              onClick={handleLaunchDisplay} 
              variant="outline" 
              size="sm"
              className="flex items-center gap-2 !bg-card dark:!bg-[#181818] border-0"
            >
              <Monitor className="h-4 w-4 mr-2" />
              <span className="sm:hidden">{t('liveMonitor.display')}</span>
              <span className="hidden sm:inline">{t('liveMonitor.launchDisplay')}</span>
            </Button>
            {!isMonitoring ? (
              <Button 
                type="button" 
                onClick={handleGoLive} 
                size="sm"
                className="flex items-center gap-2 normal-case"
              >
                <Circle className="h-4 w-4 fill-current text-error" />
                <span>{t('mosqueAdmin.monitor.goLive')}</span>
              </Button>
            ) : (
              <Button 
                type="button" 
                onClick={handleStopRecording} 
                variant="outline" 
                size="sm"
                className="flex items-center gap-2"
              >
                <Pause className="h-4 w-4" />
                <span>{t('mosqueAdmin.monitor.leaveRoom')}</span>
              </Button>
            )}

            {/* View Mode Toggle - Always visible */}
            <div className="flex items-center gap-1 mx-2">
              <Layers className={`h-4 w-4 ${viewMode === 'card' ? 'text-primary' : 'text-muted-foreground'}`} />
              <Switch
                checked={viewMode === 'typewriter'}
                onCheckedChange={(checked) => {
                  setViewMode(checked ? 'typewriter' : 'card');
                  if (checked) {
                    setHasViewedTypewriter(true);
                  }
                }}
                aria-label="Toggle view mode"
                className="scale-75"
              />
              <Type className={`h-4 w-4 ${viewMode === 'typewriter' ? 'text-primary' : 'text-muted-foreground'}`} />
            </div>

            {/* Only show additional toggles in conversation mode */}
            {isConversationMode && (
              <>
                {/* Separator */}
                <div className="w-px h-6 bg-border mx-1" />

                {/* Fullscreen Toggle */}
                <Button
                  type="button"
                  onClick={toggleFullscreen}
                  variant="outline"
                  size="sm"
                  className="flex items-center gap-2"
                  title={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
                >
                  {isFullscreen ? (
                    <Minimize className="h-4 w-4" />
                  ) : (
                    <Maximize className="h-4 w-4" />
                  )}
                </Button>

                {/* Transcription Toggle */}
                <Button
                  type="button"
                  onClick={() => setShowTranscription(!showTranscription)}
                  variant="outline"
                  size="sm"
                  className="flex items-center gap-2"
                  title={showTranscription ? "Hide transcription" : "Show transcription"}
                >
                  {showTranscription ? (
                    <Eye className="h-4 w-4" />
                  ) : (
                    <EyeOff className="h-4 w-4" />
                  )}
                </Button>

                {/* Inverted Stacking Toggle */}
                <Button
                  type="button"
                  onClick={() => setInvertedStacking(!invertedStacking)}
                  variant="outline"
                  size="sm"
                  className={`flex items-center gap-2 ${invertedStacking ? 'bg-primary/10' : ''}`}
                  title={invertedStacking ? "Switch to normal stacking" : "Switch to inverted stacking"}
                >
                  <ArrowDown 
                    className={`h-4 w-4 transition-transform duration-300 ${invertedStacking ? 'rotate-180' : ''}`}
                  />
                </Button>

                {/* Compact Font Toggle */}
                <Button
                  type="button"
                  onClick={() => setCompactFont(!compactFont)}
                  variant="outline"
                  size="sm"
                  className={`flex items-center gap-2 ${compactFont ? 'bg-primary/10' : ''}`}
                  title={compactFont ? "Normal font size" : "Compact font size"}
                >
                  <Type 
                    className={`h-4 w-4 transition-transform ${compactFont ? 'scale-75' : 'scale-100'}`}
                  />
                </Button>

                {/* Theme Toggle */}
                <Button
                  type="button"
                  onClick={() => setTheme(theme === "light" ? "dark" : "light")}
                  variant="outline"
                  size="sm"
                  className="flex items-center gap-2"
                  title={theme === "light" ? "Switch to dark mode" : "Switch to light mode"}
                >
                  <Sun className="h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
                  <Moon className="absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
                </Button>
              </>
            )}
          </div>
        </div>
      </div>

      {/* Broadcast Receiver for real-time updates */}
      <BroadcastReceiver
        roomId={room.id}
        mosqueId={mosque_id}
        enabled={isMonitoring}
        onTranscription={(text, language, timestamp, messageData) => {
          // Update real-time display
          setTranslationActivity(prev => [{
            type: 'transcription',
            language,
            text,
            timestamp,
            source: 'broadcast'
          }, ...prev.slice(0, 19)]);

          const arabicText = text.trim();
          
          // Skip empty text
          if (!arabicText) {
            return;
          }
          
          // Use sentence context from backend if available
          if (messageData?.sentence_id) {
            const sentenceId = messageData.sentence_id;
            const isComplete = messageData.is_complete || false;
            
            if (isComplete) {
              // Backend says this sentence is complete with authoritative text
              
              // Check if we have this sentence in current or sentences
              setCurrentSentence(current => {
                if (current?.id === sentenceId) {
                  // Move to completed sentences with the authoritative complete text
                  setSentences(prev => {
                    // Check if already in sentences array
                    const existingIndex = prev.findIndex(s => s.id === sentenceId);
                    if (existingIndex >= 0) {
                      // Update existing with complete text
                      const updated = [...prev];
                      updated[existingIndex] = {
                        ...updated[existingIndex],
                        transcription: arabicText, // Use backend's complete text
                        isComplete: true,
                        timestamp
                      };
                      return updated;
                    } else {
                      // Add as new complete sentence
                      return [{
                        id: sentenceId,
                        transcription: arabicText, // Use backend's authoritative complete text
                        translation: '',
                        isComplete: true,
                        timestamp
                      }, ...prev.slice(0, 49)];
                    }
                  });
                  return null; // Clear current sentence
                }
                return current;
              });
              
              // Also check if it's already in sentences array (in case current was already cleared)
              setSentences(prev => {
                const existingIndex = prev.findIndex(s => s.id === sentenceId);
                if (existingIndex >= 0) {
                  // Update with authoritative text
                  const updated = [...prev];
                  updated[existingIndex] = {
                    ...updated[existingIndex],
                    transcription: arabicText,
                    isComplete: true,
                    timestamp
                  };
                  return updated;
                }
                return prev;
              });
            } else {
              // Backend says this is a fragment
              
              // Update current sentence
              setCurrentSentence(current => {
                if (current?.id === sentenceId) {
                  // Update existing - append new fragment
                  return {
                    ...current,
                    transcription: (current.transcription + ' ' + arabicText).trim(),
                    timestamp
                  };
                } else {
                  // Start new sentence
                  return {
                    id: sentenceId,
                    transcription: arabicText,
                    timestamp,
                    isComplete: false
                  };
                }
              });
            }
          } else {
            // Fallback to old logic if no sentence context
            // Check if this is standalone punctuation
            const isStandalonePunctuation = /^[.!?؟]$/.test(arabicText);
            const hasPunctuation = /[.!?؟]/.test(arabicText);
            
            if (isStandalonePunctuation) {
              // Complete current sentence with this punctuation
              setCurrentSentence(prev => {
                if (prev && !prev.isComplete) {
                  const completedSentence = {
                    ...prev,
                    transcription: (prev.transcription + arabicText).trim(),
                    translation: '',
                    isComplete: true,
                    timestamp: timestamp
                  };
                  
                  setSentences(prevSentences => [completedSentence, ...prevSentences.slice(0, 49)]);
                  return null;
                } else {
                  // No current sentence to complete, ignore standalone punctuation
                  return prev;
                }
              });
            } else if (hasPunctuation) {
              // This text already includes punctuation - complete sentence
              setCurrentSentence(prev => {
                if (prev && !prev.isComplete) {
                  // Complete the existing building sentence with this punctuated text
                  const completedSentence = {
                    ...prev,
                    transcription: (prev.transcription + ' ' + arabicText).trim(),
                    translation: '',
                    isComplete: true,
                    timestamp: timestamp
                  };
                  
                  setSentences(prevSentences => [completedSentence, ...prevSentences.slice(0, 49)]);
                  return null;
                } else {
                  // Create new completed sentence
                  const newSentence = {
                    id: `broadcast-${Date.now()}`,
                    transcription: arabicText,
                    translation: '',
                    isComplete: true,
                    timestamp: timestamp
                  };
                  
                  setSentences(prevSentences => [newSentence, ...prevSentences.slice(0, 49)]);
                  return null;
                }
              });
            } else {
              // Accumulate text in current building sentence
              setCurrentSentence(prev => {
                if (prev) {
                  const updated = { ...prev, transcription: (prev.transcription + ' ' + arabicText).trim(), timestamp };
                  return updated;
                } else {
                  const newSentence = {
                    id: `broadcast-${Date.now()}`,
                    transcription: arabicText,
                    timestamp: timestamp
                  };
                  return newSentence;
                }
              });
            }
          }
        }}
        onTranslation={(text, language, timestamp, messageData) => {
          // Update real-time display
          setTranslationActivity(prev => [{
            type: 'translation',
            language,
            text,
            timestamp,
            source: 'broadcast'
          }, ...prev.slice(0, 19)]);

          const translation = text.trim();
          
          // Match translation to sentence by ID if available
          if (messageData?.sentence_id) {
            setSentences(prev => {
              const sentenceIndex = prev.findIndex(s => s.id === messageData.sentence_id);
              
              if (sentenceIndex !== -1) {
                const updated = [...prev];
                updated[sentenceIndex] = {
                  ...updated[sentenceIndex],
                  translation: translation
                };
                return updated;
              } else {
                // Fallback: find first sentence without translation
                const fallbackIndex = prev.findIndex(s => !s.translation || s.translation.trim() === '');
                if (fallbackIndex !== -1) {
                  const updated = [...prev];
                  updated[fallbackIndex] = {
                    ...updated[fallbackIndex],
                    translation: translation
                  };
                  return updated;
                }
              }
              return prev;
            });
          } else {
            // Fallback to old logic: find first card without translation
            setSentences(prev => {
              const sentenceIndex = prev.findIndex(s => !s.translation || s.translation.trim() === '');
              
              if (sentenceIndex !== -1) {
                const updated = [...prev];
                updated[sentenceIndex] = {
                  ...updated[sentenceIndex],
                  translation: translation,
                  isComplete: true
                };
                return updated;
              }
              return prev;
            });
          }
        }}
      />
      
      {/* --- Main Content Area --- */}
      {/* Full Width Translation Activity */}
      <div className="flex-1 flex flex-col min-h-0 overflow-hidden px-4 pb-4">
        <Card className="border-0 border-none bg-transparent flex-1 flex flex-col min-h-0">
          <CardContent className="flex-1 flex flex-col min-h-0 pt-6">
            <ScrollArea className="flex-1 min-h-[200px]">
              {viewMode === 'typewriter' ? (
                <TypewriterView
                  currentSentence={currentSentence}
                  sentences={sentences}
                  room={room}
                  isMonitoring={isMonitoring}
                  displayedTranscription={typewriterTranscriptionDisplay}
                  displayedTranslation={typewriterTranslationDisplay}
                  onTranscriptionUpdate={setTypewriterTranscriptionDisplay}
                  onTranslationUpdate={setTypewriterTranslationDisplay}
                  skipAnimation={hasViewedTypewriter}
                />
              ) : !currentSentence && sentences.length === 0 ? (
                <div className="text-center text-muted-foreground py-8">
                  {isMonitoring ? t('liveMonitor.waitingForActivity') : t('liveMonitor.startMonitoringPrompt')}
                </div>
              ) : (
                <div className="space-y-3">
                  {/* Current sentence being built */}
                  {currentSentence && !currentSentence.isComplete && (() => {
                    const cardId = `current-${currentSentence.id}`;
                    const isNewCard = !animatedCardsRef.current.has(cardId);
                    
                    if (isNewCard) {
                      animatedCardsRef.current.add(cardId);
                    }
                    
                    return (
                      <div className={`border rounded-lg p-4 bg-transparent ${isNewCard ? 'animate-card-enter' : ''}`}>
                        <div className="flex items-center justify-between mb-3">
                          <div className={`h-2 w-2 rounded-full bg-yellow-500 animate-pulse transition-colors duration-300 ${isRTLLanguage(room.transcription_language || 'ar') ? 'order-2' : 'order-1'}`}></div>
                          <span className="text-xs text-muted-foreground">
                            {format(new Date(currentSentence.timestamp), 'HH:mm:ss')}
                          </span>
                        </div>
                        <div className="grid grid-cols-1 gap-3">
                          {/* Source language text */}
                          {showTranscription && (
                            <div className={isRTLLanguage(room.transcription_language || 'ar') ? 'text-right' : 'text-left'}>
                              <p className="text-lg leading-relaxed font-medium inline" 
                                 dir={isRTLLanguage(room.transcription_language || 'ar') ? 'rtl' : 'ltr'}>
                                {currentSentence.transcription}
                                <span className="inline-block w-0.5 h-5 bg-primary animate-blink ml-1" />
                              </p>
                            </div>
                          )}
                          {/* Translation placeholder */}
                          <div className={isRTLLanguage(room.translation__language || 'en') ? 'text-right' : 'text-left'}>
                            <p className="text-lg text-muted-foreground italic font-medium">
                              {t('liveMonitor.waitingForTranslation')}
                            </p>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                  
                  {/* Completed sentences */}
                  {sentences.map((sentence, index) => {
                    const cardId = `sentence-${sentence.id}`;
                    const isNewCard = !animatedCardsRef.current.has(cardId);
                    const translationKey = `translation-${sentence.id}`;
                    const completionKey = `completion-${sentence.id}`;
                    const hasTranslation = sentence.translation && sentence.translation.trim() !== '';
                    const wasEmpty = !translationStatesRef.current.get(translationKey);
                    const shouldAnimateTranslation = hasTranslation && wasEmpty;
                    
                    // Track completion status to prevent re-animation when only completion changes
                    const wasIncomplete = !completionStatesRef.current.get(completionKey);
                    const justCompleted = sentence.isComplete && wasIncomplete;
                    
                    if (isNewCard) {
                      animatedCardsRef.current.add(cardId);
                    }
                    
                    if (hasTranslation) {
                      translationStatesRef.current.set(translationKey, true);
                    }
                    
                    if (sentence.isComplete) {
                      completionStatesRef.current.set(completionKey, true);
                    }
                    
                    return (
                      <div key={sentence.id} 
                           className={`border rounded-lg p-4 bg-transparent ${isNewCard && !justCompleted ? 'animate-card-enter' : ''}`}
                           style={isNewCard && !justCompleted ? { animationDelay: `${index * 50}ms` } : undefined}>
                        <div className="flex items-center justify-between mb-3">
                          <div className={`h-2 w-2 rounded-full ${sentence.isComplete ? 'bg-green-500' : 'bg-yellow-500'} transition-colors duration-500 ease-in-out ${isRTLLanguage(room.transcription_language || 'ar') ? 'order-2' : 'order-1'}`}></div>
                          <span className="text-xs text-muted-foreground">
                            {format(new Date(sentence.timestamp), 'HH:mm:ss')}
                          </span>
                        </div>
                        <div className="grid grid-cols-1 gap-3">
                          {/* Source language text */}
                          {showTranscription && (
                            <div className={isRTLLanguage(room.transcription_language || 'ar') ? 'text-right' : 'text-left'}>
                              <p className="text-lg leading-relaxed font-medium" 
                                 dir={isRTLLanguage(room.transcription_language || 'ar') ? 'rtl' : 'ltr'}>
                                {sentence.transcription}
                              </p>
                            </div>
                          )}
                          {/* Translation text */}
                          <div className={isRTLLanguage(room.translation__language || 'en') ? 'text-right' : 'text-left'}>
                            {sentence.translation ? (
                              <p className={`text-lg leading-relaxed text-foreground font-medium ${shouldAnimateTranslation ? 'animate-fade-in' : ''} ${compactFont ? 'text-base' : ''}`}
                                 dir={isRTLLanguage(room.translation__language || 'en') ? 'rtl' : 'ltr'}>
                                {sentence.translation}
                              </p>
                            ) : (
                              <p className={`text-lg text-muted-foreground italic font-medium ${compactFont ? 'text-base' : ''}`}>
                                {t('liveMonitor.waitingForTranslation')}
                              </p>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </ScrollArea>
          </CardContent>
        </Card>
      </div>
    </div>
    
    {/* Fixed Footer Host Controls */}
    <AnimatePresence>
      {isMonitoring && (
        <HostControlFooter
          token={token}
          serverUrl={serverUrl}
          loading={loading}
          error={error}
          roomName={room.Livekit_room_name}
          roomTitle={room.Title}
          onConnect={handleConnect}
          onDisconnect={handleHostDisconnect}
          isConnecting={isConnecting}
          sessionId={currentSessionId}
          roomId={room.id}
        />
      )}
    </AnimatePresence>
    </>
  );
};

export default LiveMonitor;



================================================
FILE: src/features/livekit/components/StyledDisconnectButton.tsx
================================================
import React from 'react';
import { DisconnectButton as LiveKitDisconnectButton } from '@livekit/components-react';
import { PhoneOff, LogOut, X } from 'lucide-react';
import { cn } from '@/lib/utils';

interface StyledDisconnectButtonProps extends React.ComponentProps<typeof LiveKitDisconnectButton> {
  variant?: 'default' | 'destructive' | 'outline' | 'ghost';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  icon?: 'phone' | 'logout' | 'x';
  showLabel?: boolean;
  customLabel?: string;
}

export const StyledDisconnectButton = React.forwardRef<HTMLButtonElement, StyledDisconnectButtonProps>(
  ({ 
    className, 
    variant = 'destructive', 
    size = 'default',
    icon = 'phone',
    showLabel = true,
    customLabel = 'End',
    children,
    ...props 
  }, ref) => {
    const baseStyles = cn(
      "inline-flex items-center justify-center gap-2",
      "rounded-lg font-medium",
      "transition-all duration-200",
      "focus:outline-none focus:ring-2 focus:ring-destructive/50 focus:ring-offset-2 focus:ring-offset-background",
      "disabled:opacity-50 disabled:cursor-not-allowed",
      "group"
    );

    const variantStyles = {
      default: cn(
        "bg-destructive text-destructive-foreground",
        "hover:bg-destructive/90",
        "shadow-sm hover:shadow-md"
      ),
      destructive: cn(
        "bg-destructive/10 text-destructive border border-destructive/20",
        "hover:bg-destructive/20 hover:border-destructive/30",
        "hover:shadow-sm"
      ),
      outline: cn(
        "border border-destructive/50 text-destructive",
        "hover:bg-destructive/10 hover:border-destructive"
      ),
      ghost: cn(
        "text-destructive",
        "hover:bg-destructive/10 hover:text-destructive"
      )
    };

    const sizeStyles = {
      default: "h-10 px-4 text-sm",
      sm: "h-9 px-3 text-sm",
      lg: "h-11 px-6 text-base",
      icon: "h-10 w-10 text-sm"
    };

    const iconSize = {
      default: "h-4 w-4",
      sm: "h-4 w-4",
      lg: "h-5 w-5",
      icon: "h-5 w-5"
    };

    const IconComponent = {
      phone: PhoneOff,
      logout: LogOut,
      x: X
    }[icon];

    return (
      <LiveKitDisconnectButton
        ref={ref}
        className={cn(
          baseStyles,
          variantStyles[variant],
          sizeStyles[size],
          className
        )}
        {...props}
      >
        {children || (
          <>
            <IconComponent className={cn(
              iconSize[size],
              "transition-transform duration-200",
              "group-hover:scale-110"
            )} />
            {showLabel && size !== 'icon' && (
              <span className="font-medium">{customLabel}</span>
            )}
          </>
        )}
      </LiveKitDisconnectButton>
    );
  }
);

StyledDisconnectButton.displayName = 'StyledDisconnectButton';


================================================
FILE: src/features/livekit/components/StyledHostControls.tsx
================================================
import React from 'react';
import { LiveKitRoom, RoomAudioRenderer } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { Mic, Loader2, WifiOff, Radio, AlertCircle } from 'lucide-react';
import { StyledMediaDeviceMenu } from './StyledMediaDeviceMenu';
import { StyledTrackToggle } from './StyledTrackToggle';
import { StyledDisconnectButton } from './StyledDisconnectButton';
import { StyledParticipantInfo } from './StyledParticipantInfo';
import { motion, AnimatePresence } from 'framer-motion';
import { useTranslation } from 'react-i18next';

interface StyledHostControlsProps {
  token: string | null;
  serverUrl: string;
  loading: boolean;
  error: string | null;
  roomName: string | null;
  roomTitle: string | null;
  onGenerateToken: () => void;
  onDisconnect: () => void;
}

export const StyledHostControls: React.FC<StyledHostControlsProps> = ({
  token,
  serverUrl,
  loading,
  error,
  roomName,
  roomTitle,
  onGenerateToken,
  onDisconnect
}) => {
  const { t } = useTranslation();

  if (!roomName) {
    return (
      <Card className="bg-gradient-to-br from-card/50 to-card/30 backdrop-blur-md border-border/50">
        <CardContent className="text-center py-8">
          <div className="w-16 h-16 bg-warning/10 rounded-full flex items-center justify-center mx-auto mb-4">
            <WifiOff className="h-8 w-8 text-warning" />
          </div>
          <h3 className="text-lg font-semibold mb-2">{t('hostControls.setupRequiredTitle')}</h3>
          <p className="text-sm text-muted-foreground max-w-sm mx-auto">
            {t('hostControls.setupRequiredDescription')}
          </p>
        </CardContent>
      </Card>
    );
  }

  if (!token) {
    return (
      <Card className="bg-gradient-to-br from-card/50 to-card/30 backdrop-blur-md border-border/50">
        <CardContent className="p-6">
          <AnimatePresence mode="wait">
            {error && (
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                className="flex items-start gap-3 p-4 mb-6 bg-destructive/10 border border-destructive/20 rounded-lg"
              >
                <AlertCircle className="h-5 w-5 text-destructive shrink-0 mt-0.5" />
                <div className="flex-1">
                  <p className="text-sm font-medium text-destructive">{error}</p>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
          
          <div className="text-center space-y-6">
            <motion.div 
              className="w-20 h-20 mx-auto bg-gradient-to-br from-primary/20 to-primary/10 rounded-full flex items-center justify-center"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Mic className="h-10 w-10 text-primary" />
            </motion.div>
            
            <div>
              <h3 className="text-xl font-semibold mb-2">{t('hostControls.readyToBroadcastTitle')}</h3>
              <p className="text-sm text-muted-foreground">
                {t('hostControls.readyToBroadcastDescription', { roomTitle })}
              </p>
            </div>
            
            <Button 
              onClick={onGenerateToken} 
              disabled={loading}
              size="lg"
              className="w-full max-w-xs mx-auto h-12 text-base font-semibold shadow-lg hover:shadow-xl transition-shadow"
            >
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-5 w-5 animate-spin" />
                  {t('hostControls.connectingButton')}
                </>
              ) : (
                <>
                  <Radio className="mr-2 h-5 w-5" />
                  {t('hostControls.startBroadcastingButton')}
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (!serverUrl) {
    return (
      <Card className="bg-gradient-to-br from-card/50 to-card/30 backdrop-blur-md border-border/50">
        <CardContent className="text-center py-8">
          <div className="w-16 h-16 bg-destructive/10 rounded-full flex items-center justify-center mx-auto mb-4">
            <AlertCircle className="h-8 w-8 text-destructive" />
          </div>
          <h3 className="text-lg font-semibold mb-2">{t('hostControls.configErrorTitle')}</h3>
          <p className="text-sm text-muted-foreground max-w-sm mx-auto">
            {t('hostControls.configErrorDescription')}
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="bg-gradient-to-br from-card/50 to-card/30 backdrop-blur-md border-border/50 overflow-hidden">
      <CardContent className="p-0">
        <LiveKitRoom 
          video={false} 
          audio={true} 
          token={token}
          serverUrl={serverUrl}
          onDisconnected={onDisconnect}
          className="livekit-room"
        >
          <RoomAudioRenderer />
          
          {/* Modern Control Panel */}
          <div className="p-4 space-y-4">
            {/* Status Bar */}
            <div className="flex items-center justify-between">
              <motion.div
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                className="flex items-center gap-3"
              >
                <Badge className="bg-success/10 text-success border-success/20 px-3 py-1.5 flex items-center gap-2">
                  <div className="relative">
                    <div className="w-2 h-2 bg-success rounded-full" />
                    <div className="absolute inset-0 w-2 h-2 bg-success rounded-full animate-ping" />
                  </div>
                  <span className="font-semibold">{t('hostControls.liveBroadcasting')}</span>
                </Badge>
                
                <StyledParticipantInfo variant="compact" />
              </motion.div>
            </div>

            {/* Main Controls */}
            <motion.div 
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.1 }}
              className="grid grid-cols-1 sm:grid-cols-3 gap-3"
            >
              {/* Audio Device Selector */}
              <div className="sm:col-span-2">
                <StyledMediaDeviceMenu 
                  kind="audioinput"
                  variant="default"
                />
              </div>
              
              {/* Mic Toggle */}
              <StyledTrackToggle 
                source={Track.Source.Microphone}
                variant="default"
                showLabel={true}
              />
            </motion.div>

            {/* Disconnect Button */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <StyledDisconnectButton 
                variant="destructive"
                icon="phone"
                customLabel={t('hostControls.endBroadcastButton')}
                className="w-full"
              />
            </motion.div>

            {/* Optional: Detailed Stats */}
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.3 }}
              className="pt-3 border-t border-border/30"
            >
              <StyledParticipantInfo variant="detailed" />
            </motion.div>
          </div>
        </LiveKitRoom>
      </CardContent>
    </Card>
  );
};


================================================
FILE: src/features/livekit/components/StyledMediaDeviceMenu.tsx
================================================
import React from 'react';
import { MediaDeviceMenu as LiveKitMediaDeviceMenu } from '@livekit/components-react';
import { Settings2, ChevronDown } from 'lucide-react';
import { cn } from '@/lib/utils';

interface StyledMediaDeviceMenuProps extends React.ComponentProps<typeof LiveKitMediaDeviceMenu> {
  variant?: 'default' | 'compact' | 'minimal';
  showIcon?: boolean;
}

export const StyledMediaDeviceMenu = React.forwardRef<HTMLButtonElement, StyledMediaDeviceMenuProps>(
  ({ className, variant = 'default', showIcon = true, ...props }, ref) => {
    const baseStyles = cn(
      "relative inline-flex items-center justify-between gap-2",
      "bg-card/50 backdrop-blur-sm",
      "border border-border/50",
      "rounded-lg",
      "text-sm font-medium",
      "transition-all duration-200",
      "hover:bg-card/80 hover:border-border",
      "focus:outline-none focus:ring-2 focus:ring-primary/50 focus:ring-offset-2 focus:ring-offset-background",
      "disabled:opacity-50 disabled:cursor-not-allowed"
    );

    const variantStyles = {
      default: "h-10 px-4 min-w-[200px]",
      compact: "h-9 px-3 min-w-[160px]",
      minimal: "h-8 px-2 min-w-[120px] text-xs"
    };

    return (
      <div className="relative w-full">
        <LiveKitMediaDeviceMenu
          ref={ref}
          className={cn(
            baseStyles,
            variantStyles[variant],
            className
          )}
          {...props}
        />
        {showIcon && (
          <div className="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
            <ChevronDown className={cn(
              "text-muted-foreground",
              variant === 'minimal' ? 'h-3 w-3' : 'h-4 w-4'
            )} />
          </div>
        )}
      </div>
    );
  }
);

StyledMediaDeviceMenu.displayName = 'StyledMediaDeviceMenu';


================================================
FILE: src/features/livekit/components/StyledMicToggle.tsx
================================================
import React from 'react';
import { useTrackToggle } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';

interface StyledMicToggleProps {
  className?: string;
  showLabel?: boolean;
}

export const StyledMicToggle: React.FC<StyledMicToggleProps> = ({ 
  className, 
  showLabel = false 
}) => {
  const { buttonProps, enabled } = useTrackToggle({ source: Track.Source.Microphone });

  return (
    <motion.button
      {...buttonProps}
      className={cn(
        "relative h-12 w-12 rounded-full",
        "bg-gradient-to-br",
        enabled 
          ? "from-emerald-500/20 to-emerald-600/20 hover:from-emerald-500/30 hover:to-emerald-600/30" 
          : "from-red-500/20 to-red-600/20 hover:from-red-500/30 hover:to-red-600/30",
        "backdrop-blur-xl border",
        enabled ? "border-emerald-500/30" : "border-red-500/30",
        "transition-all duration-300",
        "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background",
        enabled ? "focus:ring-emerald-500/50" : "focus:ring-red-500/50",
        "group overflow-hidden",
        className
      )}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      {/* Background pulse animation */}
      <AnimatePresence>
        {enabled && (
          <motion.div
            className="absolute inset-0 rounded-full bg-emerald-500/20"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1.5, opacity: 0 }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeOut"
            }}
          />
        )}
      </AnimatePresence>

      {/* Icon container */}
      <div className="relative z-10 flex items-center justify-center h-full">
        <AnimatePresence mode="wait">
          {enabled ? (
            <motion.div
              key="mic-on"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic On Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-emerald-600"
              >
                <path
                  d="M12 2C10.34 2 9 3.34 9 5V11C9 12.66 10.34 14 12 14C13.66 14 15 12.66 15 11V5C15 3.34 13.66 2 12 2Z"
                  fill="currentColor"
                  className="animate-pulse"
                />
                <path
                  d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                {/* Sound waves */}
                <motion.path
                  d="M5.5 9C5.5 9 6 8 6 11C6 14 5.5 13 5.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: -2 }}
                  animate={{ opacity: [0, 1, 0], x: [-2, 0, -2] }}
                  transition={{ duration: 1.5, repeat: Infinity }}
                />
                <motion.path
                  d="M18.5 9C18.5 9 18 8 18 11C18 14 18.5 13 18.5 13"
                  stroke="currentColor"
                  strokeWidth="1.5"
                  strokeLinecap="round"
                  initial={{ opacity: 0, x: 2 }}
                  animate={{ opacity: [0, 1, 0], x: [2, 0, 2] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: 0.75 }}
                />
              </svg>
            </motion.div>
          ) : (
            <motion.div
              key="mic-off"
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              exit={{ scale: 0, rotate: 180 }}
              transition={{ type: "spring", duration: 0.4 }}
            >
              {/* Mic Off Icon */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                className="text-red-600"
              >
                <path
                  d="M15 11V5C15 3.34 13.66 2 12 2C10.34 2 9 3.34 9 5V9.17L15 15.17V11Z"
                  fill="currentColor"
                />
                <path
                  d="M19 11H17C17 11.35 16.97 11.69 16.91 12.02L18.93 14.04C18.98 13.7 19 13.36 19 13V11Z"
                  fill="currentColor"
                  opacity="0.7"
                />
                <path
                  d="M4.71 3.29C4.32 2.9 3.68 2.9 3.29 3.29C2.9 3.68 2.9 4.32 3.29 4.71L9 10.41V11C9 12.66 10.34 14 12 14C12.23 14 12.44 13.96 12.65 13.9L14.31 15.56C13.63 15.84 12.84 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C14.09 17.78 15.11 17.41 16 16.88L19.29 20.17C19.68 20.56 20.32 20.56 20.71 20.17C21.1 19.78 21.1 19.14 20.71 18.75L4.71 3.29Z"
                  fill="currentColor"
                />
                {/* Slash line */}
                <motion.line
                  x1="4"
                  y1="4"
                  x2="20"
                  y2="20"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  initial={{ pathLength: 0 }}
                  animate={{ pathLength: 1 }}
                  transition={{ duration: 0.3 }}
                />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Status indicator dot */}
      <div className={cn(
        "absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-background",
        enabled ? "bg-emerald-500" : "bg-red-500"
      )}>
        {enabled && (
          <div className="absolute inset-0 bg-emerald-500 rounded-full animate-ping" />
        )}
      </div>

      {showLabel && (
        <span className="sr-only">
          {enabled ? 'Mute microphone' : 'Unmute microphone'}
        </span>
      )}
    </motion.button>
  );
};


================================================
FILE: src/features/livekit/components/StyledParticipantInfo.tsx
================================================
import React from 'react';
import { useParticipants, useTracks } from '@livekit/components-react';
import { Track } from 'livekit-client';
import { Users, Mic, MicOff, Headphones } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useTranslation } from '@/hooks/useTranslation';

interface StyledParticipantInfoProps {
  variant?: 'default' | 'compact' | 'detailed';
  className?: string;
  showLabels?: boolean;
}

export const StyledParticipantInfo: React.FC<StyledParticipantInfoProps> = ({
  variant = 'default',
  className,
  showLabels = false
}) => {
  const participants = useParticipants();
  const tracks = useTracks([Track.Source.Microphone]);
  const activeMics = tracks.filter(track => track.publication.isMuted === false).length;
  const { t } = useTranslation();

  const containerStyles = cn(
    "inline-flex items-center",
    "bg-card/30 backdrop-blur-sm",
    "border border-border/30",
    "rounded-lg",
    "transition-all duration-200",
    variant === 'compact' ? 'gap-3 px-3 py-1.5' : 'gap-4 px-4 py-2',
    className
  );

  const statStyles = cn(
    "flex items-center gap-1.5",
    "transition-colors duration-200"
  );

  const iconStyles = cn(
    variant === 'compact' ? 'h-3.5 w-3.5' : 'h-4 w-4'
  );

  const valueStyles = cn(
    "font-semibold tabular-nums",
    variant === 'compact' ? 'text-sm' : 'text-base'
  );

  const labelStyles = cn(
    "text-muted-foreground ml-1",
    variant === 'compact' ? 'text-xs' : 'text-sm'
  );

  if (variant === 'detailed') {
    return (
      <div className={cn(
        "flex flex-col gap-3 p-4",
        "bg-card/30 backdrop-blur-sm",
        "border border-border/30 rounded-lg",
        className
      )}>
        <div className="flex items-center justify-between">
          <div className={statStyles}>
            <Users className="h-5 w-5 text-primary" />
            <span className="text-lg font-semibold">{participants.length}</span>
            <span className="text-sm text-muted-foreground">{t('participantInfo.participants')}</span>
          </div>
        </div>
        <div className="flex items-center justify-between">
          <div className={statStyles}>
            <Mic className="h-5 w-5 text-success" />
            <span className="text-lg font-semibold">{activeMics}</span>
            <span className="text-sm text-muted-foreground">{t('participantInfo.activeMics')}</span>
          </div>
        </div>
        <div className="flex items-center justify-between">
          <div className={statStyles}>
            <Headphones className="h-5 w-5 text-info" />
            <span className="text-lg font-semibold">{participants.length - activeMics}</span>
            <span className="text-sm text-muted-foreground">{t('participantInfo.listening')}</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={containerStyles}>
      <div className={statStyles}>
        <Users className={cn(iconStyles, "text-primary")} />
        <span className={valueStyles}>{participants.length}</span>
        {showLabels && <span className={labelStyles}>{t('participantInfo.users')}</span>}
      </div>
      
      <div className="h-4 w-px bg-border/50" />
      
      <div className={statStyles}>
        <div className="relative">
          <Mic className={cn(iconStyles, activeMics > 0 ? "text-success" : "text-muted-foreground")} />
          {activeMics > 0 && (
            <div className="absolute -top-1 -right-1 h-2 w-2 bg-success rounded-full animate-pulse" />
          )}
        </div>
        <span className={cn(valueStyles, activeMics === 0 && "text-muted-foreground")}>
          {activeMics}
        </span>
        {showLabels && <span className={labelStyles}>{t('participantInfo.active')}</span>}
      </div>
    </div>
  );
};

StyledParticipantInfo.displayName = 'StyledParticipantInfo';


================================================
FILE: src/features/livekit/components/StyledTrackToggle.tsx
================================================
import React from 'react';
import { TrackToggle as LiveKitTrackToggle } from '@livekit/components-react';
import { Mic, MicOff, Video, VideoOff } from 'lucide-react';
import { Track } from 'livekit-client';
import { cn } from '@/lib/utils';
import { useTrackToggle } from '@livekit/components-react';

interface StyledTrackToggleProps extends React.ComponentProps<typeof LiveKitTrackToggle> {
  variant?: 'default' | 'ghost' | 'minimal' | 'destructive';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  showLabel?: boolean;
  customLabel?: string;
  source: Track.Source.Microphone | Track.Source.Camera;
}

export const StyledTrackToggle = React.forwardRef<HTMLButtonElement, StyledTrackToggleProps>(
  ({ 
    className, 
    variant = 'default', 
    size = 'default',
    showLabel = true,
    customLabel,
    source,
    ...props 
  }, ref) => {
    const baseStyles = cn(
      "inline-flex items-center justify-center gap-2",
      "rounded-lg font-medium",
      "transition-all duration-200",
      "focus:outline-none focus:ring-2 focus:ring-primary/50 focus:ring-offset-2 focus:ring-offset-background",
      "disabled:opacity-50 disabled:cursor-not-allowed",
      "group"
    );

    const variantStyles = {
      default: cn(
        "bg-card/50 backdrop-blur-sm border border-border/50",
        "hover:bg-card/80 hover:border-border",
        "data-[enabled=true]:bg-primary data-[enabled=true]:text-primary-foreground",
        "data-[enabled=true]:border-primary data-[enabled=true]:hover:bg-primary/90"
      ),
      ghost: cn(
        "hover:bg-accent hover:text-accent-foreground",
        "data-[enabled=true]:bg-accent data-[enabled=true]:text-accent-foreground"
      ),
      minimal: cn(
        "hover:bg-transparent",
        "data-[enabled=true]:text-primary data-[enabled=false]:text-muted-foreground"
      ),
      destructive: cn(
        "bg-destructive/10 text-destructive border border-destructive/20",
        "hover:bg-destructive/20 hover:border-destructive/30",
        "data-[enabled=true]:bg-destructive data-[enabled=true]:text-destructive-foreground",
        "data-[enabled=true]:hover:bg-destructive/90"
      )
    };

    const sizeStyles = {
      default: "h-10 px-4 text-sm",
      sm: "h-9 px-3 text-sm",
      lg: "h-11 px-6 text-base",
      icon: "h-10 w-10 text-sm"
    };

    const iconSize = {
      default: "h-4 w-4",
      sm: "h-4 w-4",
      lg: "h-5 w-5",
      icon: "h-5 w-5"
    };

    return (
      <LiveKitTrackToggle
        ref={ref}
        source={source}
        className={cn(
          baseStyles,
          variantStyles[variant],
          sizeStyles[size],
          className
        )}
        {...props}
      >
        {({ enabled }) => {
          const isMicrophone = source === Track.Source.Microphone;
          const Icon = isMicrophone 
            ? (enabled ? Mic : MicOff)
            : (enabled ? Video : VideoOff);
          
          const label = customLabel || (isMicrophone ? 'Mic' : 'Camera');

          return (
            <>
              <Icon className={cn(
                iconSize[size],
                "transition-transform duration-200",
                "group-hover:scale-110"
              )} />
              {showLabel && size !== 'icon' && (
                <span className="font-medium">{label}</span>
              )}
            </>
          );
        }}
      </LiveKitTrackToggle>
    );
  }
);

StyledTrackToggle.displayName = 'StyledTrackToggle';


================================================
FILE: src/features/livekit/hooks/useRoomConnection.ts
================================================
import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { Tables } from '@/integrations/supabase/types';

type Room = Tables<'rooms'>;

interface UseRoomConnectionProps {
  room: Room;
  onTokenGenerated?: (token: string, serverUrl: string) => void;
  onError?: (error: Error) => void;
}

export const useRoomConnection = ({ room, onTokenGenerated, onError }: UseRoomConnectionProps) => {
  const { toast } = useToast();
  const [token, setToken] = useState<string | null>(null);
  const [serverUrl, setServerUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);

  const generateToken = useCallback(async (sessionId?: string) => {
    if (!room) {
      const err = new Error('No room selected');
      setError(err.message);
      onError?.(err);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token) {
        throw new Error('No auth session');
      }

      // Generate LiveKit token
      const response = await fetch(
        'https://bpsahvbdlkzemwjdgxmq.supabase.co/functions/v1/generate-livekit-token',
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            roomName: room.Livekit_room_name,
            participantName: `Host-${room.id}`,
            sessionId: sessionId
          }),
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to generate token: ${errorText}`);
      }

      const data = await response.json();
      
      setToken(data.token);
      setServerUrl(data.url);
      onTokenGenerated?.(data.token, data.url);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to generate token';
      setError(errorMessage);
      onError?.(err instanceof Error ? err : new Error(errorMessage));
      toast({
        title: "Connection Error",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [room, toast, onTokenGenerated, onError]);

  const resetConnection = useCallback(() => {
    setToken(null);
    setServerUrl(null);
    setError(null);
    setIsConnecting(false);
  }, []);

  return {
    token,
    serverUrl,
    loading,
    error,
    isConnecting,
    setIsConnecting,
    generateToken,
    resetConnection
  };
};


================================================
FILE: src/features/livekit/hooks/useRoomSession.ts
================================================
import { useState, useCallback, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { Tables } from '@/integrations/supabase/types';
import { cleanupSession } from '@/utils/sessionCleanupCoordinator';
// Force refresh - removed useSessionCleanup import

type Room = Tables<'rooms'>;

interface UseRoomSessionProps {
  room: Room;
  onSessionStart?: (sessionId: string) => void;
  onSessionEnd?: () => void;
  autoCleanup?: boolean;
}

export const useRoomSession = ({ 
  room, 
  onSessionStart, 
  onSessionEnd,
  autoCleanup = true 
}: UseRoomSessionProps) => {
  const { toast } = useToast();
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [isMonitoring, setIsMonitoring] = useState(false);

  // Create a new session
  const startSession = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No authenticated user');

      // Create room session
      const { data: sessionData, error: sessionError } = await supabase
        .from('room_sessions')
        .insert({
          room_id: room.id,
          created_by: user.id,
          mosque_id: room.mosque_id,
          metadata: {
            room_name: room.Title,
            room_config: {
              model: room.model,
              language: room.language,
              translation_enabled: room.translation_enabled
            }
          }
        })
        .select()
        .single();

      if (sessionError) throw sessionError;

      setCurrentSessionId(sessionData.id);
      setIsMonitoring(true);
      onSessionStart?.(sessionData.id);

      // Update room status
      await supabase
        .from('rooms')
        .update({ status: 'active' })
        .eq('id', room.id);

      return sessionData.id;
    } catch (error) {
      console.error('Error starting session:', error);
      toast({
        title: "Session Error",
        description: error instanceof Error ? error.message : 'Failed to start session',
        variant: "destructive",
      });
      throw error;
    }
  }, [room, toast, onSessionStart]);

  // End the current session
  const endSession = useCallback(async () => {
    if (!currentSessionId) return;

    try {
      // Update session end time
      await supabase
        .from('room_sessions')
        .update({ ended_at: new Date().toISOString() })
        .eq('id', currentSessionId);

      // Update room status
      await supabase
        .from('rooms')
        .update({ status: 'inactive' })
        .eq('id', room.id);

      // Perform cleanup if enabled
      if (autoCleanup) {
        await cleanupSession({
          sessionId: currentSessionId,
          roomId: room.id,
          source: 'host_disconnect',
          skipTranscriptWait: true // Skip waiting to prevent UI blocking
        });
      }

      setCurrentSessionId(null);
      setIsMonitoring(false);
      onSessionEnd?.();
    } catch (error) {
      console.error('Error ending session:', error);
      toast({
        title: "Session Error",
        description: 'Failed to end session properly',
        variant: "destructive",
      });
    }
  }, [currentSessionId, room.id, autoCleanup, toast, onSessionEnd]);

  // Check for existing active session on mount
  useEffect(() => {
    const checkExistingSession = async () => {
      try {
        const { data: existingSession } = await supabase
          .from('room_sessions')
          .select('*')
          .eq('room_id', room.id)
          .is('ended_at', null)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        if (existingSession) {
          setCurrentSessionId(existingSession.id);
          setIsMonitoring(true);
        }
      } catch (error) {
        // No existing session, which is fine
      }
    };

    checkExistingSession();
  }, [room.id]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (currentSessionId && autoCleanup) {
        endSession();
      }
    };
  }, [currentSessionId, autoCleanup]);

  return {
    currentSessionId,
    isMonitoring,
    startSession,
    endSession,
    setIsMonitoring
  };
};


================================================
FILE: src/features/livekit/hooks/useTranscriptManager.ts
================================================
import { useState, useCallback, useEffect, useRef } from 'react';
import { Tables } from '@/integrations/supabase/types';

export interface TranscriptSentence {
  id: string;
  text: string;
  translation: string | null;
  timestamp: string;
  language: string;
  isNew?: boolean;
}

interface UseTranscriptManagerProps {
  maxSentences?: number;
  onNewTranscript?: (sentence: TranscriptSentence) => void;
}

export const useTranscriptManager = ({ 
  maxSentences = 50, 
  onNewTranscript 
}: UseTranscriptManagerProps = {}) => {
  const [sentences, setSentences] = useState<TranscriptSentence[]>([]);
  const [isReceivingTranscripts, setIsReceivingTranscripts] = useState(false);
  const lastTranscriptRef = useRef<string>('');

  const addTranscript = useCallback((transcript: Tables<'transcripts'>) => {
    const sentence: TranscriptSentence = {
      id: transcript.id,
      text: transcript.text || '',
      translation: transcript.translation || null,
      timestamp: transcript.created_at || new Date().toISOString(),
      language: transcript.language || 'unknown',
      isNew: true
    };

    setSentences(prev => {
      const newSentences = [...prev, sentence];
      // Keep only the last N sentences
      if (newSentences.length > maxSentences) {
        return newSentences.slice(-maxSentences);
      }
      return newSentences;
    });

    lastTranscriptRef.current = sentence.text;
    onNewTranscript?.(sentence);
    setIsReceivingTranscripts(true);

    // Remove the "new" flag after animation
    setTimeout(() => {
      setSentences(prev => 
        prev.map(s => s.id === sentence.id ? { ...s, isNew: false } : s)
      );
    }, 500);
  }, [maxSentences, onNewTranscript]);

  const updateTranslation = useCallback((transcriptId: string, translation: string) => {
    setSentences(prev => 
      prev.map(s => s.id === transcriptId ? { ...s, translation } : s)
    );
  }, []);

  const clearTranscripts = useCallback(() => {
    setSentences([]);
    lastTranscriptRef.current = '';
    setIsReceivingTranscripts(false);
  }, []);

  const getLastTranscript = useCallback(() => {
    return sentences[sentences.length - 1] || null;
  }, [sentences]);

  // Reset receiving status after inactivity
  useEffect(() => {
    let timeout: NodeJS.Timeout;
    if (isReceivingTranscripts) {
      timeout = setTimeout(() => {
        setIsReceivingTranscripts(false);
      }, 5000);
    }
    return () => clearTimeout(timeout);
  }, [isReceivingTranscripts, sentences]);

  return {
    sentences,
    isReceivingTranscripts,
    addTranscript,
    updateTranslation,
    clearTranscripts,
    getLastTranscript,
    lastTranscriptText: lastTranscriptRef.current
  };
};


================================================
FILE: src/features/mosque/components/MosqueAdminDashboard.tsx
================================================
import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from '@/components/ui/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Plus, Loader2, Play, Building, Activity, AlertCircle } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import LiveMonitor from '@/features/livekit/components/LiveMonitor';

// Import new hooks
import { useRoomManagement } from '@/features/dashboard/hooks/useRoomManagement';
import { useMosqueData } from '@/features/dashboard/hooks/useMosqueData';
import { usePromptTemplates } from '@/features/dashboard/hooks/usePromptTemplates';

// Import form components
import RoomForm from '@/features/dashboard/components/RoomForm';
import EditRoomForm from '@/features/dashboard/components/EditRoomForm';

// Import table/grid components
import RoomsGrid from '@/features/dashboard/components/RoomsGrid';

// Import optimized components
import StatsHeader from '@/features/dashboard/components/StatsHeader';
import EmptyMonitorState from '@/features/dashboard/components/EmptyMonitorState';

import { useRoomStatusMonitor } from '@/hooks/useRoomStatusMonitor';
import { 
  DEFAULT_FORM_VALUES, 
  LANGUAGE_OPTIONS, 
  STATUS_STYLES, 
  SLIDER_CONFIG, 
  WEBSOCKET_URL, 
  STORAGE_KEYS, 
  TABS 
} from '@/utils/constants';
import { 
  generateLivekitRoomName, 
  generateRoomId, 
  getFromSessionStorage, 
  saveToSessionStorage
} from '@/utils/roomHelpers';

type Room = Tables<'rooms'>;
type Mosque = Tables<'Mosque'>;
// Room templates table doesn't exist in database schema

const roomSchema = z.object({
  title: z.string().min(2).max(200),
  transcription_language: z.string().min(1),
  translation_language: z.string().min(1),
  max_delay: z.number().min(1.0).max(5.0),
  punctuation_sensitivity: z.number().min(0.0).max(1.0),
  context_window_size: z.number().min(3).max(20),
  prompt_template_id: z.string().optional(),
});

type RoomFormData = z.infer<typeof roomSchema>;

interface MosqueAdminDashboardProps {
  userProfile: {
    mosque_id: number;
  };
}

const MosqueAdminDashboard = ({ userProfile }: MosqueAdminDashboardProps) => {
  const { toast } = useToast();
  const { t } = useTranslation();
  const navigate = useNavigate();
  const isUnloadingRef = useRef(false);
  
  // Use custom hooks for data management
  const { 
    rooms, 
    loading: roomsLoading, 
    error: roomsError,
    deleteRoom,
    updateRoom,
    refetch: refetchRooms
  } = useRoomManagement({ mosqueId: userProfile.mosque_id });
  
  const { 
    mosque, 
    loading: mosqueLoading, 
    error: mosqueError 
  } = useMosqueData({ mosqueId: userProfile.mosque_id });
  
  const { 
    promptTemplates,
    loading: templatesLoading, 
    error: templatesError 
  } = usePromptTemplates({ mosqueId: userProfile.mosque_id });
  
  // Combine loading and error states
  const loading = roomsLoading || mosqueLoading || templatesLoading;
  const error = roomsError || mosqueError || templatesError;
  
  // Local UI state only
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [editingRoom, setEditingRoom] = useState<Room | null>(null);
  
  // Persistent state that survives tab switches and page focus changes
  const [activeTab, setActiveTab] = useState<string>(() => 
    getFromSessionStorage(STORAGE_KEYS.activeTab, TABS.management)
  );
  
  const [monitoringRoom, setMonitoringRoom] = useState<Room | null>(() => 
    getFromSessionStorage<Room | null>(STORAGE_KEYS.monitoringRoom, null)
  );
  
  
  // Room status monitoring hook
  const { status: roomStatus, loading: statusLoading, error: statusError, refresh: refreshRoomStatus } = useRoomStatusMonitor({
    mosqueId: userProfile.mosque_id,
    enabled: true
  });
  
  // Memoize the monitoring room to prevent LiveMonitor from unmounting on unrelated updates
  const stableMonitoringRoom = useMemo(() => {
    if (!monitoringRoom) return null;
    
    // Always ensure we have the complete room data
    // Try to find the latest version of the room with all its data
    const currentRoom = rooms.find(r => r.id === monitoringRoom.id);
    
    // If found in rooms array, use the latest data
    if (currentRoom) {
      // Log if critical fields are different
      if (currentRoom.Livekit_room_name !== monitoringRoom.Livekit_room_name ||
          currentRoom.status !== monitoringRoom.status ||
          currentRoom.Title !== monitoringRoom.Title) {
        }
      return currentRoom;
    }
    
    // Return the existing monitoringRoom if not found in rooms array
    return monitoringRoom;
  }, [monitoringRoom?.id, rooms]); // Depend on room ID only to reduce unnecessary recalculations

  const form = useForm<RoomFormData>({
    resolver: zodResolver(roomSchema),
    defaultValues: DEFAULT_FORM_VALUES,
  });

  const editForm = useForm<RoomFormData>({
    resolver: zodResolver(roomSchema),
    defaultValues: DEFAULT_FORM_VALUES,
  });

  const onSubmit = async (data: RoomFormData) => {
    setIsCreating(true);
    try {
      // Generate hierarchical LiveKit room name for multi-tenancy
      const livekitRoomName = generateLivekitRoomName(userProfile.mosque_id, data.title);
      const roomId = generateRoomId();
      
      // Step 1: Create room in database
      const roomData = {
        Title: data.title,
        mosque_id: userProfile.mosque_id,
        status: 'pending',
        transcription_language: data.transcription_language,
        translation__language: data.translation_language,
        max_delay: data.max_delay,
        punctuation_sensitivity: data.punctuation_sensitivity,
        context_window_size: data.context_window_size,
        Livekit_room_name: livekitRoomName,
        id: roomId,
        prompt_template_id: data.prompt_template_id === 'system-default' ? null : data.prompt_template_id,
        speechmatics_domain: data.speechmatics_domain || 'broadcast'
      };
      
      const { error } = await supabase
        .from('rooms')
        .insert(roomData as any);

      if (error) throw error;

      // Step 2: Create actual LiveKit room and activate it
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token) {
        throw new Error(t('technical.errors.noAuthSession'));
      }

      // Use Supabase URL from the client configuration
      const createRoomResponse = await fetch(
        `https://bpsahvbdlkzemwjdgxmq.supabase.co/functions/v1/create-livekit-room`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            roomName: livekitRoomName,
            roomId: roomId
          }),
        }
      );

      if (!createRoomResponse.ok) {
        let errorMessage = 'Failed to create LiveKit room';
        let errorDetails = '';
        try {
          const errorText = await createRoomResponse.text();
          try {
            const errorData = JSON.parse(errorText);
            errorMessage = errorData.error || errorMessage;
          } catch {
            errorDetails = errorText;
          }
        } catch {
          // Use default error message
        }
        throw new Error(errorMessage);
      }
      
      // LiveKit room created successfully, now update status to active
      const { error: updateError } = await supabase
        .from('rooms')
        .update({ status: 'active' })
        .eq('id', roomId);
        
      if (updateError) {
        throw updateError;
      }
      
      form.reset();
      setShowRoomForm(false);
      
      // Refresh data to show updated status
      await refetchRooms();
      
      toast({
        title: t('common.success'),
        description: t('mosqueAdmin.rooms.roomCreated').replace('{title}', data.title),
      });
      
      // Find the newly created room from the database
      const { data: newRoomData } = await supabase
        .from('rooms')
        .select('*')
        .eq('id', roomId)
        .single();
      
      if (newRoomData) {
        // Verify room has all required fields before monitoring
        if (!newRoomData.id || !newRoomData.Livekit_room_name) {
          toast({
            title: t('common.error'),
            description: 'Room creation incomplete, please try again',
            variant: 'destructive'
          });
          return;
        }
        
        // Automatically switch to monitor tab with the new room
        setMonitoringRoom(newRoomData);
        setActiveTab(TABS.monitor);
      } else {
        }
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : t('mosqueAdmin.rooms.roomFailed'),
        variant: "destructive",
      });
    } finally {
      setIsCreating(false);
    }
  };



  // Persist activeTab to sessionStorage
  useEffect(() => {
    sessionStorage.setItem('mosque-dashboard-active-tab', activeTab);
  }, [activeTab]);

  // Persist monitoringRoom to sessionStorage
  useEffect(() => {
    if (monitoringRoom) {
      sessionStorage.setItem('mosque-dashboard-monitoring-room', JSON.stringify(monitoringRoom));
    } else {
      sessionStorage.removeItem('mosque-dashboard-monitoring-room');
    }
  }, [monitoringRoom]);

  // Browser event protection - simplified, no state restoration on visibility
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (monitoringRoom && activeTab === 'monitor') {
        e.preventDefault();
        e.returnValue = t('dialogs.browserWarning');
        return e.returnValue;
      }
      isUnloadingRef.current = true;
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [monitoringRoom, activeTab]);

  // Define all callbacks before conditional returns to follow React hooks rules
  const handleMonitorRoom = useCallback((room: Room) => {
    // Validate room data before setting
    if (!room.id) {
      toast({
        title: t('common.error'),
        description: 'Invalid room data',
        variant: 'destructive'
      });
      return;
    }
    
    setMonitoringRoom(room);
    setActiveTab(TABS.monitor);
    // Immediately persist state to prevent loss on tab switches
    saveToSessionStorage(STORAGE_KEYS.monitoringRoom, room);
    saveToSessionStorage(STORAGE_KEYS.activeTab, TABS.monitor);
  }, [t, toast]);

  const handleStopMonitoring = useCallback(() => {
    setMonitoringRoom(null);
    setActiveTab(TABS.management);
    // Clean up stored state
    sessionStorage.removeItem(STORAGE_KEYS.monitoringRoom);
    saveToSessionStorage(STORAGE_KEYS.activeTab, TABS.management);
  }, []);

  const handleDeleteRoom = useCallback(async (room: Room) => {
    // The deleteRoom function from the hook already handles confirmation and toast notifications
    await deleteRoom(room);
  }, [deleteRoom]);

  const handleEditRoom = useCallback((room: Room) => {
    setEditingRoom(room);
    editForm.reset({
      title: room.Title || DEFAULT_FORM_VALUES.title,
      transcription_language: room.transcription_language || DEFAULT_FORM_VALUES.transcription_language,
      translation_language: room.translation__language || DEFAULT_FORM_VALUES.translation_language,
      max_delay: room.max_delay || DEFAULT_FORM_VALUES.max_delay,
      punctuation_sensitivity: room.punctuation_sensitivity || DEFAULT_FORM_VALUES.punctuation_sensitivity,
      context_window_size: room.context_window_size || DEFAULT_FORM_VALUES.context_window_size,
      prompt_template_id: room.prompt_template_id || 'system-default',
      speechmatics_domain: room.speechmatics_domain || DEFAULT_FORM_VALUES.speechmatics_domain,
    });
    setShowEditDialog(true);
  }, [editForm]);

  if (loading) {
    return (
      <main className="container mx-auto px-6 py-8">
        <div className="flex items-center justify-center py-8">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="ml-2 text-muted-foreground">{t('dashboard.loadingDashboard')}</span>
        </div>
      </main>
    );
  }

  if (error) {
    return (
      <main className="container mx-auto px-6 py-8">
        <div className="text-center py-8">
          <p className="text-destructive">{error instanceof Error ? error.message : String(error)}</p>
          <Button variant="outline" onClick={refetchRooms} className="mt-4">
            {t('common.tryAgain')}
          </Button>
        </div>
      </main>
    );
  }

  const handleUpdateRoom = async (data: RoomFormData) => {
    if (!editingRoom) return;

    try {
      setIsCreating(true);

      // Only include prompt_template_id if it was explicitly changed
      const updates: any = {
        Title: data.title,
        transcription_language: data.transcription_language,
        translation__language: data.translation_language,
        max_delay: data.max_delay,
        punctuation_sensitivity: data.punctuation_sensitivity,
        context_window_size: data.context_window_size,
        speechmatics_domain: data.speechmatics_domain || 'broadcast',
      };

      // Only update prompt_template_id if it's different from 'system-default'
      if (data.prompt_template_id && data.prompt_template_id !== 'system-default') {
        updates.prompt_template_id = data.prompt_template_id;
      } else if (data.prompt_template_id === 'system-default') {
        updates.prompt_template_id = null;
      }
      // If undefined, don't include it in updates (preserves existing value)

      const success = await updateRoom(editingRoom.id, updates);

      if (!success) throw new Error('Failed to update room');
      
      setShowEditDialog(false);
      setEditingRoom(null);
      editForm.reset();
      setIsCreating(false);
      
      toast({
        title: t('toast.success.updated'),
        description: t('mosqueAdmin.rooms.roomUpdated'),
      });
    } catch (error) {
      setIsCreating(false);
      toast({
        title: t('toast.error.generic'),
        description: t('mosqueAdmin.rooms.roomUpdateFailed'),
        variant: 'destructive',
      });
    }
  };

  // handleStatusChange function removed - room status is now read-only
  // Status updates automatically based on active sessions
  // const handleStatusChange = async (roomId: number, newStatus: string) => {
  //   try {
  //     const { error } = await supabase
  //       .from('rooms')
  //       .update({ status: newStatus })
  //       .eq('id', roomId);

  //     if (error) throw error;

  //     toast({
  //       title: t('common.success'),
  //       description: t('mosqueAdmin.rooms.statusUpdated'),
  //     });

  //     // Refresh data to show updated status
  //     await fetchData();
  //     await refreshRoomStatus();
  //   } catch (err) {
  //     toast({
  //       title: t('common.error'),
  //       description: err instanceof Error ? err.message : t('mosqueAdmin.rooms.statusUpdateFailed'),
  //       variant: "destructive",
  //     });
  //   }
  // };


  return (
    <main className="w-full -mt-6">

      {/* Tabs Navigation */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <div className="flex justify-center pt-0 mt-0 bg-card dark:bg-transparent">
          <TabsList className="grid grid-cols-2 h-10 w-full max-w-md mt-0 bg-[#F0F4F9] dark:bg-[#181818]">
            <TabsTrigger value={TABS.management} className="flex items-center gap-2 data-[state=active]:bg-tab-active data-[state=active]:text-tab-active-foreground data-[state=inactive]:bg-card dark:data-[state=inactive]:bg-[#181818] transition-colors">
              <Building className="h-4 w-4" />
              {t('mosqueAdmin.tabs.roomManagement')}
            </TabsTrigger>
            <TabsTrigger value={TABS.monitor} className="flex items-center gap-2 data-[state=active]:bg-tab-active data-[state=active]:text-tab-active-foreground data-[state=inactive]:bg-card dark:data-[state=inactive]:bg-[#181818] transition-colors">
              <Activity className="h-4 w-4" />
              {t('mosqueAdmin.tabs.liveMonitor')}
            </TabsTrigger>
          </TabsList>
        </div>

        <TabsContent value={TABS.management} className="w-full space-y-4">
          {/* Room Status Monitoring Error */}
          {statusError && (
            <Card className="border-destructive">
              <CardContent className="pt-6">
                <div className="flex items-center gap-2 text-destructive">
                  <AlertCircle className="h-4 w-4" />
                  <span>{t('mosqueAdmin.stats.statusMonitorError')}: {statusError}</span>
                  <Button variant="outline" size="sm" onClick={refreshRoomStatus} className="ml-auto">
                    {t('common.retry')}
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Unified Room Header with Inline Stats */}
          <StatsHeader 
            mosqueName={mosque?.name}
            totalRooms={roomStatus.totalRooms}
            activeRooms={roomStatus.activeRooms}
            emptyRooms={roomStatus.emptyRooms}
            loading={statusLoading}
            showRoomForm={showRoomForm}
            onToggleRoomForm={() => setShowRoomForm(!showRoomForm)}
            mosqueId={userProfile.mosque_id}
            onRefresh={refreshRoomStatus}
          />

          {/* Room Form */}
          <div className="relative z-10">
            <RoomForm 
              form={form}
              onSubmit={onSubmit}
              isCreating={isCreating}
              promptTemplates={promptTemplates}
              showAdvanced={showAdvanced}
              setShowAdvanced={setShowAdvanced}
              showRoomForm={showRoomForm}
              onCancel={() => setShowRoomForm(false)}
            />
          </div>
          
          {/* Rooms Grid */}
          <div className="space-y-4">
            <h2 className="text-xl font-bold font-poppins lowercase flex items-center gap-2" style={{ letterSpacing: '-0.058em' }}>
              <Play className="h-5 w-5" />
              {t('mosqueAdmin.rooms.manageRooms')}
            </h2>
            <RoomsGrid 
              rooms={rooms}
              onMonitorRoom={handleMonitorRoom}
              onEditRoom={handleEditRoom}
              onDeleteRoom={handleDeleteRoom}
              onCreateRoom={() => setShowRoomForm(true)}
            />
          </div>

         </TabsContent>

          <TabsContent value={TABS.monitor} className="w-full mt-4">
            {stableMonitoringRoom ? (
             <div className="w-full">
               {/* Debug logging - hidden from rendering */}
               <LiveMonitor 
                 key={`monitor-${stableMonitoringRoom.id}`}
                 room={stableMonitoringRoom} 
                 mosque_id={userProfile.mosque_id}
                 websocketUrl={WEBSOCKET_URL}
                 onStopMonitoring={handleStopMonitoring}
               />
             </div>
           ) : (
             <EmptyMonitorState onGoToManagement={() => setActiveTab(TABS.management)} />
          )}
        </TabsContent>

        {/* Edit Room Dialog */}
        <EditRoomForm 
          editForm={editForm}
          editingRoom={editingRoom}
          showEditDialog={showEditDialog}
          setShowEditDialog={setShowEditDialog}
          handleUpdateRoom={handleUpdateRoom}
          promptTemplates={promptTemplates}
        />

      </Tabs>
    </main>
  );
};

export default MosqueAdminDashboard;


================================================
FILE: src/features/mosque/components/MosqueCreationWizard.tsx
================================================
import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Building, User, ChevronRight, ChevronLeft, Loader2, Check, Copy, CreditCard } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

const mosqueCreationSchema = z.object({
  // Basic Info
  mosqueName: z.string().min(2, 'Mosque name must be at least 2 characters').max(100),
  subdomain: z.string().min(2, 'Subdomain must be at least 2 characters').regex(/^[a-z0-9-]+$/, 'Subdomain can only contain lowercase letters, numbers, and hyphens'),
  description: z.string().optional(),
  
  // Billing Package
  packageSlug: z.string().default('professional'),
  
  // Contact Info
  contactEmail: z.string().email('Invalid email address').optional(),
  contactPhone: z.string().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  country: z.string().optional(),
  postalCode: z.string().optional(),
  timezone: z.string().default('UTC'),
});

type MosqueCreationData = z.infer<typeof mosqueCreationSchema>;

interface MosqueCreationWizardProps {
  onSuccess?: () => void;
  onCancel?: () => void;
}

const timezones = [
  { value: 'UTC', label: 'UTC (Coordinated Universal Time)' },
  { value: 'Europe/Amsterdam', label: 'Amsterdam (CET/CEST)' },
  { value: 'Europe/London', label: 'London (GMT/BST)' },
  { value: 'America/New_York', label: 'New York (EST/EDT)' },
  { value: 'America/Chicago', label: 'Chicago (CST/CDT)' },
  { value: 'America/Los_Angeles', label: 'Los Angeles (PST/PDT)' },
  { value: 'Asia/Dubai', label: 'Dubai (GST)' },
  { value: 'Asia/Riyadh', label: 'Riyadh (AST)' },
  { value: 'Asia/Karachi', label: 'Karachi (PKT)' },
  { value: 'Asia/Jakarta', label: 'Jakarta (WIB)' },
];

const languages = [
  { value: 'ar', label: 'Arabic', flag: '🇸🇦' },
  { value: 'en', label: 'English', flag: '🇬🇧' },
  { value: 'nl', label: 'Dutch', flag: '🇳🇱' },
  { value: 'fr', label: 'French', flag: '🇫🇷' },
  { value: 'de', label: 'German', flag: '🇩🇪' },
  { value: 'es', label: 'Spanish', flag: '🇪🇸' },
  { value: 'tr', label: 'Turkish', flag: '🇹🇷' },
  { value: 'ur', label: 'Urdu', flag: '🇵🇰' },
  { value: 'id', label: 'Indonesian', flag: '🇮🇩' },
];

export default function MosqueCreationWizard({ onSuccess, onCancel }: MosqueCreationWizardProps) {
  const { toast } = useToast();
  const { t } = useTranslation();
  const [currentStep, setCurrentStep] = useState(0);
  const [isCreating, setIsCreating] = useState(false);
  const [createdMosque, setCreatedMosque] = useState<any>(null);
  const [generatedPassword, setGeneratedPassword] = useState<string | null>(null);
  const [billingPackages, setBillingPackages] = useState<any[]>([]);

  const form = useForm<MosqueCreationData>({
    resolver: zodResolver(mosqueCreationSchema),
    defaultValues: {
      mosqueName: '',
      subdomain: '',
      description: '',
      packageSlug: 'professional',
      contactEmail: '',
      contactPhone: '',
      address: '',
      city: '',
      country: '',
      postalCode: '',
      timezone: 'UTC',
    },
  });

  // Fetch available billing packages
  useEffect(() => {
    const fetchPackages = async () => {
      const { data, error } = await supabase
        .from('billing_packages')
        .select('*')
        .eq('is_active', true)
        .order('monthly_price', { ascending: true });
      
      if (data && !error) {
        setBillingPackages(data);
      }
    };
    fetchPackages();
  }, []);

  const steps = [
    { title: 'Basic Information', icon: Building },
  ];
  
  const generateSubdomain = (name: string): string => {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  };

  const handleMosqueNameChange = (value: string) => {
    form.setValue('mosqueName', value);
    if (!form.getValues('subdomain') || form.getValues('subdomain') === generateSubdomain(form.watch('mosqueName'))) {
      form.setValue('subdomain', generateSubdomain(value));
    }
  };


  const onSubmit = async (data: MosqueCreationData) => {
    setIsCreating(true);
    try {
      // Generate a random ID for the mosque (matching existing pattern)
      const mosqueId = Math.floor(Math.random() * 1000000);
      
      // Get the package UUID from the slug
      let packageId = null;
      if (data.packageSlug) {
        const { data: packageData, error: packageError } = await supabase
          .from('billing_packages')
          .select('id')
          .eq('slug', data.packageSlug)
          .single();
        
        if (packageError) {
          console.warn('Could not find package with slug:', data.packageSlug);
        } else {
          packageId = packageData?.id;
        }
      }
      
      // If no package found, get the default professional package
      if (!packageId) {
        const { data: defaultPackage } = await supabase
          .from('billing_packages')
          .select('id')
          .eq('slug', 'professional')
          .single();
        
        packageId = defaultPackage?.id;
      }
      
      // Simple approach: Just create the mosque first
      const { data: mosque, error: mosqueError } = await supabase
        .from('Mosque')
        .insert({
          id: mosqueId,
          name: data.mosqueName,
          Subdomain: data.subdomain,
          description: data.description,
          contact_email: data.contactEmail,
          contact_phone: data.contactPhone,
          address: data.address,
          city: data.city,
          country: data.country,
          postal_code: data.postalCode,
          timezone: data.timezone || 'UTC',
          primary_language: 'ar',
          translation_languages: ['en', 'nl'],
          enable_public_display: true,
          default_max_delay: 2.0,
          default_punctuation_sensitivity: 0.5,
          default_context_window_size: 3,
          is_active: true,
          package_id: packageId
        })
        .select()
        .single();

      if (mosqueError) {
        throw new Error(`Failed to create mosque: ${mosqueError.message}`);
      }

      // For now, just create the mosque without the admin user
      // The admin can be added manually later
      setCreatedMosque({
        ...mosque,
        package_name: data.packageSlug || 'professional'
      });
      
      toast({
        title: t('common.success'),
        description: `Mosque "${data.mosqueName}" created successfully!`,
      });

      // Move to success step
      setCurrentStep(steps.length);
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : 'Failed to create mosque',
        variant: "destructive",
      });
    } finally {
      setIsCreating(false);
    }
  };

  const generateSecurePassword = (): string => {
    const length = 16;
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    let password = '';
    
    // Ensure at least one of each type
    password += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)];
    password += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
    password += '0123456789'[Math.floor(Math.random() * 10)];
    password += '!@#$%^&*'[Math.floor(Math.random() * 8)];
    
    // Fill the rest randomly
    for (let i = password.length; i < length; i++) {
      password += charset[Math.floor(Math.random() * charset.length)];
    }
    
    // Shuffle the password
    return password.split('').sort(() => 0.5 - Math.random()).join('');
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast({
      title: 'Copied',
      description: 'Copied to clipboard',
    });
  };

  if (currentStep >= steps.length) {
    // Success step
    return (
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <div className="flex items-center gap-2 text-green-600">
            <Check className="h-6 w-6" />
            <CardTitle>{t('mosqueCreation.successTitle')}</CardTitle>
          </div>
          <CardDescription>
            {t('mosqueCreation.successDescription')}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div>
              <h3 className="font-semibold mb-2">{t('mosqueCreation.mosqueDetails')}</h3>
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-muted-foreground">{t('mosqueCreation.nameLabel')}:</span>
                  <span className="font-medium">{createdMosque?.name}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">{t('mosqueCreation.subdomainLabel')}:</span>
                  <code className="bg-muted px-2 py-1 rounded">{createdMosque?.Subdomain}</code>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">{t('mosqueCreation.urlLabel')}:</span>
                  <span className="font-medium">https://{createdMosque?.Subdomain}.bayanplatform.com</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Billing Package:</span>
                  <Badge variant="secondary">{createdMosque?.package_name || 'professional'}</Badge>
                </div>
              </div>
            </div>

            <Alert>
              <AlertDescription>
                <p className="text-sm text-muted-foreground">
                  {t('mosqueCreation.successAlert')}
                </p>
              </AlertDescription>
            </Alert>
          </div>

          <div className="flex justify-end">
            <Button onClick={onSuccess}>
              {t('common.done')}
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full max-w-2xl">
      <CardHeader>
        <CardTitle>{t('mosqueCreation.title')}</CardTitle>
        <CardDescription>
          {t('mosqueCreation.description')}
        </CardDescription>
      </CardHeader>
      <CardContent>

        <Form {...form}>
          <form 
            onSubmit={form.handleSubmit(onSubmit)} 
            className="space-y-6"
          >
            {/* Basic Information */}
            <div className="space-y-4">
                <FormField
                  control={form.control}
                  name="mosqueName"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueCreation.mosqueNameLabel')} *</FormLabel>
                      <FormControl>
                        <Input
                          placeholder={t('mosqueCreation.mosqueNamePlaceholder')}
                          {...field}
                          onChange={(e) => handleMosqueNameChange(e.target.value)}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="subdomain"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueCreation.subdomainLabel')} *</FormLabel>
                      <FormControl>
                        <div className="flex items-center gap-2">
                          <Input
                            placeholder={t('mosqueCreation.subdomainPlaceholder')}
                            {...field}
                          />
                          <span className="text-sm text-muted-foreground">.bayanplatform.com</span>
                        </div>
                      </FormControl>
                      <FormDescription>
                        {t('mosqueCreation.subdomainDescription')}
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueCreation.descriptionLabel')}</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder={t('mosqueCreation.descriptionPlaceholder')}
                          className="resize-none"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="city"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('mosqueCreation.cityLabel')}</FormLabel>
                        <FormControl>
                          <Input placeholder={t('mosqueCreation.cityPlaceholder')} {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="country"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('mosqueCreation.countryLabel')}</FormLabel>
                        <FormControl>
                          <Input placeholder={t('mosqueCreation.countryPlaceholder')} {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="timezone"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('mosqueCreation.timezoneLabel')}</FormLabel>
                      <Select onValueChange={field.onChange} defaultValue={field.value}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder={t('mosqueCreation.timezonePlaceholder')} />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {timezones.map((tz) => (
                            <SelectItem key={tz.value} value={tz.value}>
                              {tz.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="contactEmail"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('mosqueCreation.contactEmailLabel')}</FormLabel>
                        <FormControl>
                          <Input
                            type="email"
                            placeholder={t('mosqueCreation.contactEmailPlaceholder')}
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="contactPhone"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('mosqueCreation.contactPhoneLabel')}</FormLabel>
                        <FormControl>
                          <Input
                            type="tel"
                            placeholder={t('mosqueCreation.contactPhonePlaceholder')}
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                {/* Billing Package Selection */}
                <FormField
                  control={form.control}
                  name="packageSlug"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>
                        <CreditCard className="inline-block h-4 w-4 mr-2" />
                        Billing Package *
                      </FormLabel>
                      <Select onValueChange={field.onChange} value={field.value}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Select a billing package" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {billingPackages.map((pkg) => (
                            <SelectItem key={pkg.slug} value={pkg.slug}>
                              <div className="flex items-center justify-between w-full">
                                <span>{pkg.name}</span>
                                <span className="text-sm text-muted-foreground ml-4">
                                  €{pkg.monthly_price}/month - {pkg.included_hours}h included
                                </span>
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormDescription>
                        Choose the billing package for this mosque. This can be changed later.
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
            </div>



            {/* Navigation buttons */}
            <div className="flex justify-between">
              <Button
                type="button"
                variant="outline"
                onClick={onCancel}
              >
                {t('common.cancel')}
              </Button>

              <Button type="submit" disabled={isCreating}>
                {isCreating ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    {t('mosqueCreation.creatingButton')}
                  </>
                ) : (
                  <>
                    <Check className="mr-2 h-4 w-4" />
                    {t('mosqueCreation.createButton')}
                  </>
                )}
              </Button>
            </div>
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}


================================================
FILE: src/features/mosque/components/MosqueUsersTable.tsx
================================================
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { UserCheck, Loader2, Users } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useImpersonation } from '@/hooks/useImpersonation';
import { useTranslation } from '@/hooks/useTranslation';

interface MosqueUser {
  user_id: string;
  email: string;
  mosque_name: string;
  is_super_admin: boolean;
}

interface MosqueUsersTableProps {
  mosqueId: number;
  mosqueName: string;
}

const MosqueUsersTable = ({ mosqueId, mosqueName }: MosqueUsersTableProps) => {
  const [users, setUsers] = useState<MosqueUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [impersonatingUserId, setImpersonatingUserId] = useState<string | null>(null);
  const { toast } = useToast();
  const { startImpersonation } = useImpersonation();
  const { t } = useTranslation();

  const fetchMosqueUsers = async () => {
    setLoading(true);
    try {
      const { data, error } = await supabase.rpc('get_mosque_users', {
        mosque_id_param: mosqueId
      });

      if (error) throw error;
      
      // Filter out super admins from the list
      const regularUsers = data?.filter(user => !user.is_super_admin) || [];
      setUsers(regularUsers);
    } catch (err) {
      toast({
        title: t('common.error'),
        description: err instanceof Error ? err.message : t('technical.errors.fetchUsersFailed'),
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const handleImpersonate = async (user: MosqueUser) => {
    setImpersonatingUserId(user.user_id);
    try {
      await startImpersonation(user.user_id, user.email);
    } catch (error) {
      } finally {
      setImpersonatingUserId(null);
    }
  };

  useEffect(() => {
    fetchMosqueUsers();
  }, [mosqueId]);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Users className="h-5 w-5" />
          {t('users.mosqueUsers').replace('{mosqueName}', mosqueName)}
        </CardTitle>
      </CardHeader>
      <CardContent>
        {loading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <span className="ml-2 text-muted-foreground">{t('users.loadingUsers')}</span>
          </div>
        ) : users.length === 0 ? (
          <div className="text-center py-8">
            <Users className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
            <h3 className="text-lg font-semibold mb-2">{t('users.noUsersFound')}</h3>
            <p className="text-muted-foreground">
              {t('users.noUsersDescription')}
            </p>
          </div>
        ) : (
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>{t('users.email')}</TableHead>
                <TableHead>{t('users.actions')}</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {users.map((user) => (
                <TableRow key={user.user_id}>
                  <TableCell className="font-medium">{user.email}</TableCell>
                  <TableCell>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleImpersonate(user)}
                      disabled={impersonatingUserId === user.user_id}
                    >
                      {impersonatingUserId === user.user_id ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          {t('users.starting')}
                        </>
                      ) : (
                        <>
                          <UserCheck className="mr-2 h-4 w-4" />
                          {t('users.loginAs')}
                        </>
                      )}
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        )}
      </CardContent>
    </Card>
  );
};

export default MosqueUsersTable;


================================================
FILE: src/features/mosque/components/PromptTemplateManager.tsx
================================================
import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import { Plus, Edit, Trash2, Eye, Loader2 } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

type PromptTemplate = {
  id: string;
  name: string;
  description: string | null;
  content_type: string;
  prompt_template: string;
  template_variables: any;
  mosque_id: number | null;
  is_default: boolean;
  is_active: boolean;
  created_at: string;
};

const promptTemplateSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  description: z.string().optional(),
  content_type: z.string().min(1, 'Content type is required'),
  prompt_template: z.string().min(10, 'Prompt template must be at least 10 characters'),
  template_variables: z.object({
    style: z.string().optional(),
    context: z.string().optional(),
    terminology: z.string().optional(),
    audience: z.string().optional(),
    preserve_terms: z.array(z.string()).optional(),
  }).optional(),
  is_default: z.boolean().default(false),
});

type PromptTemplateFormData = z.infer<typeof promptTemplateSchema>;

const CONTENT_TYPES = [
  { value: 'sermon', label: 'Sermon' },
  { value: 'announcement', label: 'Announcement' },
  { value: 'lecture', label: 'Lecture' },
  { value: 'dua', label: 'Dua' },
];

const STYLE_OPTIONS = [
  { value: 'formal', label: 'Formal' },
  { value: 'casual', label: 'Casual' },
  { value: 'youth', label: 'Youth' },
  { value: 'academic', label: 'Academic' },
];

const CONTEXT_OPTIONS = [
  { value: 'friday', label: 'Friday' },
  { value: 'eid', label: 'Eid' },
  { value: 'ramadan', label: 'Ramadan' },
  { value: 'special', label: 'Special' },
];

const TERMINOLOGY_OPTIONS = [
  { value: 'preserve', label: 'Preserve' },
  { value: 'translate', label: 'Translate' },
  { value: 'simplify', label: 'Simplify' },
];

const AUDIENCE_OPTIONS = [
  { value: 'general', label: 'General' },
  { value: 'children', label: 'Children' },
  { value: 'scholars', label: 'Scholars' },
];

// Dialect options removed - no longer needed

const DEFAULT_PRESERVE_TERMS = ['Allah', 'Salah', 'Zakat', 'Hajj', 'Umrah', 'Jummah', 'Ramadan', 'Eid'];

const PromptTemplateManager = () => {
  const { toast } = useToast();
  const { t } = useTranslation();
  const [templates, setTemplates] = useState<PromptTemplate[]>([]);
  const [loading, setLoading] = useState(true);
  const [isCreating, setIsCreating] = useState(false);
  const [editingTemplate, setEditingTemplate] = useState<PromptTemplate | null>(null);
  const [showForm, setShowForm] = useState(false);
  const [previewTemplate, setPreviewTemplate] = useState<PromptTemplate | null>(null);

  const form = useForm<PromptTemplateFormData>({
    resolver: zodResolver(promptTemplateSchema),
    defaultValues: {
      name: '',
      description: '',
      content_type: 'sermon',
      prompt_template: '',
      template_variables: {
        style: 'formal',
        context: 'friday',
        terminology: 'preserve',
        audience: 'general',
        preserve_terms: DEFAULT_PRESERVE_TERMS,
      },
      is_default: false,
    },
  });

  const fetchTemplates = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('prompt_templates' as any)
        .select('*')
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setTemplates((data as any) || []);
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to fetch prompt templates',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const generatePromptPreview = (template: PromptTemplate | PromptTemplateFormData) => {
    let preview = template.prompt_template;
    
    // Replace common variables with sample values
    preview = preview
      .replace(/\{source_language\}/g, 'Arabic')
      .replace(/\{target_language\}/g, 'Dutch')
      .replace(/\{content_type\}/g, template.content_type)
      .replace(/\{style\}/g, template.template_variables?.style || 'formal')
      .replace(/\{context\}/g, template.template_variables?.context || 'friday')
      .replace(/\{terminology\}/g, template.template_variables?.terminology || 'preserve')
      .replace(/\{audience\}/g, template.template_variables?.audience || 'general');

    return preview;
  };

  const onSubmit = async (data: PromptTemplateFormData) => {
    try {
      setIsCreating(true);
      
      const templateData = {
        name: data.name,
        description: data.description || null,
        content_type: data.content_type,
        prompt_template: data.prompt_template,
        template_variables: data.template_variables || {},
        mosque_id: null, // Super admin templates are global
        is_default: data.is_default,
        is_active: true,
      };

      if (editingTemplate) {
        const { error } = await supabase
          .from('prompt_templates' as any)
          .update(templateData)
          .eq('id', editingTemplate.id);

        if (error) throw error;

        toast({
          title: 'Success',
          description: 'Prompt template updated successfully',
        });
      } else {
        const { error } = await supabase
          .from('prompt_templates' as any)
          .insert([templateData]);

        if (error) throw error;

        toast({
          title: 'Success',
          description: 'Prompt template created successfully',
        });
      }

      form.reset();
      setShowForm(false);
      setEditingTemplate(null);
      fetchTemplates();
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to save prompt template',
        variant: 'destructive',
      });
    } finally {
      setIsCreating(false);
    }
  };

  const handleEdit = (template: PromptTemplate) => {
    setEditingTemplate(template);
    form.reset({
      name: template.name,
      description: template.description || '',
      content_type: template.content_type,
      prompt_template: template.prompt_template,
      template_variables: template.template_variables || {},
      is_default: template.is_default,
    });
    setShowForm(true);
  };

  const handleDelete = async (templateId: string, templateName: string) => {
    if (!confirm(`Are you sure you want to delete "${templateName}"?`)) {
      return;
    }

    try {
      const { error } = await supabase
        .from('prompt_templates' as any)
        .update({ is_active: false })
        .eq('id', templateId);

      if (error) throw error;

      toast({
        title: 'Success',
        description: 'Prompt template deleted successfully',
      });

      fetchTemplates();
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to delete prompt template',
        variant: 'destructive',
      });
    }
  };

  const handleNewTemplate = () => {
    setEditingTemplate(null);
    form.reset();
    setShowForm(true);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <span className="ml-2 text-muted-foreground">Loading prompt templates...</span>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-end">
        <Dialog open={showForm} onOpenChange={setShowForm}>
          <DialogTrigger asChild>
            <Button onClick={handleNewTemplate}>
              <Plus className="mr-2 h-4 w-4" />
              {t('promptTemplates.createTemplate')}
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle>
                {editingTemplate ? t('promptTemplates.editTitle') : t('promptTemplates.createTitle')}
              </DialogTitle>
            </DialogHeader>
            
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
                <div className="grid grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="name"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('promptTemplates.templateName')}</FormLabel>
                        <FormControl>
                          <Input placeholder={t('promptTemplates.templateNamePlaceholder')} {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  
                  <FormField
                    control={form.control}
                    name="content_type"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('promptTemplates.contentType')}</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder={t('promptTemplates.selectContentType')} />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {CONTENT_TYPES.map((type) => (
                              <SelectItem key={type.value} value={type.value}>
                                {t(`promptTemplates.contentTypes.${type.value}` as any)}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('promptTemplates.descriptionLabel')}</FormLabel>
                      <FormControl>
                        <Input placeholder={t('promptTemplates.descriptionPlaceholder')} {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-3 gap-4">
                  <FormField
                    control={form.control}
                    name="template_variables.style"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('promptTemplates.style')}</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {STYLE_OPTIONS.map((option) => (
                              <SelectItem key={option.value} value={option.value}>
                                {t(`promptTemplates.styleOptions.${option.value}` as any)}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="template_variables.context"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('promptTemplates.context')}</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {CONTEXT_OPTIONS.map((option) => (
                              <SelectItem key={option.value} value={option.value}>
                                {t(`promptTemplates.contextOptions.${option.value}` as any)}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="template_variables.terminology"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('promptTemplates.terminology')}</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {TERMINOLOGY_OPTIONS.map((option) => (
                              <SelectItem key={option.value} value={option.value}>
                                {t(`promptTemplates.terminologyOptions.${option.value}` as any)}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="template_variables.audience"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{t('promptTemplates.audience')}</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {AUDIENCE_OPTIONS.map((option) => (
                              <SelectItem key={option.value} value={option.value}>
                                {t(`promptTemplates.audienceOptions.${option.value}` as any)}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                </div>

                <FormField
                  control={form.control}
                  name="prompt_template"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>{t('promptTemplates.promptTemplate')}</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder={t('promptTemplates.promptPlaceholder')}
                          rows={6}
                          {...field}
                        />
                      </FormControl>
                      <p className="text-xs text-muted-foreground">
                        {t('promptTemplates.variablesHint')} {'{source_language}'}, {'{target_language}'}, {'{content_type}'}, {'{style}'}, {'{context}'}, {'{terminology}'}, {'{audience}'}
                      </p>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                {form.watch('prompt_template') && (
                  <div className="rounded-md border p-4 bg-muted">
                    <h4 className="font-medium text-sm mb-2">{t('promptTemplates.preview')}</h4>
                    <p className="text-sm text-muted-foreground whitespace-pre-wrap">
                      {generatePromptPreview(form.getValues())}
                    </p>
                  </div>
                )}

                <div className="flex justify-end gap-2">
                  <Button type="button" variant="outline" onClick={() => setShowForm(false)}>
                    {t('common.cancel')}
                  </Button>
                  <Button type="submit" disabled={isCreating}>
                    {isCreating && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                    {editingTemplate ? t('promptTemplates.updateButton') : t('promptTemplates.createButton')}
                  </Button>
                </div>
              </form>
            </Form>
          </DialogContent>
        </Dialog>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>{t('promptTemplates.title')} ({templates.length})</CardTitle>
        </CardHeader>
        <CardContent>
          {templates.length === 0 ? (
            <p className="text-center text-muted-foreground py-8">
              {t('promptTemplates.noTemplatesFound')}
            </p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>{t('promptTemplates.columns.name')}</TableHead>
                  <TableHead>{t('promptTemplates.columns.contentType')}</TableHead>
                  <TableHead>{t('promptTemplates.columns.style')}</TableHead>
                  <TableHead>{t('promptTemplates.columns.status')}</TableHead>
                  <TableHead>{t('promptTemplates.columns.created')}</TableHead>
                  <TableHead className="text-right">{t('common.actions')}</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {templates.map((template) => (
                  <TableRow key={template.id}>
                    <TableCell>
                      <div>
                        <div className="font-medium">{template.name}</div>
                        {template.description && (
                          <div className="text-sm text-muted-foreground">{template.description}</div>
                        )}
                      </div>
                    </TableCell>
                    <TableCell>
                      <Badge variant="outline">{t(`promptTemplates.contentTypes.${template.content_type}` as any)}</Badge>
                    </TableCell>
                    <TableCell>
                      <Badge variant="secondary">
                        {t(`promptTemplates.styleOptions.${template.template_variables?.style || 'default'}` as any, {
                          defaultValue: template.template_variables?.style || 'default'
                        })}
                      </Badge>
                    </TableCell>
                    <TableCell>
                      <div className="flex gap-1">
                        {template.is_default && (
                          <Badge variant="default">{t('promptTemplates.default')}</Badge>
                        )}
                        <Badge variant={template.is_active ? "default" : "secondary"}>
                          {template.is_active ? t('common.active') : t('common.inactive')}
                        </Badge>
                      </div>
                    </TableCell>
                    <TableCell className="text-sm text-muted-foreground">
                      {new Date(template.created_at).toLocaleDateString()}
                    </TableCell>
                    <TableCell className="text-right">
                      <div className="flex justify-end gap-2">
                        <Dialog>
                          <DialogTrigger asChild>
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() => setPreviewTemplate(template)}
                            >
                              <Eye className="h-4 w-4" />
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>{t('promptTemplates.previewTitle', { name: template.name })}</DialogTitle>
                            </DialogHeader>
                            <div className="space-y-4">
                              <div>
                                <h4 className="font-medium text-sm mb-2">{t('promptTemplates.generatedPrompt')}</h4>
                                <div className="rounded-md border p-4 bg-muted text-sm whitespace-pre-wrap">
                                  {generatePromptPreview(template)}
                                </div>
                              </div>
                            </div>
                          </DialogContent>
                        </Dialog>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleEdit(template)}
                        >
                          <Edit className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDelete(template.id, template.name)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default PromptTemplateManager;


================================================
FILE: src/features/mosque/components/RoomCodeManager.tsx
================================================
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { SecureToggle } from '@/components/ui/secure-toggle';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { Copy, Eye, Tv2 } from 'lucide-react';
import { Tables } from '@/integrations/supabase/types';
import { motion, AnimatePresence } from 'framer-motion';
import { useTranslation } from '@/hooks/useTranslation';

interface RoomCodeManagerProps {
  room: Tables<'rooms'>;
  onUpdate: (updatedRoom: Tables<'rooms'>) => void;
  className?: string;
}

const RoomCodeManager = ({ room, onUpdate, className }: RoomCodeManagerProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const [optimisticState, setOptimisticState] = useState(room.public_access_enabled || false);
  const { toast } = useToast();
  const { t } = useTranslation();

  const handleTogglePublicAccess = async () => {
    const newState = !optimisticState;
    const previousState = optimisticState;
    
    // Optimistic update
    setOptimisticState(newState);
    setIsLoading(true);
    
    try {
      const { data, error } = await supabase.rpc('toggle_room_public_access', {
        room_id_param: room.id
      });

      if (error) throw error;

      // Update parent with the new room state
      const updatedRoom = { ...room, public_access_enabled: data };
      onUpdate(updatedRoom);

      toast({
        title: t('roomCodeManager.updatedTitle'),
        description: data 
          ? t('roomCodeManager.enabledDescription').replace('{id}', room.id.toString())
          : t('roomCodeManager.disabledDescription').replace('{id}', room.id.toString()),
      });
    } catch (error) {
      // Rollback optimistic update on error
      setOptimisticState(previousState);
      toast({
        title: t('common.error'),
        description: t('roomCodeManager.updateFailed'),
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const copyRoomCode = () => {
    navigator.clipboard.writeText(room.id.toString());
    toast({
      title: t('roomCodeManager.copiedTitle'),
      description: t('roomCodeManager.copiedDescription'),
    });
  };

  const previewDisplay = () => {
    window.open(`/public-display?code=${room.id}`, '_blank');
  };

  return (
    <div className={`flex flex-col items-end gap-1 ${className}`}>
      <SecureToggle
        icon={Tv2}
        label="" // Hide label, icon is enough
        checked={optimisticState}
        onCheckedChange={handleTogglePublicAccess}
        isLoading={isLoading}
        color="data-[state=checked]:bg-blue-600"
      />
      
      <AnimatePresence mode="wait">
        {optimisticState && (
          <motion.div 
            initial={{ opacity: 0, scale: 0.95, height: 0 }}
            animate={{ opacity: 1, scale: 1, height: "auto" }}
            exit={{ opacity: 0, scale: 0.95, height: 0 }}
            transition={{ duration: 0.2, ease: "easeOut" }}
            className="overflow-hidden w-full"
          >
            <div className="flex items-center justify-end gap-1 mt-1">
              <motion.div 
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 0.1 }}
                className="px-1.5 py-0.5 bg-muted/50 rounded text-[10px] font-mono flex items-center gap-1"
              >
                <span className="text-muted-foreground">{t('roomCodeManager.codeLabel')}:</span>
                <span className="font-semibold">{room.id}</span>
              </motion.div>
              <Button
                variant="ghost"
                size="sm"
                onClick={copyRoomCode}
                className="h-5 w-5 p-0 hover:bg-muted/50 transition-colors"
                title={t('common.copy')}
              >
                <Copy className="h-2.5 w-2.5" />
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={previewDisplay}
                className="h-5 w-5 p-0 hover:bg-muted/50 transition-colors"
                title={t('common.preview')}
              >
                <Eye className="h-2.5 w-2.5" />
              </Button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default RoomCodeManager;


================================================
FILE: src/features/session/components/SessionHistory.tsx
================================================
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { CalendarIcon, Eye, Clock, MessageSquare, Search, Filter, Loader2, ArrowRight, Globe, Mic, CheckSquare, Square, Check, X } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { format } from 'date-fns';
import { useTranslation } from '@/hooks/useTranslation';
import { cn } from '@/lib/utils';
import { StyledHeader } from '@/components/ui/styled-headers';
import {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from '@/components/ui/pagination';

type RoomSession = Tables<'room_sessions'> & {
  rooms: {
    Title: string;
    transcription_language: string;
    translation__language: string;
  };
};

interface SessionHistoryProps {
  mosqueId: number;
}

const SessionHistory = ({ mosqueId }: SessionHistoryProps) => {
  const { toast } = useToast();
  const { t } = useTranslation();
  const [sessions, setSessions] = useState<RoomSession[]>([]);
  const [rooms, setRooms] = useState<Tables<'rooms'>[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedRoom, setSelectedRoom] = useState<string>('all');
  const [sortBy, setSortBy] = useState<'date' | 'duration' | 'transcripts'>('date');
  const [currentPage, setCurrentPage] = useState(1);
  const [editingSessionId, setEditingSessionId] = useState<string | null>(null);
  const [publicTitle, setPublicTitle] = useState<string>('');
  const itemsPerPage = 20;

  const fetchSessions = async () => {
    try {
      setLoading(true);
      
      // Fetch completed sessions with room details
      const { data: sessionsData, error: sessionsError } = await supabase
        .from('room_sessions')
        .select(`
          *,
          rooms (
            Title,
            transcription_language,
            translation__language
          )
        `)
        .eq('mosque_id', mosqueId)
        .eq('status', 'completed')
        .order('started_at', { ascending: false });

      if (sessionsError) throw sessionsError;

      setSessions(sessionsData || []);

      // Fetch all rooms for filter dropdown
      const { data: roomsData, error: roomsError } = await supabase
        .from('rooms')
        .select('*')
        .eq('mosque_id', mosqueId)
        .order('Title');

      if (roomsError) throw roomsError;

      setRooms(roomsData || []);
    } catch (err) {
      toast({
        title: t('common.error'),
        description: t('sessionHistory.loading'),
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchSessions();
  }, [mosqueId]);

  const handleViewSession = (sessionId: string) => {
    // Navigate to session replay page
    window.location.href = `/session/${sessionId}`;
  };

  // Toggle public visibility in database
  const handleTogglePublic = async (sessionId: string, currentIsPublic: boolean, currentTitle: string | null, e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card click
    
    if (!currentIsPublic) {
      // If making public, show the title input
      setEditingSessionId(sessionId);
      setPublicTitle(currentTitle || '');
    } else {
      // If making private, just toggle it off
      const { error } = await supabase
        .from('room_sessions')
        .update({ 
          is_public: false,
          public_title: null 
        })
        .eq('id', sessionId);

      if (error) {
        toast({
          title: t('common.error'),
          description: 'Failed to update public visibility',
          variant: "destructive",
        });
      } else {
        // Update local state
        setSessions(sessions.map(s => 
          s.id === sessionId ? { ...s, is_public: false, public_title: null } : s
        ));
        
        toast({
          title: 'Success',
          description: 'Session made private',
        });
      }
    }
  };

  // Save public title and make session public
  const handleSavePublicTitle = async (sessionId: string) => {
    if (!publicTitle.trim()) {
      toast({
        title: 'Error',
        description: 'Please enter a title for the public session',
        variant: "destructive",
      });
      return;
    }

    const { error } = await supabase
      .from('room_sessions')
      .update({ 
        is_public: true,
        public_title: publicTitle.trim()
      })
      .eq('id', sessionId);

    if (error) {
      toast({
        title: t('common.error'),
        description: 'Failed to update public visibility',
        variant: "destructive",
      });
    } else {
      // Update local state
      setSessions(sessions.map(s => 
        s.id === sessionId ? { ...s, is_public: true, public_title: publicTitle.trim() } : s
      ));
      
      setEditingSessionId(null);
      setPublicTitle('');
      
      toast({
        title: 'Success',
        description: 'Session made public with custom title',
      });
    }
  };

  // Cancel editing
  const handleCancelEdit = () => {
    setEditingSessionId(null);
    setPublicTitle('');
  };


  const filteredAndSortedSessions = sessions
    .filter(session => {
      const matchesSearch = searchTerm === '' || 
        session.rooms?.Title?.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesRoom = selectedRoom === 'all' || 
        session.room_id.toString() === selectedRoom;
      return matchesSearch && matchesRoom;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case 'date':
          return new Date(b.started_at).getTime() - new Date(a.started_at).getTime();
        case 'duration':
          return (b.duration_minutes || 0) - (a.duration_minutes || 0);
        case 'transcripts':
          return b.transcript_count - a.transcript_count;
        default:
          return 0;
      }
    });

  const formatDuration = (minutes: number | null) => {
    if (minutes === null || minutes === undefined) return t('sessionHistory.notAvailable');
    
    // Handle very short durations (less than 1 minute)
    if (minutes < 1) {
      const seconds = Math.round(minutes * 60);
      return `${seconds} ${t('sessionHistory.seconds')}`;
    }
    
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    
    if (hours > 0) {
      return `${hours}h ${mins}m`;
    }
    return `${mins}m`;
  };

  const getLanguageDisplay = (lang: string) => {
    const languages: Record<string, string> = {
      'ar': 'Arabic',
      'nl': 'Dutch',
      'en': 'English',
      'fr': 'French',
      'de': 'German',
      'es': 'Spanish'
    };
    return languages[lang] || lang;
  };

  const getLanguageFlag = (lang: string) => {
    const flags: Record<string, string> = {
      'ar': '🇸🇦',
      'nl': '🇳🇱',
      'en': '🇬🇧',
      'fr': '🇫🇷',
      'de': '🇩🇪',
      'es': '🇪🇸'
    };
    return flags[lang] || '🌐';
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-16">
        <div className="text-center space-y-4">
          <Loader2 className="h-12 w-12 animate-spin text-primary mx-auto" />
          <p className="text-muted-foreground">{t('sessionHistory.loading')}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      {/* Filters */}
      <div className="space-y-4">
        <div className="flex flex-col lg:flex-row gap-4">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder={t('sessionHistory.searchPlaceholder')}
              value={searchTerm}
              onChange={(e) => {
                setSearchTerm(e.target.value);
                setCurrentPage(1);
              }}
              className="pl-10 h-11"
            />
          </div>
          
          <Select value={selectedRoom} onValueChange={(value) => {
            setSelectedRoom(value);
            setCurrentPage(1);
          }}>
            <SelectTrigger className="w-full lg:w-[200px] h-11">
              <Filter className="h-4 w-4 mr-2" />
              <SelectValue placeholder={t('sessionHistory.filterByRoom')} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">{t('sessionHistory.allRooms')}</SelectItem>
              {rooms.map((room) => (
                <SelectItem key={room.id} value={room.id.toString()}>
                  {room.Title || `${t('sessionHistory.roomFallback')} ${room.id}`}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Select value={sortBy} onValueChange={(value: any) => {
            setSortBy(value);
            setCurrentPage(1);
          }}>
            <SelectTrigger className="w-full lg:w-[200px] h-11">
              <SelectValue placeholder={t('sessionHistory.sortBy')} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="date">{t('sessionHistory.dateNewest')}</SelectItem>
              <SelectItem value="duration">{t('sessionHistory.duration')}</SelectItem>
              <SelectItem value="transcripts">{t('sessionHistory.transcriptCount')}</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Pagination calculations */}
      {(() => {
        const totalItems = filteredAndSortedSessions.length;
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        const paginatedSessions = filteredAndSortedSessions.slice(startIndex, endIndex);
        
        const getPageNumbers = () => {
          const pages = [];
          const maxButtons = 5;
          
          if (totalPages <= maxButtons) {
            for (let i = 1; i <= totalPages; i++) {
              pages.push(i);
            }
          } else {
            if (currentPage <= 3) {
              for (let i = 1; i <= 4; i++) {
                pages.push(i);
              }
              pages.push('ellipsis');
              pages.push(totalPages);
            } else if (currentPage >= totalPages - 2) {
              pages.push(1);
              pages.push('ellipsis');
              for (let i = totalPages - 3; i <= totalPages; i++) {
                pages.push(i);
              }
            } else {
              pages.push(1);
              pages.push('ellipsis');
              for (let i = currentPage - 1; i <= currentPage + 1; i++) {
                pages.push(i);
              }
              pages.push('ellipsis');
              pages.push(totalPages);
            }
          }
          
          return pages;
        };
        
        return (
          <>
            {/* Sessions Grid */}
            {filteredAndSortedSessions.length === 0 ? (
        <Card>
          <CardContent className="text-center py-16">
            <MessageSquare className="h-16 w-16 text-muted-foreground/50 mx-auto mb-6" />
            <StyledHeader variant='h3' className="mb-2">{t('sessionHistory.noSessionsFound')}</StyledHeader>
            <p className="text-muted-foreground max-w-md mx-auto">
              {sessions.length === 0 
                ? t('sessionHistory.noCompletedSessions')
                : t('sessionHistory.noMatchingSessions')
              }
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="space-y-6">
          <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
            {paginatedSessions.map((session) => (
            <Card 
              key={session.id} 
              className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer"
            >
              <CardHeader className="space-y-3">
                <div className="flex items-start justify-between">
                  <div className="space-y-1">
                    <StyledHeader variant='h4' className="text-lg font-semibold line-clamp-1">
                      {session.rooms?.Title || `${t('sessionHistory.roomFallback')} ${session.room_id}`}
                    </StyledHeader>
                    <CardDescription className="text-sm">
                      {t('sessionHistory.table.room')} #{session.room_id}
                    </CardDescription>
                  </div>
                  <div className="flex flex-col items-end gap-2">
                    <Badge variant="secondary" className="text-xs">
                      {format(new Date(session.started_at), 'MMM dd')}
                    </Badge>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-1 hover:bg-transparent"
                      onClick={(e) => handleTogglePublic(session.id, session.is_public || false, session.public_title || null, e)}
                      title={session.is_public ? 'Make private' : 'Make public'}
                    >
                      {session.is_public ? (
                        <CheckSquare className="h-5 w-5 text-primary" />
                      ) : (
                        <Square className="h-5 w-5 text-muted-foreground" />
                      )}
                    </Button>
                  </div>
                </div>
                
                {/* Public Title Input (appears when editing) */}
                {editingSessionId === session.id && (
                  <div className="space-y-2 pt-2 border-t">
                    <label className="text-sm font-medium">{t('sessionHistory.publicTitleLabel')}</label>
                    <Input
                      value={publicTitle}
                      onChange={(e) => setPublicTitle(e.target.value)}
                      placeholder={t('sessionHistory.publicTitlePlaceholder')}
                      className="h-8"
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          handleSavePublicTitle(session.id);
                        } else if (e.key === 'Escape') {
                          handleCancelEdit();
                        }
                      }}
                    />
                    <div className="flex gap-2">
                      <Button
                        size="sm"
                        onClick={() => handleSavePublicTitle(session.id)}
                        className="h-7"
                      >
                        <Check className="h-3 w-3 mr-1" />
                        {t('common.save')}
                      </Button>
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={handleCancelEdit}
                        className="h-7"
                      >
                        <X className="h-3 w-3 mr-1" />
                        {t('common.cancel')}
                      </Button>
                    </div>
                  </div>
                )}
                
                {/* Show public title if exists */}
                {session.is_public && session.public_title && editingSessionId !== session.id && (
                  <div className="pt-2 border-t">
                    <p className="text-xs text-muted-foreground">{t('sessionHistory.publicTitleLabel')}:</p>
                    <p className="text-sm font-medium">{session.public_title}</p>
                  </div>
                )}
                
                {/* Language Badge */}
                <div className="flex items-center gap-2">
                  <div className="flex items-center gap-1.5 text-sm">
                    <span className="text-lg">{getLanguageFlag(session.rooms?.transcription_language || 'ar')}</span>
                    <span className="text-muted-foreground">{getLanguageDisplay(session.rooms?.transcription_language || 'ar')}</span>
                  </div>
                  <ArrowRight className="h-3.5 w-3.5 text-muted-foreground" />
                  <div className="flex items-center gap-1.5 text-sm">
                    <span className="text-lg">{getLanguageFlag(session.rooms?.translation__language || 'nl')}</span>
                    <span className="text-muted-foreground">{getLanguageDisplay(session.rooms?.translation__language || 'nl')}</span>
                  </div>
                </div>
              </CardHeader>
              
              <CardContent className="space-y-4">
                {/* Stats Grid */}
                <div className="grid grid-cols-3 gap-4 py-3">
                  <div className="text-center space-y-1">
                    <div className="flex items-center justify-center text-muted-foreground">
                      <CalendarIcon className="h-4 w-4" />
                    </div>
                    <p className="text-sm font-medium">{format(new Date(session.started_at), 'HH:mm')}</p>
                    <p className="text-xs text-muted-foreground">{t('sessionHistory.table.started')}</p>
                  </div>
                  
                  <div className="text-center space-y-1 border-x border-border/30">
                    <div className="flex items-center justify-center text-muted-foreground">
                      <Clock className="h-4 w-4" />
                    </div>
                    <p className="text-sm font-medium">{formatDuration(session.duration_minutes)}</p>
                    <p className="text-xs text-muted-foreground">{t('sessionHistory.table.duration')}</p>
                  </div>
                  
                  <div className="text-center space-y-1">
                    <div className="flex items-center justify-center text-muted-foreground">
                      <MessageSquare className="h-4 w-4" />
                    </div>
                    <p className="text-sm font-medium">{session.transcript_count}</p>
                    <p className="text-xs text-muted-foreground">{t('sessionHistory.table.transcripts')}</p>
                  </div>
                </div>
                
                {/* View Button */}
                <Button
                  variant="outline"
                  className="w-full border-border/50 transition-all duration-200 hover:bg-primary hover:text-primary-foreground hover:border-primary hover:shadow-md group-hover:bg-primary group-hover:text-primary-foreground group-hover:border-primary group-hover:shadow-md"
                  onClick={() => handleViewSession(session.id)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {t('sessionHistory.viewSession')}
                </Button>
              </CardContent>
            </Card>
            ))}
          </div>
          
          {/* Pagination */}
          {totalPages > 1 && (
            <Pagination className="mt-8">
              <PaginationContent>
                <PaginationItem>
                  <PaginationPrevious 
                    onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                    className={cn(
                      "cursor-pointer",
                      currentPage === 1 && "pointer-events-none opacity-50"
                    )}
                  />
                </PaginationItem>
                
                {getPageNumbers().map((page, index) => (
                  <PaginationItem key={index}>
                    {page === 'ellipsis' ? (
                      <PaginationEllipsis />
                    ) : (
                      <PaginationLink
                        onClick={() => setCurrentPage(page as number)}
                        isActive={currentPage === page}
                        className="cursor-pointer"
                      >
                        {page}
                      </PaginationLink>
                    )}
                  </PaginationItem>
                ))}
                
                <PaginationItem>
                  <PaginationNext 
                    onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                    className={cn(
                      "cursor-pointer",
                      currentPage === totalPages && "pointer-events-none opacity-50"
                    )}
                  />
                </PaginationItem>
              </PaginationContent>
            </Pagination>
          )}
          
          {/* Results info */}
          <div className="text-center text-sm text-muted-foreground">
            {t('sessionHistory.showingResults', {
              start: startIndex + 1,
              end: Math.min(endIndex, totalItems),
              total: totalItems
            }) || `Showing ${startIndex + 1} to ${Math.min(endIndex, totalItems)} of ${totalItems} sessions`}
          </div>
        </div>
      )}
          </>
        );
      })()}
    </div>
  );
};

export default SessionHistory;


================================================
FILE: src/features/session/components/SessionReplay.tsx
================================================
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Switch } from '@/components/ui/switch';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Separator } from '@/components/ui/separator';
import { 
  ArrowLeft, 
  Clock, 
  MessageSquare, 
  Calendar,
  Download, 
  FileText, 
  Languages,
  Layers,
  Type,
  Globe,
  Timer,
  History,
  RefreshCw,
  Loader2
} from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { useLanguage } from '@/contexts/LanguageContext';
import { Tables } from '@/integrations/supabase/types';
import TypewriterView from '@/features/display/components/TypewriterView';
import { format, formatDistanceToNow } from 'date-fns';
import { GlobalHeader } from '@/components/layout/GlobalHeader';

type RoomSession = Tables<'room_sessions'>;
type Transcript = Tables<'transcripts'>;
type Room = Tables<'rooms'>;

interface SessionWithRoom extends RoomSession {
  room: Room;
}

const SessionReplay = () => {
  const { sessionId } = useParams<{ sessionId: string }>();
  const navigate = useNavigate();
  const { toast } = useToast();
  const { t } = useTranslation();
  const { isRTL } = useLanguage();
  
  const [session, setSession] = useState<SessionWithRoom | null>(null);
  const [transcripts, setTranscripts] = useState<Transcript[]>([]);
  const [sentences, setSentences] = useState<Array<{
    id: string;
    arabic: string;
    translation: string;
    isComplete: boolean;
    timestamp: string;
  }>>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [exportFormat, setExportFormat] = useState<'transcript' | 'translation' | 'srt' | 'formatted'>('transcript');
  const [viewMode, setViewMode] = useState<'card' | 'typewriter'>('card');
  const [totalTranscripts, setTotalTranscripts] = useState(0);
  const [fetchedTranscripts, setFetchedTranscripts] = useState(0);
  
  // TypewriterView state
  const [typewriterTranscriptionDisplay, setTypewriterTranscriptionDisplay] = useState('');
  const [typewriterTranslationDisplay, setTypewriterTranslationDisplay] = useState('');

  useEffect(() => {
    if (!sessionId) {
      navigate('/history');
      return;
    }
    
    fetchSessionData();
  }, [sessionId]);

  const fetchAllTranscripts = async (sessionId: string, showProgress: boolean = false): Promise<Transcript[]> => {
    const pageSize = 1000; // Supabase default limit
    let allTranscripts: Transcript[] = [];
    let from = 0;
    let hasMore = true;
    
    // First, get the total count
    const { count, error: countError } = await supabase
      .from('transcripts')
      .select('*', { count: 'exact', head: true })
      .eq('session_id', sessionId);
    
    if (countError) {
      console.error('Error getting transcript count:', countError);
      throw countError;
    }
    
    const total = count || 0;
    if (showProgress) {
      setTotalTranscripts(total);
      setFetchedTranscripts(0);
    }
    
    console.log(`[SessionReplay] Total transcripts for session: ${total}`);
    
    // Fetch all pages
    while (hasMore) {
      const to = from + pageSize - 1;
      
      const { data, error } = await supabase
        .from('transcripts')
        .select('*')
        .eq('session_id', sessionId)
        .order('timestamp', { ascending: true })
        .range(from, to);
      
      if (error) {
        console.error(`Error fetching transcripts range ${from}-${to}:`, error);
        throw error;
      }
      
      if (data && data.length > 0) {
        allTranscripts = [...allTranscripts, ...data];
        if (showProgress) {
          setFetchedTranscripts(allTranscripts.length);
        }
        console.log(`[SessionReplay] Fetched ${data.length} transcripts (${allTranscripts.length}/${total})`);
        
        // Check if we have more to fetch
        hasMore = data.length === pageSize && allTranscripts.length < total;
        from = to + 1;
      } else {
        hasMore = false;
      }
    }
    
    console.log(`[SessionReplay] Fetched all ${allTranscripts.length} transcripts`);
    return allTranscripts;
  };

  const fetchSessionData = async (forceRefresh: boolean = false) => {
    try {
      if (forceRefresh) {
        setRefreshing(true);
      } else {
        setLoading(true);
      }
      
      // Fetch session with room information
      const { data: sessionData, error: sessionError } = await supabase
        .from('room_sessions')
        .select(`
          *,
          room:rooms (*)
        `)
        .eq('id', sessionId)
        .single();

      if (sessionError) {
        toast({
          title: "Error",
          description: "Failed to load session data",
          variant: "destructive"
        });
        if (!forceRefresh) {
          navigate('/history');
        }
        return;
      }

      setSession(sessionData as SessionWithRoom);

      // Fetch ALL transcripts with pagination
      try {
        const allTranscripts = await fetchAllTranscripts(sessionId!, forceRefresh);
        setTranscripts(allTranscripts);
        
        // Process transcripts into sentence groups
        processSentences(allTranscripts);
        
        if (forceRefresh) {
          toast({
            title: "Success",
            description: `Reconstructed session with ${allTranscripts.length} transcript entries`,
          });
        }
      } catch (transcriptsError) {
        console.error('Error fetching transcripts:', transcriptsError);
        toast({
          title: "Error",
          description: "Failed to load all session transcripts",
          variant: "destructive"
        });
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "An unexpected error occurred",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };
  
  const handleRefresh = async () => {
    await fetchSessionData(true);
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  };

  const formatDuration = (minutes: number | null) => {
    if (minutes === null || minutes === undefined) return 'N/A';
    
    if (minutes < 1) {
      const seconds = Math.round(minutes * 60);
      return `${seconds} seconds`;
    }
    
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    
    if (hours > 0) {
      return `${hours} hour${hours > 1 ? 's' : ''} ${mins} minute${mins !== 1 ? 's' : ''}`;
    }
    return `${mins} minute${mins !== 1 ? 's' : ''}`;
  };

  const getLanguageDisplayName = (code: string): string => {
    const languageMap: Record<string, string> = {
      'ar': 'Arabic',
      'en': 'English', 
      'nl': 'Dutch',
      'fr': 'French',
      'de': 'German',
      'es': 'Spanish',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'hi': 'Hindi',
      'ur': 'Urdu',
      'tr': 'Turkish'
    };
    
    return languageMap[code?.toLowerCase()] || code?.toUpperCase() || 'Unknown';
  };

  const isRTLLanguage = (code: string): boolean => {
    const rtlLanguages = ['ar', 'ur', 'fa', 'he'];
    return rtlLanguages.includes(code?.toLowerCase());
  };

  // Process transcript segments into complete sentences using sentence context
  const processSentences = (transcripts: Transcript[]) => {
    // Group transcripts by sentence_id for better reconstruction
    const sentenceGroups = new Map<string, Transcript[]>();
    const orphanTranscripts: Transcript[] = [];
    
    // First pass: group by sentence_id
    transcripts.forEach((transcript) => {
      if (transcript.sentence_id) {
        if (!sentenceGroups.has(transcript.sentence_id)) {
          sentenceGroups.set(transcript.sentence_id, []);
        }
        sentenceGroups.get(transcript.sentence_id)!.push(transcript);
      } else {
        // Handle legacy transcripts without sentence_id
        orphanTranscripts.push(transcript);
      }
    });
    
    const processedSentences: Array<{
      id: string;
      arabic: string;
      translation: string;
      isComplete: boolean;
      timestamp: string;
    }> = [];
    
    // Process grouped sentences (new format with sentence context)
    sentenceGroups.forEach((sentenceTranscripts, sentenceId) => {
      // Sort by timestamp to ensure correct order
      sentenceTranscripts.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      
      // Find the complete/authoritative version if available
      const completeTranscript = sentenceTranscripts.find(t => t.is_complete === true && t.transcription_segment);
      const translationTranscript = sentenceTranscripts.find(t => t.translation_segment);
      
      let arabicText = '';
      let timestamp = sentenceTranscripts[0].timestamp;
      
      if (completeTranscript) {
        // Use the authoritative complete text from backend
        arabicText = completeTranscript.transcription_segment || '';
        timestamp = completeTranscript.timestamp;
      } else {
        // Fallback: accumulate fragments (should be rare with new system)
        arabicText = sentenceTranscripts
          .filter(t => t.transcription_segment)
          .map(t => t.transcription_segment)
          .join(' ')
          .trim();
      }
      
      if (arabicText) {
        processedSentences.push({
          id: sentenceId,
          arabic: arabicText,
          translation: translationTranscript?.translation_segment || '',
          isComplete: completeTranscript?.is_complete || false,
          timestamp: timestamp
        });
      }
    });
    
    // Process orphan transcripts (legacy format without sentence_id)
    if (orphanTranscripts.length > 0) {
      let currentSentence: {
        id: string;
        arabic: string;
        timestamp: string;
        isComplete?: boolean;
      } | null = null;

      orphanTranscripts.forEach((transcript) => {
        // Arabic transcription segments (build sentences)
        if (transcript.transcription_segment && transcript.transcription_segment.trim()) {
          const text = transcript.transcription_segment.trim();
          
          if (currentSentence) {
            // Check if this segment already contains the accumulated text (complete sentence from backend)
            if (text.includes(currentSentence.arabic)) {
              // This is a complete sentence that already contains all previous fragments
              currentSentence.arabic = text;
              currentSentence.isComplete = true;
            } else {
              // Continue building the current sentence
              currentSentence.arabic = `${currentSentence.arabic} ${text}`;
            }
            
            // Check if sentence is complete (ends with punctuation)
            if (text.match(/[.!?؟،]$/)) {
              currentSentence.isComplete = true;
            }
          } else {
            // Start a new sentence
            currentSentence = {
              id: transcript.id,
              arabic: text,
              timestamp: transcript.timestamp,
              isComplete: text.match(/[.!?؟،]$/) ? true : false
            };
          }
        }
        
        // Translation segments (complete sentences)
        if (transcript.translation_segment && transcript.translation_segment.trim() && currentSentence) {
          // Add the completed sentence with its translation
          processedSentences.push({
            id: currentSentence.id,
            arabic: currentSentence.arabic,
            translation: transcript.translation_segment.trim(),
            isComplete: true,
            timestamp: currentSentence.timestamp
          });
          
          // Reset for next sentence
          currentSentence = null;
        }
      });

      // Add any remaining incomplete sentence
      if (currentSentence) {
        processedSentences.push({
          id: currentSentence.id,
          arabic: currentSentence.arabic,
          translation: '', // No translation yet
          isComplete: currentSentence.isComplete || false,
          timestamp: currentSentence.timestamp
        });
      }
    }
    
    // Sort all sentences by timestamp
    processedSentences.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
    
    setSentences(processedSentences);
    
    // Initialize typewriter view with complete text
    const fullTranscription = processedSentences.map(s => s.arabic).join(' ');
    const fullTranslation = processedSentences.filter(s => s.translation).map(s => s.translation).join(' ');
    setTypewriterTranscriptionDisplay(fullTranscription);
    setTypewriterTranslationDisplay(fullTranslation);
  };

  const handleExport = () => {
    if (sentences.length === 0) {
      toast({
        title: "No Data",
        description: "No sentences available to export",
        variant: "destructive"
      });
      return;
    }

    let content = '';
    let filename = '';
    let mimeType = 'text/plain';

    const sessionDate = session?.started_at ? format(new Date(session.started_at), 'yyyy-MM-dd') : 'unknown';

    switch (exportFormat) {
      case 'transcript':
        content = sentences
          .filter(s => s.arabic)
          .map((s, i) => `${i + 1}. ${s.arabic}`)
          .join('\n\n');
        filename = `transcript_${session?.room.Title}_${sessionDate}.txt`;
        break;
        
      case 'translation':
        content = sentences
          .filter(s => s.translation)
          .map((s, i) => `${i + 1}. ${s.translation}`)
          .join('\n\n');
        filename = `translation_${session?.room.Title}_${sessionDate}.txt`;
        break;
        
      case 'srt':
        content = sentences
          .filter(s => s.arabic && s.translation)
          .map((s, i) => {
            const startTime = new Date(s.timestamp);
            const endTime = new Date(startTime.getTime() + 5000); // 5 seconds duration
            
            const formatSRTTime = (date: Date) => {
              const hours = String(date.getHours()).padStart(2, '0');
              const minutes = String(date.getMinutes()).padStart(2, '0');
              const seconds = String(date.getSeconds()).padStart(2, '0');
              const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
              return `${hours}:${minutes}:${seconds},${milliseconds}`;
            };

            return `${i + 1}\n${formatSRTTime(startTime)} --> ${formatSRTTime(endTime)}\n${s.arabic}\n${s.translation}\n`;
          })
          .join('\n');
        filename = `subtitles_${session?.room.Title}_${sessionDate}.srt`;
        mimeType = 'text/srt';
        break;
        
      case 'formatted':
        const divider = '─'.repeat(80);
        const sessionHeader = [
          divider,
          `SESSION: ${session?.room.Title}`,
          `DATE: ${format(new Date(session.started_at), 'MMMM d, yyyy - h:mm a')}`,
          `DURATION: ${formatDuration(session.duration_minutes)}`,
          `LANGUAGES: ${getLanguageDisplayName(session.room.transcription_language || 'ar')} → ${getLanguageDisplayName(session.room.translation__language || 'en')}`,
          `TOTAL SENTENCES: ${sentences.length}`,
          divider,
          ''
        ].join('\n');
        
        content = sessionHeader + sentences
          .map((s, i) => {
            const sentenceHeader = `[${i + 1}] ${formatTime(s.timestamp)} ${s.isComplete ? '✓' : '○'}`;
            const formattedEntry = [
              sentenceHeader,
              '',
              `${getLanguageDisplayName(session.room.transcription_language || 'ar')}:`,
              s.arabic || '(No transcription)',
              '',
              `${getLanguageDisplayName(session.room.translation__language || 'en')}:`,
              s.translation || '(No translation available)',
              '',
              divider
            ];
            return formattedEntry.join('\n');
          })
          .join('\n\n');
        
        filename = `formatted_transcript_${session?.room.Title}_${sessionDate}.txt`;
        break;
    }

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    toast({
      title: "Export Complete",
      description: `${exportFormat.charAt(0).toUpperCase() + exportFormat.slice(1)} exported successfully`,
    });
  };

  if (loading) {
    return (
      <div className="h-screen flex flex-col">
        <div className="flex items-center gap-4 p-6">
          <Button
            variant="ghost"
            onClick={() => navigate('/history')}
            className="flex items-center gap-2"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to History
          </Button>
        </div>
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Loading session...</p>
          </div>
        </div>
      </div>
    );
  }

  if (!session) {
    return (
      <div className="h-screen flex flex-col">
        <div className="flex items-center gap-4 p-6">
          <Button
            variant="ghost"
            onClick={() => navigate('/history')}
            className="flex items-center gap-2"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to History
          </Button>
        </div>
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <h3 className="text-lg font-medium mb-2">{t('sessionReplay.sessionNotFound')}</h3>
            <p className="text-muted-foreground">{t('sessionReplay.sessionNotFoundDescription')}</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div>
      {/* Header - using GlobalHeader component */}
      <GlobalHeader
        title={t('dashboard.sessionArchive')}
        subtitle={session ? `${session.room.Title} - ${format(new Date(session.started_at), 'MMMM d, yyyy')}` : t('history.description')}
        icon={<History className="w-full h-full" />}
        showMenuButton={false}
      />

      {/* Compact Session Info Bar */}
      <div className="border-b bg-card/50 backdrop-blur-sm">
        <div className="container mx-auto px-4 sm:px-6 lg:pl-24 py-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            {/* Left side - Back button and info */}
            <div className="flex items-center gap-3 flex-1 min-w-0">
              <Button
                variant="ghost"
                size="sm"
                onClick={() => navigate('/history')}
                className="flex items-center gap-2 h-8"
              >
                <ArrowLeft className="h-3.5 w-3.5" />
                <span className="hidden sm:inline">{t('sessionReplay.backButton')}</span>
              </Button>
              
              <Separator orientation="vertical" className="h-6" />
              
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <MessageSquare className="h-4 w-4 text-primary" />
                <span className="font-medium text-foreground">{session.room.Title}</span>
              </div>
              
              <div className="hidden lg:flex items-center gap-3 text-sm text-muted-foreground">
                <Separator orientation="vertical" className="h-6" />
                <div className="flex items-center gap-1.5">
                  <Calendar className="h-3.5 w-3.5" />
                  <span>{format(new Date(session.started_at), 'MMM d, yyyy')}</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <Timer className="h-3.5 w-3.5" />
                  <span>{formatDuration(session.duration_minutes)}</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <Globe className="h-3.5 w-3.5" />
                  <span>{getLanguageDisplayName(session.room.transcription_language || 'ar')} → {getLanguageDisplayName(session.room.translation__language || 'en')}</span>
                </div>
              </div>
            </div>
            
            {/* Right side - Export controls */}
            <div className="flex items-center gap-2">
              <Button
                onClick={handleRefresh}
                disabled={refreshing}
                size="sm"
                variant="outline"
                className="h-8"
              >
                {refreshing ? (
                  <>
                    <Loader2 className="h-3.5 w-3.5 mr-1.5 animate-spin" />
                    <span className="hidden sm:inline">
                      {totalTranscripts > 0 ? `${fetchedTranscripts}/${totalTranscripts}` : 'Loading...'}
                    </span>
                  </>
                ) : (
                  <>
                    <RefreshCw className="h-3.5 w-3.5 mr-1.5" />
                    <span className="hidden sm:inline">{t('sessionReplay.refreshAll')}</span>
                  </>
                )}
              </Button>
              <Select value={exportFormat} onValueChange={(value: 'transcript' | 'translation' | 'srt' | 'formatted') => setExportFormat(value)}>
                <SelectTrigger className="w-[140px] h-8 text-sm">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="transcript">
                    <div className="flex items-center gap-2">
                      <FileText className="h-3.5 w-3.5" />
                      <span>{t('sessionReplay.export.fullTranscript')}</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="translation">
                    <div className="flex items-center gap-2">
                      <Languages className="h-3.5 w-3.5" />
                      <span>{t('sessionReplay.export.translationOnly')}</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="srt">
                    <div className="flex items-center gap-2">
                      <Clock className="h-3.5 w-3.5" />
                      <span>{t('sessionReplay.export.srtSubtitles')}</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="formatted">
                    <div className="flex items-center gap-2">
                      <Layers className="h-3.5 w-3.5" />
                      <span>{t('sessionReplay.export.formattedCards')}</span>
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
              <Button 
                onClick={handleExport} 
                disabled={sentences.length === 0}
                size="sm"
                className="h-8"
              >
                <Download className="h-3.5 w-3.5 mr-1.5" />
                <span className="hidden sm:inline">{t('sessionReplay.exportButton')}</span>
              </Button>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content Area */}
      <div className="container mx-auto px-4 sm:px-6 lg:pl-24 py-4 sm:py-6 lg:pt-[90px]">
        <div>
          <div className="pb-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Badge variant="secondary">
                  {sentences.length} sentences
                </Badge>
                {transcripts.length > 0 && (
                  <Badge variant="outline" className="text-xs">
                    {transcripts.length} transcript entries
                  </Badge>
                )}
                {refreshing && (
                  <Badge variant="outline" className="text-xs">
                    <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                    Fetching {fetchedTranscripts}/{totalTranscripts}
                  </Badge>
                )}
              </div>
              <div className="flex items-center gap-3">
                <Layers className={`h-4 w-4 ${viewMode === 'card' ? 'text-primary' : 'text-muted-foreground'}`} />
                <Switch
                  checked={viewMode === 'typewriter'}
                  onCheckedChange={(checked) => setViewMode(checked ? 'typewriter' : 'card')}
                  aria-label="Toggle view mode"
                />
                <Type className={`h-4 w-4 ${viewMode === 'typewriter' ? 'text-primary' : 'text-muted-foreground'}`} />
              </div>
            </div>
          </div>
          
          <div className="p-0">
            <div className="h-[calc(100vh-300px)]">
              {viewMode === 'typewriter' ? (
                <div className="h-full p-6">
                  <TypewriterView
                    currentSentence={null}
                    sentences={sentences.map(s => ({
                      ...s,
                      transcription: s.arabic,
                      translation: s.translation
                    }))}
                    room={{
                      transcription_language: session.room.transcription_language,
                      translation__language: session.room.translation__language
                    }}
                    isMonitoring={true}
                    displayedTranscription={typewriterTranscriptionDisplay}
                    displayedTranslation={typewriterTranslationDisplay}
                    onTranscriptionUpdate={setTypewriterTranscriptionDisplay}
                    onTranslationUpdate={setTypewriterTranslationDisplay}
                    skipAnimation={true}
                  />
                </div>
              ) : (
                <ScrollArea className="h-full p-6">
                  {sentences.length === 0 ? (
                    <div className="text-center text-muted-foreground py-16">
                      <MessageSquare className="h-12 w-12 mx-auto mb-4 opacity-50" />
                      <p className="text-lg">{t('sessionReplay.noTranscriptsFound')}</p>
                    </div>
                  ) : (
                    <div className="space-y-4 max-w-4xl mx-auto">
                      {sentences.map((sentence, index) => (
                        <Card key={sentence.id} className="border shadow-sm hover:shadow-md transition-shadow">
                          <CardContent className="p-6">
                            <div className="flex items-center justify-between mb-4">
                              <div className="flex items-center gap-3">
                                <div className={`h-2.5 w-2.5 rounded-full ${sentence.isComplete ? 'bg-green-500' : 'bg-yellow-500'}`}></div>
                                <Badge variant="outline" className="text-xs">
                                  #{index + 1}
                                </Badge>
                              </div>
                              <span className="text-sm text-muted-foreground">
                                {formatTime(sentence.timestamp)}
                              </span>
                            </div>
                            
                            <div className="space-y-4">
                              {/* Source Language Text */}
                              <div className={isRTLLanguage(session.room.transcription_language || 'ar') ? 'text-right' : 'text-left'}>
                                <p className="text-xs text-muted-foreground mb-1">
                                  {getLanguageDisplayName(session.room.transcription_language || 'ar')}
                                </p>
                                <p className="text-lg leading-relaxed font-medium" 
                                   dir={isRTLLanguage(session.room.transcription_language || 'ar') ? 'rtl' : 'ltr'}>
                                  {sentence.arabic}
                                </p>
                              </div>
                              
                              {/* Translation */}
                              <div className={isRTLLanguage(session.room.translation__language || 'en') ? 'text-right' : 'text-left'}>
                                <p className="text-xs text-muted-foreground mb-1">
                                  {getLanguageDisplayName(session.room.translation__language || 'en')}
                                </p>
                                {sentence.translation ? (
                                  <p className="text-lg leading-relaxed"
                                     dir={isRTLLanguage(session.room.translation__language || 'en') ? 'rtl' : 'ltr'}>
                                    {sentence.translation}
                                  </p>
                                ) : (
                                  <p className="text-lg text-muted-foreground italic">
                                    {t('sessionReplay.noTranslationAvailable')}
                                  </p>
                                )}
                              </div>
                            </div>
                          </CardContent>
                        </Card>
                      ))}
                    </div>
                  )}
                </ScrollArea>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SessionReplay;


================================================
FILE: src/features/session/pages/HistoryPage.tsx
================================================
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { LogOut, Building, History, Menu } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useNavigate } from 'react-router-dom';
import { Tables } from '@/integrations/supabase/types';
import { useAuth } from '@/hooks/useAuth';
import { useTranslation } from '@/hooks/useTranslation';
import { useLanguage } from '@/contexts/LanguageContext';
import SessionHistory from '@/features/session/components/SessionHistory';
import SidebarNav from '@/components/layout/SidebarNav';
import { GlobalHeader } from '@/components/layout/GlobalHeader';
import { getNavItems } from '@/config/navigation';
import { Sheet, SheetContent } from '@/components/ui/sheet';

type UserProfile = Tables<'users'>;

const HistoryPage = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { t } = useTranslation();
  const { isRTL } = useLanguage();
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [mosque, setMosque] = useState<Tables<'Mosque'> | null>(null);
  const [loading, setLoading] = useState(true);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);



  const fetchUserProfile = async () => {
    if (!user) return;
    
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .maybeSingle();

      if (error) throw error;
      
      if (!data) {
        navigate('/auth');
        return;
      }

      setUserProfile(data);
      
      // Fetch mosque data for non-super admins
      if (!data.is_super_admin) {
        const { data: mosqueData, error: mosqueError } = await supabase
          .from('Mosque')
          .select('*')
          .eq('id', data.mosque_id)
          .maybeSingle();
        
        if (mosqueError) {
          } else {
          setMosque(mosqueData);
        }
      }
    } catch (err) {
      navigate('/auth');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (user?.id) {
      fetchUserProfile();
    }
  }, [user?.id]);

  if (loading || !userProfile) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-muted-foreground">{t('history.loading')}</div>
      </div>
    );
  }

  const navItems = getNavItems(userProfile?.is_super_admin || false, t);

  return (
    <div className={`min-h-screen bg-background ${isRTL ? 'rtl' : 'ltr'}`}>
      <div className="flex">
        {/* Desktop Sidebar Navigation */}
        <div className="hidden lg:block">
          <SidebarNav items={navItems} />
        </div>
        
        {/* Mobile Sidebar Navigation */}
        <Sheet open={isMobileMenuOpen} onOpenChange={setIsMobileMenuOpen}>
          <SheetContent side={isRTL ? 'right' : 'left'} className="p-0 w-20">
            <SidebarNav items={navItems} onNavigate={() => setIsMobileMenuOpen(false)} />
          </SheetContent>
        </Sheet>
        
        {/* Main Content Area */}
        <div className="flex-1 min-w-0">
          {/* Header */}
          <GlobalHeader
            title={`${t('history.title')} - ${mosque?.name || t('dashboard.defaultMosqueName')}`}
            subtitle={t('history.description')}
            icon={<History className="w-full h-full" />}
            onMenuClick={() => setIsMobileMenuOpen(true)}
          />

          {/* Main Content */}
          <main className="p-4 sm:p-6 lg:pl-24 lg:pt-[90px]">
            <SessionHistory mosqueId={userProfile.mosque_id} />
          </main>
        </div>
      </div>
    </div>
  );
};

export default HistoryPage;


================================================
FILE: src/features/session/pages/SessionReplayPage.tsx
================================================
import { useState, useEffect } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { useTranslation } from '@/hooks/useTranslation';
import { useLanguage } from '@/contexts/LanguageContext';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import SessionReplay from "@/features/session/components/SessionReplay";
import SidebarNav from '@/components/layout/SidebarNav';
import { getNavItems } from '@/config/navigation';
import { Sheet, SheetContent } from '@/components/ui/sheet';
import { Button } from '@/components/ui/button';
import { Menu } from 'lucide-react';

type UserProfile = Tables<'users'>;

const SessionReplayPage = () => {
  const { user } = useAuth();
  const { t } = useTranslation();
  const { isRTL } = useLanguage();
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  useEffect(() => {
    const fetchUserProfile = async () => {
      if (!user) return;
      
      const { data } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .maybeSingle();

      if (data) {
        setUserProfile(data);
      }
    };

    fetchUserProfile();
  }, [user]);

  const navItems = getNavItems(userProfile?.is_super_admin || false, t);

  return (
    <div className={`min-h-screen bg-background ${isRTL ? 'rtl' : 'ltr'}`}>
      <div className="flex">
        {/* Desktop Sidebar Navigation */}
        <div className="hidden lg:block">
          <SidebarNav items={navItems} />
        </div>
        
        {/* Mobile Sidebar Navigation */}
        <Sheet open={isMobileMenuOpen} onOpenChange={setIsMobileMenuOpen}>
          <SheetContent side={isRTL ? 'right' : 'left'} className="p-0 w-20">
            <SidebarNav items={navItems} onNavigate={() => setIsMobileMenuOpen(false)} />
          </SheetContent>
        </Sheet>
        
        {/* Main Content Area */}
        <div className="flex-1 min-w-0">
          {/* Mobile Menu Toggle */}
          <Button
            variant="ghost"
            size="icon"
            className="fixed top-6 left-6 h-9 w-9 lg:hidden z-50"
            onClick={() => setIsMobileMenuOpen(true)}
          >
            <Menu className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
          
          <SessionReplay />
        </div>
      </div>
    </div>
  );
};

export default SessionReplayPage;


================================================
FILE: src/hooks/use-mobile.tsx
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: src/hooks/use-toast.ts
================================================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 3000 // 3 seconds instead of forever

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }



================================================
FILE: src/hooks/useAuth.ts
================================================
import { useState, useEffect, useRef, useMemo } from 'react';
import { User, Session } from '@supabase/supabase-js';
import { supabase } from '@/integrations/supabase/client';

export const useAuth = () => {
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const previousUserIdRef = useRef<string | undefined>();

  // Stabilize user object - only update when user ID actually changes
  const user = useMemo(() => {
    const currentUser = session?.user ?? null;
    const currentUserId = currentUser?.id;
    
    // Only update if user ID changed (prevents cascade re-renders)
    if (currentUserId !== previousUserIdRef.current) {
      previousUserIdRef.current = currentUserId;
      return currentUser;
    }
    
    // Return existing user if ID hasn't changed (maintains reference stability)
    return currentUser;
  }, [session?.user?.id]);

  useEffect(() => {
    // Set up auth state listener FIRST
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        // Only log meaningful auth events, not session refreshes
        if (event === 'SIGNED_IN' || event === 'SIGNED_OUT' || event === 'TOKEN_REFRESHED') {
          }
        
        setSession(session);
        setLoading(false);
      }
    );

    // THEN check for existing session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setLoading(false);
    });

    return () => subscription.unsubscribe();
  }, []);

  return { user, session, loading };
};


================================================
FILE: src/hooks/useBroadcastChannel.ts
================================================
import { useEffect, useRef, useState, useCallback } from 'react';
import { broadcastChannelManager, ConnectionState } from '@/lib/broadcastChannelManager';

interface UseBroadcastChannelOptions {
  enabled?: boolean;
  onConnectionStateChange?: (state: ConnectionState) => void;
}

interface BroadcastMessage {
  type: string;
  room_id: number;
  mosque_id: number;
  data: any;
}

interface UseBroadcastChannelReturn {
  connectionState: ConnectionState;
  subscribe: (event: string, callback: (message: BroadcastMessage) => void) => () => void;
}

/**
 * React hook for managing broadcast channel subscriptions
 * Handles lifecycle and provides clean interface to BroadcastChannelManager
 */
export function useBroadcastChannel(
  channelName: string,
  listenerId: string,
  options: UseBroadcastChannelOptions = {}
): UseBroadcastChannelReturn {
  const { enabled = true, onConnectionStateChange } = options;
  const [connectionState, setConnectionState] = useState<ConnectionState>(ConnectionState.DISCONNECTED);
  const subscriptionsRef = useRef<Map<string, () => void>>(new Map());
  const isUnmountedRef = useRef(false);

  // Message deduplication
  const recentMessages = useRef<Set<string>>(new Set());
  const MESSAGE_HISTORY_SIZE = 100;

  // Handle connection state changes
  const handleStateChange = useCallback((state: ConnectionState) => {
    if (!isUnmountedRef.current) {
      setConnectionState(state);
      onConnectionStateChange?.(state);
    }
  }, [onConnectionStateChange]);

  // Create stable subscribe function using refs
  const subscribeInternal = useCallback((event: string, callback: (message: BroadcastMessage) => void) => {
    const subscriptionKey = event;
    
    // Check if already subscribed to this event
    if (subscriptionsRef.current.has(subscriptionKey)) {
      // Return existing cleanup function
      return subscriptionsRef.current.get(subscriptionKey) || (() => {});
    }
    
    // Wrap callback with deduplication
    const wrappedCallback = (payload: any) => {
      if (isUnmountedRef.current) return;

      const message = payload as BroadcastMessage;
      
      // Generate deduplication key
      const msgId = message.data?.msg_id || message.data?.timestamp;
      
      // Check for duplicate
      if (msgId && recentMessages.current.has(msgId)) {
        return;
      }
      
      // Add to recent messages
      if (msgId) {
        recentMessages.current.add(msgId);
        
        // Cleanup old message IDs
        if (recentMessages.current.size > MESSAGE_HISTORY_SIZE) {
          const firstId = recentMessages.current.values().next().value;
          recentMessages.current.delete(firstId);
        }
      }
      
      callback(message);
    };

    // Subscribe through manager
    const cleanup = broadcastChannelManager.subscribe(
      channelName,
      `${listenerId}-${subscriptionKey}`,
      event,
      wrappedCallback,
      {
        onConnectionStateChange: handleStateChange
      }
    );

    // Store cleanup function
    subscriptionsRef.current.set(subscriptionKey, cleanup);

    // Return cleanup function
    return () => {
      const storedCleanup = subscriptionsRef.current.get(subscriptionKey);
      if (storedCleanup) {
        storedCleanup();
        subscriptionsRef.current.delete(subscriptionKey);
      }
    };
  }, [channelName, listenerId, handleStateChange]);
  
  // Subscribe function that checks enabled state
  const subscribe = useCallback((event: string, callback: (message: BroadcastMessage) => void) => {
    if (!enabled) {
      return () => {};
    }
    return subscribeInternal(event, callback);
  }, [enabled, subscribeInternal]);

  // Cleanup on unmount or when disabled
  useEffect(() => {
    isUnmountedRef.current = false;

    return () => {
      isUnmountedRef.current = true;
      
      // Cleanup all subscriptions
      subscriptionsRef.current.forEach(cleanup => cleanup());
      subscriptionsRef.current.clear();
      
      // Clear message history
      recentMessages.current.clear();
    };
  }, []);

  // Handle enabled/disabled state changes
  useEffect(() => {
    if (!enabled) {
      // Cleanup all subscriptions when disabled
      subscriptionsRef.current.forEach(cleanup => cleanup());
      subscriptionsRef.current.clear();
      setConnectionState(ConnectionState.DISCONNECTED);
    }
  }, [enabled]);

  return {
    connectionState,
    subscribe
  };
}


================================================
FILE: src/hooks/useImpersonation.ts
================================================
import { useState, useEffect } from 'react';
import { User } from '@supabase/supabase-js';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useNavigate } from 'react-router-dom';
import { useTranslation } from './useTranslation';

interface ImpersonationState {
  isImpersonating: boolean;
  originalUser: User | null;
  impersonatedUser: User | null;
  sessionId: string | null;
}

export const useImpersonation = () => {
  const [impersonationState, setImpersonationState] = useState<ImpersonationState>({
    isImpersonating: false,
    originalUser: null,
    impersonatedUser: null,
    sessionId: null,
  });
  const { toast } = useToast();
  const navigate = useNavigate();
  const { t } = useTranslation();

  useEffect(() => {
    // Check for impersonation session in URL
    const urlParams = new URLSearchParams(window.location.search);
    const sessionId = urlParams.get('impersonation_session');
    
    if (sessionId) {
      // Store session info in localStorage
      localStorage.setItem('impersonation_session', sessionId);
      
      // Clean URL
      const newUrl = window.location.pathname;
      window.history.replaceState({}, '', newUrl);
    }

    // Check for existing impersonation session
    const storedSessionId = localStorage.getItem('impersonation_session');
    if (storedSessionId) {
      setImpersonationState(prev => ({
        ...prev,
        isImpersonating: true,
        sessionId: storedSessionId,
      }));
    }
  }, []);

  const startImpersonation = async (targetUserId: string, targetUserEmail: string) => {
    try {
      const { data, error } = await supabase.functions.invoke('impersonate-user', {
        body: {
          action: 'start',
          targetUserId
        }
      });

      if (error) throw error;

      // Store original user before switching
      const { data: { user: currentUser } } = await supabase.auth.getUser();
      
      // Set the new session tokens
      const { error: sessionError } = await supabase.auth.setSession({
        access_token: data.accessToken,
        refresh_token: data.refreshToken
      });

      if (sessionError) throw sessionError;

      // Update state
      setImpersonationState({
        isImpersonating: true,
        originalUser: currentUser,
        impersonatedUser: data.targetUser,
        sessionId: data.sessionId,
      });

      // Store session info
      localStorage.setItem('impersonation_session', data.sessionId);
      localStorage.setItem('original_user', JSON.stringify(currentUser));

      toast({
        title: t('impersonation.startedTitle'),
        description: t('impersonation.startedDescription').replace('{email}', targetUserEmail),
      });

      // Navigate to dashboard - let auth state handle the context update
      navigate('/dashboard');

    } catch (error) {
      toast({
        title: t('impersonation.failedTitle'),
        description: error instanceof Error ? error.message : t('impersonation.failedDescription'),
        variant: "destructive",
      });
    }
  };

  const endImpersonation = async () => {
    try {
      const sessionId = impersonationState.sessionId || localStorage.getItem('impersonation_session');
      
      if (sessionId) {
        await supabase.functions.invoke('impersonate-user', {
          body: {
            action: 'end',
            sessionId
          }
        });
      }

      // Clear impersonation state
      localStorage.removeItem('impersonation_session');
      localStorage.removeItem('original_user');
      
      // Sign out current session to return to original user
      await supabase.auth.signOut();

      toast({
        title: t('impersonation.endedTitle'),
        description: t('impersonation.endedDescription'),
      });

      // Navigate to auth page
      navigate('/auth');

    } catch (error) {
      toast({
        title: t('common.error'),
        description: t('impersonation.endFailed'),
        variant: "destructive",
      });
    }
  };

  return {
    ...impersonationState,
    startImpersonation,
    endImpersonation,
  };
};


================================================
FILE: src/hooks/useManagedSubscription.ts
================================================
import { useEffect, useRef, useCallback } from 'react';
import { connectionManager } from '@/lib/supabaseConnectionManager';
import type { RealtimePostgresChangesPayload } from '@supabase/supabase-js';

interface SubscriptionConfig {
  channelName: string;
  table: string;
  event?: '*' | 'INSERT' | 'UPDATE' | 'DELETE';
  filter?: string;
  schema?: string;
  debounceMs?: number;
}

/**
 * Hook for managed Supabase subscriptions using the connection manager.
 * Prevents connection explosion by reusing channels and proper cleanup.
 */
export const useManagedSubscription = (
  config: SubscriptionConfig,
  callback: (payload: RealtimePostgresChangesPayload<any>) => void,
  deps: React.DependencyList = []
) => {
  const cleanupRef = useRef<(() => void) | null>(null);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const subscriptionIdRef = useRef<string>(`sub-${Math.random().toString(36).substr(2, 9)}`);

  // Create debounced callback if needed
  const debouncedCallback = useCallback((payload: RealtimePostgresChangesPayload<any>) => {
    if (config.debounceMs && config.debounceMs > 0) {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
      debounceTimerRef.current = setTimeout(() => {
        callback(payload);
      }, config.debounceMs);
    } else {
      callback(payload);
    }
  }, [callback, config.debounceMs]);

  useEffect(() => {
    // Check if connection manager is near limit
    if (connectionManager.isNearLimit()) {
      console.warn('Approaching connection limit. Some subscriptions may be rejected.');
    }

    // Subscribe using connection manager
    cleanupRef.current = connectionManager.subscribe(
      config.channelName,
      subscriptionIdRef.current,
      {
        event: config.event || '*',
        schema: config.schema || 'public',
        table: config.table,
        filter: config.filter,
        callback: debouncedCallback,
      }
    );

    // Cleanup function
    return () => {
      // Clear debounce timer
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
        debounceTimerRef.current = null;
      }

      // Call connection manager cleanup
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = null;
      }
    };
  }, [config.channelName, config.table, ...deps]); // Include deps but be careful with reference equality

  // Return connection stats for debugging
  return {
    getStats: () => connectionManager.getStats(),
  };
};


================================================
FILE: src/hooks/useRoomStatusMonitor.ts
================================================
import { useState, useEffect, useRef, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

interface RoomStatusData {
  totalRooms: number;
  activeRooms: number;
  pendingRooms: number;
  emptyRooms: number;
  inconsistentRooms: number;
}

interface UseRoomStatusMonitorProps {
  mosqueId: number;
  enabled?: boolean;
}

export const useRoomStatusMonitor = ({ mosqueId, enabled = true }: UseRoomStatusMonitorProps) => {
  const [status, setStatus] = useState<RoomStatusData>({
    totalRooms: 0,
    activeRooms: 0,
    pendingRooms: 0,
    emptyRooms: 0,
    inconsistentRooms: 0
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();
  
  // Refs for debouncing and cleanup state
  const debounceTimerRef = useRef<NodeJS.Timeout>();
  const isCleaningUpRef = useRef(false);

  const validateAndFixRoomStatus = async () => {
    if (!enabled) return;
    
    // Prevent concurrent cleanup attempts
    if (isCleaningUpRef.current) {
      return;
    }

    try {
      isCleaningUpRef.current = true;
      setLoading(true);
      // Check for rooms with active status but no active sessions
      const { data: inconsistentRooms, error: inconsistentError } = await supabase
        .from('rooms')
        .select(`
          id,
          Title,
          status,
          room_sessions!inner(
            id,
            status
          )
        `)
        .eq('mosque_id', mosqueId)
        .eq('status', 'active')
        .not('room_sessions.status', 'eq', 'active');

      if (inconsistentError) {
        } else if (inconsistentRooms && inconsistentRooms.length > 0) {
        // Use gentle cleanup instead of aggressive cleanup
        for (const room of inconsistentRooms) {
          const { data: cleanedSessions, error: cleanupError } = await supabase.rpc('gentle_cleanup_room_sessions', {
            room_id_param: room.id,
            minutes_threshold: 15 // Only clean up sessions inactive for 15+ minutes
          });

          if (cleanupError) {
            } else {
            }
        }

        // Only show toast if we actually cleaned up sessions
        const totalCleaned = inconsistentRooms.length;
        if (totalCleaned > 0) {
          toast({
            title: "Status Fixed",
            description: `Cleaned up ${totalCleaned} room(s) with abandoned sessions`,
          });
        }
      }

      // Get overall status counts
      const { data: roomsData, error: roomsError } = await supabase
        .from('rooms')
        .select('id, status')
        .eq('mosque_id', mosqueId);

      if (roomsError) throw roomsError;

      const statusCounts = roomsData?.reduce((acc, room) => {
        acc.totalRooms++;
        switch (room.status) {
          case 'active':
            acc.activeRooms++;
            break;
          case 'pending':
            acc.pendingRooms++;
            break;
          case 'empty':
            acc.emptyRooms++;
            break;
          default:
            acc.inconsistentRooms++;
        }
        return acc;
      }, {
        totalRooms: 0,
        activeRooms: 0,
        pendingRooms: 0,
        emptyRooms: 0,
        inconsistentRooms: 0
      }) || {
        totalRooms: 0,
        activeRooms: 0,
        pendingRooms: 0,
        emptyRooms: 0,
        inconsistentRooms: 0
      };

      setStatus(statusCounts);
      setError(null);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to validate room status';
      setError(errorMessage);
      } finally {
      setLoading(false);
      isCleaningUpRef.current = false;
    }
  };
  
  // Debounced version of validateAndFixRoomStatus
  const debouncedValidateAndFix = useCallback(() => {
    // Clear any existing timer
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    
    // Set new timer with 5 second delay to avoid being too trigger-happy
    debounceTimerRef.current = setTimeout(() => {
      validateAndFixRoomStatus();
    }, 5000);
  }, [enabled, mosqueId]);

  useEffect(() => {
    if (enabled && mosqueId) {
      validateAndFixRoomStatus();

      // Set up real-time monitoring
      const channel = supabase
        .channel(`room-status-monitor-${mosqueId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'rooms',
            filter: `mosque_id=eq.${mosqueId}`
          },
          () => {
            debouncedValidateAndFix();
          }
        )
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'room_sessions'
          },
          () => {
            debouncedValidateAndFix();
          }
        )
        .subscribe();

      return () => {
        // Clear debounce timer on cleanup
        if (debounceTimerRef.current) {
          clearTimeout(debounceTimerRef.current);
        }
        supabase.removeChannel(channel);
      };
    }
  }, [mosqueId, enabled, debouncedValidateAndFix]);

  return {
    status,
    loading,
    error,
    refresh: validateAndFixRoomStatus
  };
};


================================================
FILE: src/hooks/useRoomStatusValidation.ts
================================================
import { supabase } from '@/integrations/supabase/client';

interface ValidationResult {
  isValid: boolean;
  error?: string;
  suggestion?: string;
}

export const useRoomStatusValidation = () => {
  const validateStatusChange = async (
    roomId: number, 
    currentStatus: string, 
    newStatus: string
  ): Promise<ValidationResult> => {
    try {
      // If changing to empty, check for active sessions
      if (newStatus === 'empty') {
        const { data: activeSessions, error } = await supabase
          .from('room_sessions')
          .select('id, started_at')
          .eq('room_id', roomId)
          .eq('status', 'active');

        if (error) throw error;

        if (activeSessions && activeSessions.length > 0) {
          return {
            isValid: false,
            error: 'Cannot set room to empty - there are active recording sessions',
            suggestion: 'Please end all active sessions before changing room status to empty'
          };
        }
      }

      // If changing from empty to active/live, ensure LiveKit room exists
      if (currentStatus === 'empty' && (newStatus === 'active' || newStatus === 'live')) {
        const { data: room } = await supabase
          .from('rooms')
          .select('Livekit_room_name')
          .eq('id', roomId)
          .single();

        if (!room?.Livekit_room_name) {
          return {
            isValid: false,
            error: 'Cannot activate room without LiveKit room name',
            suggestion: 'Please ensure the room has a valid LiveKit configuration'
          };
        }
      }

      // Check for pending status - rooms shouldn't stay pending if they have a LiveKit room
      if (newStatus === 'pending') {
        const { data: room } = await supabase
          .from('rooms')
          .select('Livekit_room_name')
          .eq('id', roomId)
          .single();

        if (room?.Livekit_room_name) {
          return {
            isValid: true,
            error: undefined,
            suggestion: 'Room has LiveKit configuration - consider setting to "empty" instead'
          };
        }
      }

      return { isValid: true };
    } catch (error) {
      return {
        isValid: false,
        error: 'Failed to validate status change',
        suggestion: 'Please try again or contact support'
      };
    }
  };

  const syncRoomStatus = async (roomId: number): Promise<string | null> => {
    try {
      // Check for active sessions
      const { data: activeSessions } = await supabase
        .from('room_sessions')
        .select('id')
        .eq('room_id', roomId)
        .eq('status', 'active')
        .limit(1);

      // Get current room status
      const { data: room } = await supabase
        .from('rooms')
        .select('status')
        .eq('id', roomId)
        .single();

      if (!room) return null;

      const hasActiveSessions = activeSessions && activeSessions.length > 0;
      const currentStatus = room.status;

      // Determine correct status
      let correctStatus = currentStatus;
      if (hasActiveSessions && currentStatus !== 'live') {
        correctStatus = 'live';
      } else if (!hasActiveSessions && currentStatus === 'live') {
        correctStatus = 'empty';
      }

      // Update if needed
      if (correctStatus !== currentStatus) {
        const { error } = await supabase
          .from('rooms')
          .update({ 
            status: correctStatus,
            updated_at: new Date().toISOString()
          })
          .eq('id', roomId);

        if (error) {
          return null;
        }

        }

      return correctStatus;
    } catch (error) {
      return null;
    }
  };

  return {
    validateStatusChange,
    syncRoomStatus
  };
};


================================================
FILE: src/hooks/useSessionCleanup.ts
================================================
import { useEffect, useRef } from 'react';
import { cleanupSession, emergencyCleanup, CleanupSource } from '@/utils/sessionCleanupCoordinator';
import { Tables } from '@/integrations/supabase/types';

interface UseSessionCleanupProps {
  sessionId: string | null;
  roomId: number;
  isActive: boolean;
  room?: Tables<'rooms'>;
  onCleanup?: () => void;
}

export const useSessionCleanup = ({ sessionId, roomId, isActive, room, onCleanup }: UseSessionCleanupProps) => {
  const isCleaningUpRef = useRef(false);

  const performCleanup = async (source: CleanupSource) => {
    if (!sessionId || isCleaningUpRef.current) return;
    
    // Check if room is persistent (kiosk mode)
    if (room?.is_persistent) {
      return;
    }
    
    isCleaningUpRef.current = true;
    
    try {
      await cleanupSession({
        sessionId,
        roomId,
        source,
        room,
        onComplete: onCleanup
      });
    } finally {
      isCleaningUpRef.current = false;
    }
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (isActive && sessionId && !room?.is_persistent) {
        performCleanup('unmount');
      }
    };
  }, [sessionId, isActive, room?.is_persistent]);

  // Cleanup on window unload
  useEffect(() => {
    if (!isActive || !sessionId || room?.is_persistent) return;

    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      // Show confirmation if session is active (not in kiosk mode)
      e.preventDefault();
      e.returnValue = 'You have an active recording session. Are you sure you want to leave?';
    };

    const handleUnload = () => {
      // Use emergency cleanup for page unload
      emergencyCleanup(sessionId, roomId);
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    window.addEventListener('unload', handleUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
      window.removeEventListener('unload', handleUnload);
    };
  }, [sessionId, roomId, isActive, room?.is_persistent]);

  // Cleanup on visibility change (mobile/tab switching)
  useEffect(() => {
    if (!isActive || !sessionId || room?.is_persistent) return;

    const handleVisibilityChange = () => {
      if (document.hidden) {
        // Store timestamp when page was hidden
        sessionStorage.setItem(`hidden-${roomId}`, Date.now().toString());
      } else {
        // Check if page was hidden for too long
        const hiddenTime = sessionStorage.getItem(`hidden-${roomId}`);
        if (hiddenTime) {
          const elapsed = Date.now() - parseInt(hiddenTime);
          if (elapsed > 5 * 60 * 1000) { // 5 minutes
            performCleanup('visibility');
          }
          sessionStorage.removeItem(`hidden-${roomId}`);
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [sessionId, roomId, isActive, room?.is_persistent]);

  return { performCleanup };
};


================================================
FILE: src/hooks/useSupabaseSubscription.ts
================================================
import { useEffect, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';

interface SubscriptionConfig {
  table: string;
  event?: '*' | 'INSERT' | 'UPDATE' | 'DELETE';
  filter?: string;
  handler: () => void;
}

interface UseSupabaseSubscriptionOptions {
  channelName: string;
  subscriptions: SubscriptionConfig[];
  debounceMs?: number;
  onConnect?: () => void;
  onError?: (error: Error) => void;
}

/**
 * Reusable hook for managing Supabase real-time subscriptions with:
 * - Automatic cleanup
 * - Debouncing
 * - Single multiplexed channel
 * - Proper error handling
 */
export const useSupabaseSubscription = ({
  channelName,
  subscriptions,
  debounceMs = 500,
  onConnect,
  onError,
}: UseSupabaseSubscriptionOptions) => {
  const channelRef = useRef<RealtimeChannel | null>(null);
  const debounceTimersRef = useRef<Map<string, NodeJS.Timeout>>(new Map());

  useEffect(() => {
    // Create debounced handlers
    const createDebouncedHandler = (handler: () => void, key: string) => {
      return () => {
        const existingTimer = debounceTimersRef.current.get(key);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }

        const timer = setTimeout(handler, debounceMs);
        debounceTimersRef.current.set(key, timer);
      };
    };

    // Create multiplexed channel
    let channel = supabase.channel(channelName);

    // Add all subscriptions to the channel
    subscriptions.forEach((sub, index) => {
      const key = `${sub.table}-${sub.event || '*'}-${index}`;
      const handler = debounceMs > 0 
        ? createDebouncedHandler(sub.handler, key)
        : sub.handler;

      const config: any = {
        event: sub.event || '*',
        schema: 'public',
        table: sub.table,
      };

      if (sub.filter) {
        config.filter = sub.filter;
      }

      channel = channel.on('postgres_changes', config, handler);
    });

    // Subscribe to the channel
    channel.subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        console.log(`Channel ${channelName} subscribed`);
        onConnect?.();
      } else if (status === 'CHANNEL_ERROR') {
        console.error(`Channel ${channelName} error`);
        onError?.(new Error(`Channel ${channelName} subscription error`));
      }
    });

    channelRef.current = channel;

    // Cleanup
    return () => {
      console.log(`Cleaning up channel ${channelName}`);
      
      // Clear all debounce timers
      debounceTimersRef.current.forEach(timer => clearTimeout(timer));
      debounceTimersRef.current.clear();

      // Unsubscribe and remove channel
      if (channelRef.current) {
        channelRef.current.unsubscribe();
        supabase.removeChannel(channelRef.current);
        channelRef.current = null;
      }
    };
  }, [channelName]); // Only re-create if channel name changes

  return channelRef.current;
};


================================================
FILE: src/hooks/useTranslation.ts
================================================
import { useLanguage } from '@/contexts/LanguageContext';
import { getTranslation, getNestedTranslation, interpolate } from '@/lib/translations';

export function useTranslation() {
  const { language } = useLanguage();

  const t = (key: string, variables?: Record<string, string | number>): string => {
    const translationObj = getTranslation(language);
    const translation = getNestedTranslation(translationObj, key);
    
    if (variables) {
      return interpolate(translation, variables);
    }
    
    return translation;
  };

  return { t, language };
}


================================================
FILE: src/hooks/data/useMosques.ts
================================================
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';

type Mosque = Tables<'Mosque'>;

interface UseMosquesOptions {
  autoFetch?: boolean;
  realtime?: boolean;
}

interface UseMosquesReturn {
  mosques: Mosque[];
  loading: boolean;
  error: Error | null;
  fetchMosques: () => Promise<void>;
  createMosque: (data: Omit<Mosque, 'id'>) => Promise<Mosque | null>;
  updateMosque: (id: number, data: Partial<Mosque>) => Promise<Mosque | null>;
  deleteMosque: (id: number) => Promise<boolean>;
  getMosqueById: (id: number) => Mosque | undefined;
  searchMosques: (query: string) => Mosque[];
}

export function useMosques(options: UseMosquesOptions = {}): UseMosquesReturn {
  const { autoFetch = true, realtime = true } = options;
  const { toast } = useToast();
  const { t } = useTranslation();
  
  const [mosques, setMosques] = useState<Mosque[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  // Fetch all mosques
  const fetchMosques = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const { data, error } = await supabase
        .from('Mosque')
        .select('*')
        .order('name');

      if (error) throw error;
      setMosques(data || []);
    } catch (err) {
      const error = err as Error;
      setError(error);
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.fetchMosquesFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Create a new mosque
  const createMosque = useCallback(async (data: Omit<Mosque, 'id'>): Promise<Mosque | null> => {
    try {
      setLoading(true);
      
      // Generate a random ID for the mosque
      const newMosque = {
        ...data,
        id: Math.floor(Math.random() * 1000000),
      };
      
      const { data: created, error } = await supabase
        .from('Mosque')
        .insert(newMosque)
        .select()
        .single();

      if (error) throw error;
      
      // Update local state
      setMosques(prev => [...prev, created]);
      
      toast({
        title: t('common.success'),
        description: t('superAdmin.onboarding.mosqueCreated')
          .replace('{name}', created.name)
          .replace('{subdomain}', created.Subdomain || ''),
      });
      
      return created;
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('superAdmin.onboarding.mosqueFailed'),
        variant: 'destructive',
      });
      return null;
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Update a mosque
  const updateMosque = useCallback(async (id: number, data: Partial<Mosque>): Promise<Mosque | null> => {
    try {
      setLoading(true);
      
      const { data: updated, error } = await supabase
        .from('Mosque')
        .update(data)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      
      // Update local state
      setMosques(prev => prev.map(m => m.id === id ? updated : m));
      
      toast({
        title: t('common.success'),
        description: t('superAdmin.mosques.mosqueUpdated'),
      });
      
      return updated;
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
      return null;
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Delete a mosque
  const deleteMosque = useCallback(async (id: number): Promise<boolean> => {
    try {
      setLoading(true);
      
      const { error } = await supabase
        .from('Mosque')
        .delete()
        .eq('id', id);

      if (error) throw error;
      
      // Update local state
      setMosques(prev => prev.filter(m => m.id !== id));
      
      toast({
        title: t('common.success'),
        description: t('superAdmin.mosques.mosqueDeleted'),
      });
      
      return true;
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.deleteFailed'),
        variant: 'destructive',
      });
      return false;
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Get mosque by ID
  const getMosqueById = useCallback((id: number): Mosque | undefined => {
    return mosques.find(m => m.id === id);
  }, [mosques]);

  // Search mosques
  const searchMosques = useCallback((query: string): Mosque[] => {
    const lowerQuery = query.toLowerCase();
    return mosques.filter(mosque => 
      mosque.name.toLowerCase().includes(lowerQuery) ||
      mosque.Subdomain?.toLowerCase().includes(lowerQuery)
    );
  }, [mosques]);

  // Auto-fetch on mount
  useEffect(() => {
    if (autoFetch) {
      fetchMosques();
    }
  }, [autoFetch, fetchMosques]);

  // Real-time subscription
  useEffect(() => {
    if (!realtime) return;

    const channel = supabase
      .channel('mosques-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'Mosque' },
        (payload) => {
          if (payload.eventType === 'INSERT') {
            setMosques(prev => [...prev, payload.new as Mosque]);
          } else if (payload.eventType === 'UPDATE') {
            setMosques(prev => prev.map(m => 
              m.id === (payload.new as Mosque).id ? payload.new as Mosque : m
            ));
          } else if (payload.eventType === 'DELETE') {
            setMosques(prev => prev.filter(m => m.id !== (payload.old as Mosque).id));
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [realtime]);

  return {
    mosques,
    loading,
    error,
    fetchMosques,
    createMosque,
    updateMosque,
    deleteMosque,
    getMosqueById,
    searchMosques,
  };
}


================================================
FILE: src/hooks/data/useUsers.ts
================================================
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { useToast } from '@/hooks/use-toast';
import { useTranslation } from '@/hooks/useTranslation';
import { useAuth } from '@/hooks/useAuth';

type User = Tables<'users'>;
type Mosque = Tables<'Mosque'>;

interface ExtendedUser extends User {
  mosque?: Mosque;
}

interface UseUsersOptions {
  autoFetch?: boolean;
  realtime?: boolean;
  mosqueId?: number;
}

interface UseUsersReturn {
  users: ExtendedUser[];
  loading: boolean;
  error: Error | null;
  fetchUsers: () => Promise<void>;
  createUser: (data: Partial<User>) => Promise<User | null>;
  updateUser: (id: string, data: Partial<User>) => Promise<User | null>;
  deleteUser: (id: string) => Promise<boolean>;
  getUserById: (id: string) => ExtendedUser | undefined;
  searchUsers: (query: string) => ExtendedUser[];
  updateUserRole: (id: string, role: string) => Promise<boolean>;
}

export function useUsers(options: UseUsersOptions = {}): UseUsersReturn {
  const { autoFetch = true, realtime = true, mosqueId } = options;
  const { toast } = useToast();
  const { t } = useTranslation();
  const { user: currentUser } = useAuth();
  
  const [users, setUsers] = useState<ExtendedUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  // Check if current user is super admin
  const [isSuperAdmin, setIsSuperAdmin] = useState(false);
  
  useEffect(() => {
    const checkSuperAdmin = async () => {
      if (!currentUser) return;
      
      const { data } = await supabase
        .from('users')
        .select('is_super_admin')
        .eq('id', currentUser.id)
        .single();
        
      setIsSuperAdmin(data?.is_super_admin || false);
    };
    
    checkSuperAdmin();
  }, [currentUser]);

  // Fetch all users
  const fetchUsers = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      let query = supabase
        .from('users')
        .select(`
          *,
          mosque:Mosque!users_mosque_id_fkey (
            id,
            name,
            Subdomain
          )
        `)
        .order('created_at', { ascending: false });

      // Filter by mosque if specified
      if (mosqueId) {
        query = query.eq('mosque_id', mosqueId);
      }

      const { data, error } = await query;

      if (error) throw error;
      setUsers(data || []);
    } catch (err) {
      const error = err as Error;
      setError(error);
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.fetchUsersFailed'),
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [mosqueId, toast, t]);

  // Create a new user (Note: This requires admin privileges)
  const createUser = useCallback(async (data: Partial<User>): Promise<User | null> => {
    try {
      setLoading(true);
      
      // This would typically require a server-side function to create users
      // For now, we'll just show an error
      throw new Error('User creation requires server-side implementation');
      
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.createUserFailed'),
        variant: 'destructive',
      });
      return null;
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Update a user
  const updateUser = useCallback(async (id: string, data: Partial<User>): Promise<User | null> => {
    try {
      setLoading(true);
      
      const { data: updated, error } = await supabase
        .from('users')
        .update(data)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      
      // Update local state
      setUsers(prev => prev.map(u => u.id === id ? { ...u, ...updated } : u));
      
      toast({
        title: t('common.success'),
        description: t('superAdmin.users.userUpdated'),
      });
      
      return updated;
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
      return null;
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Delete a user
  const deleteUser = useCallback(async (id: string): Promise<boolean> => {
    try {
      setLoading(true);
      
      const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', id);

      if (error) throw error;
      
      // Update local state
      setUsers(prev => prev.filter(u => u.id !== id));
      
      toast({
        title: t('common.success'),
        description: t('superAdmin.users.userDeleted'),
      });
      
      return true;
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.deleteFailed'),
        variant: 'destructive',
      });
      return false;
    } finally {
      setLoading(false);
    }
  }, [toast, t]);

  // Update user role
  const updateUserRole = useCallback(async (id: string, role: string): Promise<boolean> => {
    try {
      const { error } = await supabase
        .from('users')
        .update({ Role: role })
        .eq('id', id);

      if (error) throw error;
      
      // Update local state
      setUsers(prev => prev.map(u => u.id === id ? { ...u, Role: role } : u));
      
      toast({
        title: t('common.success'),
        description: t('superAdmin.users.roleUpdated'),
      });
      
      return true;
    } catch (err) {
      const error = err as Error;
      toast({
        title: t('common.error'),
        description: error.message || t('technical.errors.updateFailed'),
        variant: 'destructive',
      });
      return false;
    }
  }, [toast, t]);

  // Get user by ID
  const getUserById = useCallback((id: string): ExtendedUser | undefined => {
    return users.find(u => u.id === id);
  }, [users]);

  // Search users
  const searchUsers = useCallback((query: string): ExtendedUser[] => {
    const lowerQuery = query.toLowerCase();
    return users.filter(user => 
      user.full_name?.toLowerCase().includes(lowerQuery) ||
      user.email.toLowerCase().includes(lowerQuery) ||
      user.mosque?.name?.toLowerCase().includes(lowerQuery)
    );
  }, [users]);

  // Auto-fetch on mount
  useEffect(() => {
    if (autoFetch) {
      fetchUsers();
    }
  }, [autoFetch, fetchUsers]);

  // Real-time subscription
  useEffect(() => {
    if (!realtime) return;

    const channel = supabase
      .channel('users-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'users' },
        (payload) => {
          if (payload.eventType === 'INSERT') {
            // Fetch the full user with mosque data
            fetchUsers();
          } else if (payload.eventType === 'UPDATE') {
            setUsers(prev => prev.map(u => 
              u.id === (payload.new as User).id 
                ? { ...u, ...payload.new as User }
                : u
            ));
          } else if (payload.eventType === 'DELETE') {
            setUsers(prev => prev.filter(u => u.id !== (payload.old as User).id));
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [realtime, fetchUsers]);

  return {
    users,
    loading,
    error,
    fetchUsers,
    createUser,
    updateUser,
    deleteUser,
    getUserById,
    searchUsers,
    updateUserRole,
  };
}


================================================
FILE: src/integrations/supabase/client.ts
================================================
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://bpsahvbdlkzemwjdgxmq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJwc2FodmJkbGt6ZW13amRneG1xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE5NzY3NjIsImV4cCI6MjA2NzU1Mjc2Mn0.kWhAGqxK7Lx8Vigm2-1iJkfySn7f_zAYvhADu2xigK8";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});


================================================
FILE: src/lib/broadcastChannelManager.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import type { RealtimeChannel } from '@supabase/supabase-js';

export enum ConnectionState {
  DISCONNECTED = 'DISCONNECTED',
  CONNECTING = 'CONNECTING',
  CONNECTED = 'CONNECTED',
  RECONNECTING = 'RECONNECTING',
  FAILED = 'FAILED'
}

interface BroadcastCallback {
  id: string;
  event: string;
  callback: (payload: any) => void;
}

interface ManagedBroadcastChannel {
  channel: RealtimeChannel;
  channelName: string;
  listeners: Map<string, BroadcastCallback>;
  refCount: number;
  connectionState: ConnectionState;
  retryCount: number;
  lastActivity: number;
  retryTimeout?: NodeJS.Timeout;
  healthCheckInterval?: NodeJS.Timeout;
  lastConnectionAttempt: number;
  connectionAttempts: number[];
}

interface ChannelStats {
  totalChannels: number;
  totalListeners: number;
  channels: {
    name: string;
    listeners: number;
    state: ConnectionState;
    idleTime: number;
  }[];
}

/**
 * Centralized Broadcast Channel Manager for Supabase
 * Prevents connection explosion by reusing channels and managing lifecycle
 */
class BroadcastChannelManager {
  private static instance: BroadcastChannelManager;
  private channels: Map<string, ManagedBroadcastChannel> = new Map();
  private globalChannelLimit = 20; // Max concurrent broadcast channels
  private channelTimeout = 30 * 1000; // 30 seconds idle timeout (reduced from 5 minutes)
  private cleanupInterval: NodeJS.Timeout | null = null;
  private maxRetries = 5;
  private retryDelays = [1000, 2000, 4000, 8000, 16000, 30000];

  private constructor() {
    // Start cleanup interval
    this.cleanupInterval = setInterval(() => this.cleanupIdleChannels(), 60000);
    
    // Log initial state
    console.log('[BroadcastChannelManager] Initialized with limit:', this.globalChannelLimit);
  }

  static getInstance(): BroadcastChannelManager {
    if (!BroadcastChannelManager.instance) {
      BroadcastChannelManager.instance = new BroadcastChannelManager();
    }
    return BroadcastChannelManager.instance;
  }

  /**
   * Subscribe to a broadcast channel with automatic management
   */
  subscribe(
    channelName: string,
    listenerId: string,
    event: string,
    callback: (payload: any) => void,
    options?: {
      onConnectionStateChange?: (state: ConnectionState) => void;
    }
  ): () => void {
    console.log(`[BroadcastChannelManager] Subscribe request: ${channelName} - ${listenerId} - ${event}`);

    // Check channel limit
    if (!this.channels.has(channelName) && this.channels.size >= this.globalChannelLimit) {
      console.warn(`[BroadcastChannelManager] Channel limit reached (${this.globalChannelLimit})`);
      this.cleanupIdleChannels();
      
      if (this.channels.size >= this.globalChannelLimit) {
        console.error('[BroadcastChannelManager] Cannot create new channel - limit exceeded');
        options?.onConnectionStateChange?.(ConnectionState.FAILED);
        return () => {};
      }
    }

    let managedChannel = this.channels.get(channelName);

    if (!managedChannel) {
      // Create new channel
      managedChannel = this.createChannel(channelName);
      this.channels.set(channelName, managedChannel);
    }

    // Add listener
    const fullListenerId = `${listenerId}-${event}`;
    const broadcastCallback: BroadcastCallback = {
      id: fullListenerId,
      event,
      callback
    };

    // Check for duplicate listener
    if (managedChannel.listeners.has(fullListenerId)) {
      console.warn(`[BroadcastChannelManager] Duplicate listener attempted: ${fullListenerId}`);
      return () => this.unsubscribe(channelName, fullListenerId);
    }

    managedChannel.listeners.set(fullListenerId, broadcastCallback);
    managedChannel.refCount++;
    managedChannel.lastActivity = Date.now();

    // Setup channel if needed
    if (managedChannel.connectionState === ConnectionState.DISCONNECTED) {
      this.connectChannel(managedChannel, options?.onConnectionStateChange);
    } else {
      // Channel already connected, just add the listener
      this.addListenerToChannel(managedChannel, broadcastCallback);
      options?.onConnectionStateChange?.(managedChannel.connectionState);
    }

    // Return cleanup function
    return () => this.unsubscribe(channelName, fullListenerId);
  }

  /**
   * Create a new managed channel
   */
  private createChannel(channelName: string): ManagedBroadcastChannel {
    const channel = supabase.channel(channelName, {
      config: {
        broadcast: {
          self: false,
          ack: true
        }
      }
    });

    return {
      channel,
      channelName,
      listeners: new Map(),
      refCount: 0,
      connectionState: ConnectionState.DISCONNECTED,
      retryCount: 0,
      lastActivity: Date.now(),
      lastConnectionAttempt: 0,
      connectionAttempts: []
    };
  }

  /**
   * Check if circuit breaker should trip
   */
  private shouldTripCircuitBreaker(managedChannel: ManagedBroadcastChannel): boolean {
    const now = Date.now();
    const recentWindow = 60000; // 1 minute window
    
    // Clean up old attempts
    managedChannel.connectionAttempts = managedChannel.connectionAttempts.filter(
      attempt => now - attempt < recentWindow
    );
    
    // Add current attempt
    managedChannel.connectionAttempts.push(now);
    
    // Trip if more than 20 attempts in the last minute (more lenient)
    if (managedChannel.connectionAttempts.length > 20) {
      console.error(`[BroadcastChannelManager] Circuit breaker tripped for ${managedChannel.channelName}`);
      return true;
    }
    
    // Check if we're attempting too frequently (more than once per 2 seconds average)
    if (managedChannel.connectionAttempts.length > 5) {
      const avgInterval = recentWindow / managedChannel.connectionAttempts.length;
      if (avgInterval < 2000) {
        console.warn(`[BroadcastChannelManager] Rapid reconnection detected for ${managedChannel.channelName}`);
        return true;
      }
    }
    
    return false;
  }

  /**
   * Connect a channel and setup all listeners
   */
  private connectChannel(
    managedChannel: ManagedBroadcastChannel,
    onStateChange?: (state: ConnectionState) => void
  ) {
    // Check circuit breaker
    if (this.shouldTripCircuitBreaker(managedChannel)) {
      managedChannel.connectionState = ConnectionState.FAILED;
      onStateChange?.(ConnectionState.FAILED);
      return;
    }
    
    managedChannel.connectionState = ConnectionState.CONNECTING;
    managedChannel.lastConnectionAttempt = Date.now();
    onStateChange?.(ConnectionState.CONNECTING);

    // Clear any existing retry timeout
    if (managedChannel.retryTimeout) {
      clearTimeout(managedChannel.retryTimeout);
      managedChannel.retryTimeout = undefined;
    }

    // Add all listeners to the channel
    managedChannel.listeners.forEach(listener => {
      this.addListenerToChannel(managedChannel, listener);
    });

    // Subscribe to the channel
    managedChannel.channel.subscribe((status, error) => {
      console.log(`[BroadcastChannelManager] Channel ${managedChannel.channelName} status:`, status);

      if (status === 'SUBSCRIBED') {
        managedChannel.connectionState = ConnectionState.CONNECTED;
        managedChannel.retryCount = 0;
        managedChannel.lastActivity = Date.now();
        // Clear connection attempts on successful connection
        managedChannel.connectionAttempts = [];
        onStateChange?.(ConnectionState.CONNECTED);
        
        // Notify all listeners
        managedChannel.listeners.forEach(listener => {
          if (listener.callback) {
            // Send a connection success event if needed
          }
        });
      } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || error) {
        this.handleConnectionError(managedChannel, onStateChange);
      } else if (status === 'CLOSED') {
        this.handleConnectionError(managedChannel, onStateChange);
      }
    });

    // Setup health monitoring
    this.monitorChannelHealth(managedChannel, onStateChange);
  }

  /**
   * Add a listener to an existing channel
   */
  private addListenerToChannel(
    managedChannel: ManagedBroadcastChannel,
    listener: BroadcastCallback
  ) {
    managedChannel.channel.on('broadcast', { event: listener.event }, (payload) => {
      managedChannel.lastActivity = Date.now();
      listener.callback(payload.payload);
    });
  }

  /**
   * Handle connection errors with retry logic
   */
  private handleConnectionError(
    managedChannel: ManagedBroadcastChannel,
    onStateChange?: (state: ConnectionState) => void
  ) {
    // Don't retry if channel has no listeners - it's been abandoned
    if (managedChannel.listeners.size === 0) {
      console.log(`[BroadcastChannelManager] Channel ${managedChannel.channelName} has no listeners, not retrying`);
      managedChannel.connectionState = ConnectionState.DISCONNECTED;
      return;
    }

    if (managedChannel.retryCount >= this.maxRetries) {
      console.error(`[BroadcastChannelManager] Max retries reached for ${managedChannel.channelName}`);
      managedChannel.connectionState = ConnectionState.FAILED;
      onStateChange?.(ConnectionState.FAILED);
      return;
    }

    const delay = this.retryDelays[Math.min(managedChannel.retryCount, this.retryDelays.length - 1)];
    managedChannel.connectionState = ConnectionState.RECONNECTING;
    managedChannel.retryCount++;
    onStateChange?.(ConnectionState.RECONNECTING);

    console.log(`[BroadcastChannelManager] Retrying ${managedChannel.channelName} in ${delay}ms (attempt ${managedChannel.retryCount})`);

    managedChannel.retryTimeout = setTimeout(() => {
      // Double-check channel still exists and has listeners before reconnecting
      if (this.channels.has(managedChannel.channelName) && managedChannel.listeners.size > 0) {
        this.connectChannel(managedChannel, onStateChange);
      }
    }, delay);
  }

  /**
   * Monitor channel health
   */
  private monitorChannelHealth(
    managedChannel: ManagedBroadcastChannel,
    onStateChange?: (state: ConnectionState) => void
  ) {
    // Clear any existing health check
    if (managedChannel.healthCheckInterval) {
      clearInterval(managedChannel.healthCheckInterval);
    }
    
    // Store health check interval on the managed channel
    managedChannel.healthCheckInterval = setInterval(() => {
      if (!this.channels.has(managedChannel.channelName)) {
        if (managedChannel.healthCheckInterval) {
          clearInterval(managedChannel.healthCheckInterval);
          managedChannel.healthCheckInterval = undefined;
        }
        return;
      }

      const state = managedChannel.channel.state;
      if (state === 'closed' && managedChannel.connectionState === ConnectionState.CONNECTED) {
        console.warn(`[BroadcastChannelManager] Channel ${managedChannel.channelName} unexpectedly closed`);
        this.handleConnectionError(managedChannel, onStateChange);
      }
    }, 5000);
  }

  /**
   * Unsubscribe a listener from a channel
   */
  private unsubscribe(channelName: string, listenerId: string) {
    const managedChannel = this.channels.get(channelName);
    if (!managedChannel) return;

    console.log(`[BroadcastChannelManager] Unsubscribe: ${channelName} - ${listenerId}`);

    // Remove listener
    managedChannel.listeners.delete(listenerId);
    managedChannel.refCount--;
    managedChannel.lastActivity = Date.now();

    // If no more listeners, mark as idle but don't remove immediately
    // Let the cleanup interval handle removal to avoid race conditions
    if (managedChannel.refCount <= 0 || managedChannel.listeners.size === 0) {
      console.log(`[BroadcastChannelManager] Channel ${channelName} has no more listeners, marking for cleanup`);
      // Don't remove immediately - let cleanup interval handle it
      // This prevents race conditions with retry logic
    }
  }

  /**
   * Remove a channel completely
   */
  removeChannel(channelName: string) {
    const managedChannel = this.channels.get(channelName);
    if (!managedChannel) return;

    console.log(`[BroadcastChannelManager] Removing channel ${channelName}. Total: ${this.channels.size - 1}`);

    // Clear retry timeout
    if (managedChannel.retryTimeout) {
      clearTimeout(managedChannel.retryTimeout);
      managedChannel.retryTimeout = undefined;
    }
    
    // Clear health check interval
    if (managedChannel.healthCheckInterval) {
      clearInterval(managedChannel.healthCheckInterval);
      managedChannel.healthCheckInterval = undefined;
    }

    // Unsubscribe and remove channel
    managedChannel.channel.unsubscribe();
    supabase.removeChannel(managedChannel.channel);
    this.channels.delete(channelName);
  }

  /**
   * Clean up idle channels
   */
  private cleanupIdleChannels() {
    const now = Date.now();
    const channelsToRemove: string[] = [];

    this.channels.forEach((managedChannel, channelName) => {
      // Only remove if:
      // 1. Channel has been idle for timeout period
      // 2. No listeners
      // 3. Not currently retrying (no pending retry timeout)
      // 4. Not in connecting state
      if (
        now - managedChannel.lastActivity > this.channelTimeout && 
        managedChannel.listeners.size === 0 &&
        !managedChannel.retryTimeout &&
        managedChannel.connectionState !== ConnectionState.CONNECTING &&
        managedChannel.connectionState !== ConnectionState.RECONNECTING
      ) {
        channelsToRemove.push(channelName);
      }
    });

    channelsToRemove.forEach(channelName => {
      console.log(`[BroadcastChannelManager] Removing idle channel: ${channelName}`);
      this.removeChannel(channelName);
    });
  }

  /**
   * Get current statistics
   */
  getStats(): ChannelStats {
    const stats: ChannelStats = {
      totalChannels: this.channels.size,
      totalListeners: 0,
      channels: []
    };

    this.channels.forEach((managedChannel, channelName) => {
      stats.totalListeners += managedChannel.listeners.size;
      stats.channels.push({
        name: channelName,
        listeners: managedChannel.listeners.size,
        state: managedChannel.connectionState,
        idleTime: Date.now() - managedChannel.lastActivity
      });
    });

    return stats;
  }

  /**
   * Force cleanup all channels
   */
  cleanup() {
    console.log('[BroadcastChannelManager] Cleaning up all broadcast channels');
    this.channels.forEach((_, channelName) => {
      this.removeChannel(channelName);
    });
    this.channels.clear();

    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }

  /**
   * Check if near channel limit
   */
  isNearLimit(): boolean {
    return this.channels.size >= this.globalChannelLimit * 0.8;
  }

  /**
   * Reset circuit breaker for a specific channel
   * Useful when manually cleaning up before reconnecting
   */
  resetChannelState(channelName: string) {
    const managedChannel = this.channels.get(channelName);
    if (managedChannel) {
      console.log(`[BroadcastChannelManager] Resetting channel state for ${channelName}`);
      
      // Clear any pending retry timeout
      if (managedChannel.retryTimeout) {
        clearTimeout(managedChannel.retryTimeout);
        managedChannel.retryTimeout = undefined;
      }
      
      // Reset all connection state
      managedChannel.connectionAttempts = [];
      managedChannel.retryCount = 0;
      managedChannel.connectionState = ConnectionState.DISCONNECTED;
      managedChannel.lastActivity = Date.now();
    }
  }
}

// Export singleton instance
export const broadcastChannelManager = BroadcastChannelManager.getInstance();

// Cleanup on window unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    broadcastChannelManager.cleanup();
  });
}


================================================
FILE: src/lib/supabase.ts
================================================
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey)


================================================
FILE: src/lib/supabaseConnectionManager.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';

type ChannelCallback = (payload: RealtimePostgresChangesPayload<any>) => void;

interface SubscriptionConfig {
  event: '*' | 'INSERT' | 'UPDATE' | 'DELETE';
  schema: string;
  table: string;
  filter?: string;
  callback: ChannelCallback;
}

interface ManagedChannel {
  channel: RealtimeChannel;
  subscriptions: Map<string, SubscriptionConfig>;
  refCount: number;
  lastActivity: number;
}

/**
 * Centralized Supabase connection manager to prevent connection explosion.
 * Ensures only one channel per logical group and proper cleanup.
 */
class SupabaseConnectionManager {
  private static instance: SupabaseConnectionManager;
  private channels: Map<string, ManagedChannel> = new Map();
  private globalChannelLimit = 10; // Max 10 concurrent channels
  private channelTimeout = 5 * 60 * 1000; // 5 minutes idle timeout
  private cleanupInterval: NodeJS.Timeout | null = null;

  private constructor() {
    // Start cleanup interval
    this.cleanupInterval = setInterval(() => this.cleanupIdleChannels(), 60000); // Every minute
  }

  static getInstance(): SupabaseConnectionManager {
    if (!SupabaseConnectionManager.instance) {
      SupabaseConnectionManager.instance = new SupabaseConnectionManager();
    }
    return SupabaseConnectionManager.instance;
  }

  /**
   * Subscribe to a Postgres table with automatic channel management
   */
  subscribe(
    channelName: string,
    subscriptionId: string,
    config: SubscriptionConfig
  ): () => void {
    // Check global channel limit
    if (!this.channels.has(channelName) && this.channels.size >= this.globalChannelLimit) {
      console.warn(`Channel limit reached (${this.globalChannelLimit}). Cleaning up idle channels.`);
      this.cleanupIdleChannels();
      
      // If still at limit, reject new subscription
      if (this.channels.size >= this.globalChannelLimit) {
        console.error('Cannot create new channel - limit exceeded');
        return () => {}; // Return no-op cleanup function
      }
    }

    let managedChannel = this.channels.get(channelName);

    if (!managedChannel) {
      // Create new channel
      const channel = supabase.channel(channelName);
      managedChannel = {
        channel,
        subscriptions: new Map(),
        refCount: 0,
        lastActivity: Date.now(),
      };
      this.channels.set(channelName, managedChannel);
    }

    // Add subscription to channel
    const subscriptionKey = `${config.table}-${config.event}-${subscriptionId}`;
    
    // Check if this exact subscription already exists
    if (managedChannel.subscriptions.has(subscriptionKey)) {
      console.warn(`Duplicate subscription attempted: ${subscriptionKey}`);
      return () => this.unsubscribe(channelName, subscriptionId, subscriptionKey);
    }

    managedChannel.subscriptions.set(subscriptionKey, config);
    managedChannel.refCount++;
    managedChannel.lastActivity = Date.now();

    // Configure channel if not already subscribed
    if (managedChannel.channel.state !== 'joined' && managedChannel.channel.state !== 'joining') {
      // Add all subscriptions to the channel
      managedChannel.subscriptions.forEach((sub) => {
        const eventConfig: any = {
          event: sub.event,
          schema: sub.schema,
          table: sub.table,
        };
        if (sub.filter) {
          eventConfig.filter = sub.filter;
        }
        managedChannel!.channel.on('postgres_changes', eventConfig, sub.callback);
      });

      // Subscribe the channel
      managedChannel.channel.subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log(`Channel ${channelName} connected. Total channels: ${this.channels.size}`);
        } else if (status === 'CHANNEL_ERROR') {
          console.error(`Channel ${channelName} error`);
        }
      });
    } else {
      // Channel already exists, just add the new subscription
      const eventConfig: any = {
        event: config.event,
        schema: config.schema,
        table: config.table,
      };
      if (config.filter) {
        eventConfig.filter = config.filter;
      }
      managedChannel.channel.on('postgres_changes', eventConfig, config.callback);
    }

    // Return cleanup function
    return () => this.unsubscribe(channelName, subscriptionId, subscriptionKey);
  }

  /**
   * Unsubscribe from a channel
   */
  private unsubscribe(channelName: string, subscriptionId: string, subscriptionKey: string) {
    const managedChannel = this.channels.get(channelName);
    if (!managedChannel) return;

    // Remove subscription
    managedChannel.subscriptions.delete(subscriptionKey);
    managedChannel.refCount--;
    managedChannel.lastActivity = Date.now();

    // If no more subscriptions, schedule channel for removal
    if (managedChannel.refCount <= 0 || managedChannel.subscriptions.size === 0) {
      this.removeChannel(channelName);
    }
  }

  /**
   * Remove a channel completely
   */
  private removeChannel(channelName: string) {
    const managedChannel = this.channels.get(channelName);
    if (!managedChannel) return;

    console.log(`Removing channel ${channelName}. Total channels: ${this.channels.size - 1}`);
    
    // Unsubscribe and remove channel
    managedChannel.channel.unsubscribe();
    supabase.removeChannel(managedChannel.channel);
    this.channels.delete(channelName);
  }

  /**
   * Clean up idle channels
   */
  private cleanupIdleChannels() {
    const now = Date.now();
    const channelsToRemove: string[] = [];

    this.channels.forEach((managedChannel, channelName) => {
      // Remove channels idle for more than timeout period
      if (now - managedChannel.lastActivity > this.channelTimeout) {
        channelsToRemove.push(channelName);
      }
    });

    channelsToRemove.forEach(channelName => {
      console.log(`Removing idle channel: ${channelName}`);
      this.removeChannel(channelName);
    });
  }

  /**
   * Get current connection statistics
   */
  getStats() {
    const stats = {
      totalChannels: this.channels.size,
      totalSubscriptions: 0,
      channels: [] as {
        name: string;
        subscriptions: number;
        state: string;
        idleTime: number;
      }[],
    };

    this.channels.forEach((managedChannel, channelName) => {
      stats.totalSubscriptions += managedChannel.subscriptions.size;
      stats.channels.push({
        name: channelName,
        subscriptions: managedChannel.subscriptions.size,
        state: managedChannel.channel.state || 'unknown',
        idleTime: Date.now() - managedChannel.lastActivity,
      });
    });

    return stats;
  }

  /**
   * Force cleanup all channels
   */
  cleanup() {
    console.log('Cleaning up all Supabase channels');
    this.channels.forEach((_, channelName) => {
      this.removeChannel(channelName);
    });
    this.channels.clear();
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }

  /**
   * Check if we're approaching connection limits
   */
  isNearLimit(): boolean {
    return this.channels.size >= this.globalChannelLimit * 0.8;
  }
}

// Export singleton instance
export const connectionManager = SupabaseConnectionManager.getInstance();

// Cleanup on window unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    connectionManager.cleanup();
  });
}


================================================
FILE: src/lib/supabaseMonitoring.ts
================================================
import { broadcastChannelManager } from './broadcastChannelManager';
import { connectionManager } from './supabaseConnectionManager';

interface ConnectionMetrics {
  timestamp: number;
  broadcastChannels: {
    total: number;
    listeners: number;
    nearLimit: boolean;
  };
  databaseChannels: {
    total: number;
    subscriptions: number;
    nearLimit: boolean;
  };
  totalConnections: number;
  warnings: string[];
}

/**
 * Production monitoring for Supabase connections
 * Tracks metrics and sends to analytics/monitoring service
 */
class SupabaseMonitoring {
  private static instance: SupabaseMonitoring;
  private metricsInterval: NodeJS.Timeout | null = null;
  private metricsHistory: ConnectionMetrics[] = [];
  private maxHistorySize = 100;
  private warningThreshold = 0.8; // 80% of limits

  private constructor() {
    this.startMonitoring();
  }

  static getInstance(): SupabaseMonitoring {
    if (!SupabaseMonitoring.instance) {
      SupabaseMonitoring.instance = new SupabaseMonitoring();
    }
    return SupabaseMonitoring.instance;
  }

  private startMonitoring() {
    // Collect metrics every 30 seconds
    this.metricsInterval = setInterval(() => {
      this.collectMetrics();
    }, 30000);

    // Initial collection
    this.collectMetrics();
  }

  private collectMetrics() {
    const broadcastStats = broadcastChannelManager.getStats();
    const databaseStats = connectionManager.getStats();
    const warnings: string[] = [];

    // Check for warnings
    if (broadcastChannelManager.isNearLimit()) {
      warnings.push('Broadcast channels near limit');
    }
    if (connectionManager.isNearLimit()) {
      warnings.push('Database channels near limit');
    }

    const metrics: ConnectionMetrics = {
      timestamp: Date.now(),
      broadcastChannels: {
        total: broadcastStats.totalChannels,
        listeners: broadcastStats.totalListeners,
        nearLimit: broadcastChannelManager.isNearLimit()
      },
      databaseChannels: {
        total: databaseStats.totalChannels,
        subscriptions: databaseStats.totalSubscriptions,
        nearLimit: connectionManager.isNearLimit()
      },
      totalConnections: broadcastStats.totalChannels + databaseStats.totalChannels,
      warnings
    };

    // Store in history
    this.metricsHistory.push(metrics);
    if (this.metricsHistory.length > this.maxHistorySize) {
      this.metricsHistory.shift();
    }

    // Send to monitoring service
    this.sendMetrics(metrics);

    // Log warnings
    if (warnings.length > 0) {
      console.warn('[SupabaseMonitoring] Warnings:', warnings);
    }
  }

  private sendMetrics(metrics: ConnectionMetrics) {
    // In production, send to your monitoring service
    // Example: Sentry, DataDog, CloudWatch, etc.
    
    if (process.env.NODE_ENV === 'production') {
      // Example: Send to analytics
      if (typeof window !== 'undefined' && (window as any).analytics) {
        (window as any).analytics.track('supabase_connections', {
          broadcast_channels: metrics.broadcastChannels.total,
          database_channels: metrics.databaseChannels.total,
          total_connections: metrics.totalConnections,
          has_warnings: metrics.warnings.length > 0,
          warnings: metrics.warnings
        });
      }

      // Example: Custom monitoring endpoint
      fetch('/api/monitoring/supabase', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(metrics)
      }).catch(err => {
        console.error('[SupabaseMonitoring] Failed to send metrics:', err);
      });
    } else {
      // In development, just log
      console.log('[SupabaseMonitoring] Metrics:', metrics);
    }
  }

  /**
   * Get current connection metrics
   */
  getCurrentMetrics(): ConnectionMetrics | null {
    return this.metricsHistory[this.metricsHistory.length - 1] || null;
  }

  /**
   * Get metrics history
   */
  getMetricsHistory(): ConnectionMetrics[] {
    return [...this.metricsHistory];
  }

  /**
   * Check if connections are healthy
   */
  isHealthy(): boolean {
    const current = this.getCurrentMetrics();
    if (!current) return true;
    
    return current.warnings.length === 0 && 
           current.totalConnections < 50; // Adjust based on your limits
  }

  /**
   * Force a metrics collection
   */
  forceCollect() {
    this.collectMetrics();
  }

  /**
   * Stop monitoring
   */
  stop() {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
      this.metricsInterval = null;
    }
  }
}

// Export singleton instance
export const supabaseMonitoring = SupabaseMonitoring.getInstance();

// Auto-start monitoring
if (typeof window !== 'undefined') {
  // Report on page unload
  window.addEventListener('beforeunload', () => {
    const metrics = supabaseMonitoring.getCurrentMetrics();
    if (metrics && metrics.warnings.length > 0) {
      // Send final warning metrics
      navigator.sendBeacon?.('/api/monitoring/supabase-warnings', JSON.stringify(metrics));
    }
  });

  // Report on visibility change (mobile background)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
      supabaseMonitoring.forceCollect();
    }
  });
}


================================================
FILE: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: src/lib/__tests__/broadcastChannelManager.test.ts
================================================
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { broadcastChannelManager, ConnectionState } from '../broadcastChannelManager';

// Mock Supabase
vi.mock('@/integrations/supabase/client', () => ({
  supabase: {
    channel: vi.fn(() => ({
      on: vi.fn().mockReturnThis(),
      subscribe: vi.fn((callback) => {
        setTimeout(() => callback('SUBSCRIBED'), 0);
        return { unsubscribe: vi.fn() };
      }),
      unsubscribe: vi.fn(),
      state: 'joined'
    })),
    removeChannel: vi.fn()
  }
}));

describe('BroadcastChannelManager', () => {
  beforeEach(() => {
    // Clean up any existing channels
    broadcastChannelManager.cleanup();
  });

  afterEach(() => {
    broadcastChannelManager.cleanup();
  });

  it('should create a singleton instance', () => {
    const instance1 = broadcastChannelManager;
    const instance2 = broadcastChannelManager;
    expect(instance1).toBe(instance2);
  });

  it('should reuse channels for the same channel name', () => {
    const callback1 = vi.fn();
    const callback2 = vi.fn();

    const cleanup1 = broadcastChannelManager.subscribe(
      'test-channel',
      'listener-1',
      'test-event',
      callback1
    );

    const cleanup2 = broadcastChannelManager.subscribe(
      'test-channel',
      'listener-2',
      'test-event',
      callback2
    );

    const stats = broadcastChannelManager.getStats();
    expect(stats.totalChannels).toBe(1);
    expect(stats.totalListeners).toBe(2);

    cleanup1();
    cleanup2();
  });

  it('should remove channel when last listener unsubscribes', () => {
    const callback = vi.fn();

    const cleanup = broadcastChannelManager.subscribe(
      'test-channel',
      'listener-1',
      'test-event',
      callback
    );

    expect(broadcastChannelManager.getStats().totalChannels).toBe(1);

    cleanup();

    expect(broadcastChannelManager.getStats().totalChannels).toBe(0);
  });

  it('should prevent duplicate listeners', () => {
    const callback = vi.fn();

    const cleanup1 = broadcastChannelManager.subscribe(
      'test-channel',
      'listener-1',
      'test-event',
      callback
    );

    const cleanup2 = broadcastChannelManager.subscribe(
      'test-channel',
      'listener-1',
      'test-event',
      callback
    );

    const stats = broadcastChannelManager.getStats();
    expect(stats.totalListeners).toBe(1);

    cleanup1();
    cleanup2();
  });

  it('should handle connection state changes', async () => {
    const stateChanges: ConnectionState[] = [];
    const callback = vi.fn();

    broadcastChannelManager.subscribe(
      'test-channel',
      'listener-1',
      'test-event',
      callback,
      {
        onConnectionStateChange: (state) => {
          stateChanges.push(state);
        }
      }
    );

    // Wait for async subscription
    await new Promise(resolve => setTimeout(resolve, 100));

    expect(stateChanges).toContain(ConnectionState.CONNECTING);
    expect(stateChanges).toContain(ConnectionState.CONNECTED);
  });

  it('should report when near channel limit', () => {
    // Create channels up to 80% of limit
    const cleanups: (() => void)[] = [];
    
    for (let i = 0; i < 16; i++) {
      cleanups.push(
        broadcastChannelManager.subscribe(
          `test-channel-${i}`,
          'listener-1',
          'test-event',
          vi.fn()
        )
      );
    }

    expect(broadcastChannelManager.isNearLimit()).toBe(true);

    // Cleanup
    cleanups.forEach(cleanup => cleanup());
  });

  it('should cleanup all channels on cleanup()', () => {
    // Create multiple channels
    for (let i = 0; i < 5; i++) {
      broadcastChannelManager.subscribe(
        `test-channel-${i}`,
        'listener-1',
        'test-event',
        vi.fn()
      );
    }

    expect(broadcastChannelManager.getStats().totalChannels).toBe(5);

    broadcastChannelManager.cleanup();

    expect(broadcastChannelManager.getStats().totalChannels).toBe(0);
  });
});


================================================
FILE: src/lib/translations/ar.ts
================================================
import { TranslationStructure } from './types';

export const ar: TranslationStructure = {
  common: {
    signOut: 'تسجيل الخروج',
    loading: 'جارٍ التحميل...',
    error: 'خطأ',
    retry: 'إعادة المحاولة',
    save: 'حفظ',
    cancel: 'إلغاء',
    delete: 'حذف',
    edit: 'تعديل',
    create: 'إنشاء',
    update: 'تحديث',
    actions: 'الإجراءات',
    tryAgain: 'حاول مرة أخرى',
    success: 'نجح',
    id: 'المعرف',
    status: 'الحالة',
    created: 'تم الإنشاء',
    saveChanges: 'حفظ التغييرات',
    updating: 'جارٍ التحديث...',
    refresh: 'تحديث',
    lastUpdated: 'آخر تحديث',
    active: 'نشط',
    pending: 'في الانتظار',
    notSet: 'غير محدد',
    live: 'مباشر',
    offline: 'غير متصل',
    monitor: 'مراقبة',
    preparing: 'جارٍ التحضير...',
    inactive: 'غير نشط',
    completed: 'مكتمل',
    total: 'المجموع',
    title: 'العنوان',
    mosque: 'المسجد',
    from: 'من',
    to: 'إلى',
    createdAt: 'تاريخ الإنشاء',
    unknown: 'غير معروف',
    room: 'الغرفة',
    user: 'المستخدم',
    email: 'البريد الإلكتروني',
    role: 'الدور',
    joinedAt: 'تاريخ الانضمام',
    admin: 'مدير',
    superAdmin: 'مدير عام',
    users: 'المستخدمون',
    admins: 'المديرون',
    all: 'الكل',
    allMosques: 'كل المساجد',
    allStatuses: 'كل الحالات',
    allTime: 'كل الوقت',
    today: 'اليوم',
    lastWeek: 'الأسبوع الماضي',
    lastMonth: 'الشهر الماضي',
    search: 'بحث',
    filter: 'تصفية',
    export: 'تصدير',
    import: 'استيراد',
    noResultsFound: 'لم يتم العثور على نتائج لبحثك',
    unauthorized: 'غير مصرح لك بالوصول إلى هذه الصفحة',
    comingSoon: 'قريباً',
    featureNotImplemented: 'هذه الميزة لم يتم تطبيقها بعد',
    avgDuration: 'متوسط المدة',
    avgSentences: 'متوسط الجمل',
    sentences: 'الجمل',
    transcripts: 'النصوص',
    startTime: 'وقت البداية',
    replay: 'إعادة التشغيل',
    confirmDelete: 'تأكيد الحذف',
    saving: 'جارٍ الحفظ...',
    quickActions: 'الإجراءات السريعة',
    recentActivity: 'النشاط الأخير',
    noRecentActivity: 'لا يوجد نشاط حديث للعرض',
    noRecentActivityDescription: 'سيظهر النشاط هنا عند تنفيذ الإجراءات',
    noMosque: 'بدون مسجد',
    unnamed: 'بدون اسم',
    editMosque: 'تعديل المسجد',
    editDescription: 'تحديث تفاصيل المسجد',
    deleteConfirmation: 'هل أنت متأكد من حذف {name}؟ لا يمكن التراجع عن هذا الإجراء.',
    mosqueDeleted: 'تم حذف المسجد بنجاح',
    mosqueUpdated: 'تم تحديث المسجد بنجاح',
    description: 'الوصف',
    subdomain: 'النطاق الفرعي',
    bayanPlatform: 'منصة بيان',
    goToDashboard: 'الذهاب إلى لوحة التحكم',
    viewPublicSpeeches: 'عرض الخطب العامة',
    showing: 'عرض',
    of: 'من',
    previous: 'السابق',
    next: 'التالي',
    rooms: 'غرف',
    sessions: 'جلسات',
  },
  dashboard: {
    title: 'لوحة التحكم',
    superAdminTitle: 'لوحة تحكم المدير العام',
    mosqueAdminTitle: 'لوحة تحكم إدارة المسجد',
    welcome: 'مرحباً',
    loadingProfile: 'جارٍ تحميل الملف الشخصي...',
    errorLoadingProfile: 'خطأ في تحميل الملف الشخصي. يرجى المحاولة مرة أخرى.',
    loadingDashboard: 'جارٍ تحميل لوحة التحكم...',
    profileNotFound: 'لم يتم العثور على ملف تعريف المستخدم. يرجى الاتصال بالمسؤول لإعداد حسابك.',
    defaultMosqueName: 'الفرقان',
    superAdminSubtitle: 'إدارة مستأجري المساجد',
    mosqueAdminSubtitle: 'إدارة الخطب والفعاليات',
    history: 'السجل',
    overview: 'نظرة عامة',
    mosques: 'المساجد',
    users: 'المستخدمون',
    prompts: 'المطالبات',
    settings: 'الإعدادات',
    rooms: 'الغرف',
    monitor: 'المراقبة',
    sessions: 'الجلسات',
    billing: 'الاستخدام',
    sessionArchive: 'أرشيف الجلسات',
  },
  navigation: {
    dashboard: 'لوحة التحكم',
    rooms: 'الغرف',
    users: 'المستخدمون',
    settings: 'الإعدادات',
  },
  superAdmin: {
    stats: {
      totalMosques: 'إجمالي المساجد',
      activeTenants: 'المستأجرون النشطون على المنصة',
      liveUpdates: 'التحديثات المباشرة',
      realTime: 'في الوقت الفعلي',
      autoRefreshing: 'تحديث تلقائي للبيانات',
      quickAction: 'إجراء سريع',
      addNewMosque: 'إضافة مسجد جديد',
      systemOverview: 'نظرة عامة على النظام والإحصائيات',
      registeredUsers: 'المستخدمون المسجلون',
      configuredTemplates: 'القوالب المكونة',
    },
    onboarding: {
      title: 'إضافة مستأجر جديد',
      description: 'إنشاء مسجد جديد مع حساب مدير',
      mosqueName: 'اسم المسجد',
      mosqueNamePlaceholder: 'أدخل اسم المسجد...',
      createMosque: 'إنشاء مسجد ونشره',
      creatingMosque: 'جارٍ إنشاء المسجد...',
      mosqueCreated: 'تم إنشاء المسجد "{name}" مع النطاق الفرعي "{subdomain}".',
      mosqueExists: 'يوجد مسجد بالنطاق الفرعي "{subdomain}" بالفعل',
      mosqueFailed: 'فشل في إنشاء المسجد',
    },
    mosques: {
      title: 'المساجد المُدارة',
      loadingMosques: 'جارٍ تحميل المساجد...',
      noMosquesFound: 'لم يتم العثور على مساجد',
      noMosquesDescription: 'ابدأ بإضافة أول مسجد إلى المنصة.',
      addFirstMosque: 'إضافة أول مسجد',
      mosqueName: 'اسم المسجد',
      subdomain: 'النطاق الفرعي',
      viewUsers: 'عرض المستخدمين',
      hideUsers: 'إخفاء المستخدمين',
      description: 'إدارة جميع المساجد على المنصة',
      editMosque: 'تعديل المسجد',
      editDescription: 'تحديث تفاصيل المسجد',
      deleteConfirmation: 'هل أنت متأكد من حذف {name}؟ لا يمكن التراجع عن هذا الإجراء.',
      mosqueDeleted: 'تم حذف المسجد بنجاح',
      mosqueUpdated: 'تم تحديث المسجد بنجاح',
    },
    validation: {
      mosqueNameMin: 'يجب أن يكون اسم المسجد على الأقل حرفين',
      mosqueNameMax: 'يجب أن يكون اسم المسجد أقل من 100 حرف',
      templateNameMin: 'يجب أن يكون اسم القالب على الأقل حرفين',
    },
    templates: {
      spokenLanguage: 'اللغة المنطوقة',
      translationLanguage: 'لغة الترجمة',
    },
    rooms: {
      description: 'إدارة جميع الغرف عبر جميع المساجد في النظام',
      totalRooms: 'إجمالي الغرف عبر جميع المساجد',
      activeRooms: 'يتم بثها حالياً',
      pendingRooms: 'جارٍ الإعداد',
      inactiveRooms: 'غير مستخدمة',
      allRooms: 'كل الغرف',
      searchPlaceholder: 'البحث بعنوان الغرفة أو المسجد أو اسم LiveKit...',
      filterByMosque: 'تصفية حسب المسجد',
      filterByStatus: 'تصفية حسب الحالة',
      noRoomsFound: 'لم يتم العثور على غرف',
      noRoomsDescription: 'لم يتم إنشاء أي غرف بعد.',
      monitoringComingSoon: 'مراقبة متعددة المساجد قريباً',
      statusUpdated: 'تم تحديث حالة الغرفة بنجاح',
      roomsDeleted: 'تم حذف الغرف المحددة بنجاح',
    },
    sessions: {
      description: 'عرض وإدارة سجل الجلسات عبر جميع المساجد',
      totalSessions: 'إجمالي الجلسات المسجلة',
      activeSessions: 'مباشرة حالياً',
      completedSessions: 'الجلسات المنتهية',
      averageDuration: 'متوسط طول الجلسة',
      averageSentences: 'متوسط الجمل لكل جلسة',
      totalSentences: 'إجمالي الجمل المترجمة',
      sessionHistory: 'سجل الجلسات',
      searchPlaceholder: 'البحث بالغرفة أو المسجد أو معرف الجلسة...',
      filterByMosque: 'تصفية حسب المسجد',
      filterByDate: 'تصفية حسب التاريخ',
      noSessionsFound: 'لم يتم العثور على جلسات',
      noSessionsDescription: 'لم يتم تسجيل أي جلسات بعد.',
    },
    users: {
      description: 'إدارة جميع المستخدمين عبر المنصة',
      title: 'كل المستخدمين',
      searchPlaceholder: 'البحث بالاسم أو البريد الإلكتروني أو المسجد...',
      filterByMosque: 'تصفية حسب المسجد',
      noUsersFound: 'لم يتم العثور على مستخدمين',
      noUsersDescription: 'لم يتم تسجيل أي مستخدمين بعد.',
      userDeleted: 'تم حذف المستخدم بنجاح',
      roleUpdated: 'تم تحديث دور المستخدم بنجاح',
      impersonate: 'انتحال شخصية المستخدم',
      impersonating: 'انتحال شخصية {name}',
      deleteConfirmation: 'هل أنت متأكد من حذف {name}؟ لا يمكن التراجع عن هذا الإجراء.',
      bulkActions: 'الإجراءات المجمعة',
      makeAdmin: 'جعل مدير',
      makeUser: 'جعل مستخدم',
      deleteSelected: 'حذف المحدد',
      bulkDeleteConfirmation: 'هل أنت متأكد من حذف {count} مستخدمين؟ لا يمكن التراجع عن هذا الإجراء.',
      bulkDeleteSuccess: 'تم حذف {count} مستخدمين بنجاح',
      bulkRoleUpdateSuccess: 'تم تحديث الدور لـ {count} مستخدمين بنجاح',
      exportSuccess: 'تم تصدير المستخدمين بنجاح',
    },
    prompts: {
      description: 'إدارة قوالب مطالبات الذكاء الاصطناعي لجميع المساجد',
    },
  },
  mosqueAdmin: {
    tabs: {
      roomManagement: 'إدارة الغرف',
      liveMonitor: 'المراقب المباشر',
    },
    stats: {
      totalRooms: 'إجمالي الغرف',
      available: 'متاح',
      statusMonitorError: 'خطأ في مراقب الحالة',
      activeRooms: 'الغرف النشطة',
      currentlyActive: 'نشطة حالياً',
      mosqueOverview: 'نظرة عامة على المسجد والإحصائيات',
    },
    rooms: {
      title: 'مراقبة حالة الغرف',
      createNew: 'إنشاء غرفة جديدة',
      manageRooms: 'إدارة الغرف',
      roomTitle: 'عنوان الغرفة',
      roomTitlePlaceholder: 'أدخل عنوان الغرفة...',
      maxDelay: 'أقصى تأخير (ثواني)',
      maxDelayDescription: 'التأخير الأعلى يوفر ترجمات أكثر دقة من خلال الانتظار لفترة أطول للجمل الكاملة. القيم الأقل تعطي الأولوية للسرعة على الدقة.',
      punctuationSensitivity: 'حساسية علامات الترقيم',
      punctuationSensitivityDescription: 'الحساسية الأعلى تنشئ الجمل بشكل أسرع من خلال اكتشاف علامات الترقيم بقوة أكبر. القيم الأقل تنتظر حدود جمل أوضح.',
      contextWindowSize: 'حجم نافذة السياق',
      contextWindowSizeDescription: 'عدد أزواج الجمل السابقة للحفاظ على سياق الترجمة. القيم الأعلى توفر استمرارية أفضل ولكن قد تزيد من وقت الاستجابة.',
      sentences: 'جمل',
      advancedSettings: 'الإعدادات المتقدمة',
      showAdvanced: 'إظهار المتقدم',
      hideAdvanced: 'إخفاء المتقدم',
      createRoom: 'إنشاء غرفة',
      creatingRoom: 'جارٍ إنشاء الغرفة...',
      roomCreated: 'تم إنشاء الغرفة "{title}". جارٍ فتح المراقب...',
      roomFailed: 'فشل في إنشاء الغرفة',
      deleteConfirm: 'هل أنت متأكد من حذف "{title}"؟ لا يمكن التراجع عن هذا الإجراء.',
      roomDeleted: 'تم حذف "{title}" بنجاح.',
      deleteFailed: 'فشل في حذف الغرفة',
      noRoomsFound: 'لم يتم العثور على غرف',
      noRoomsDescription: 'أنشئ غرفتك الأولى للبدء في الترجمة المباشرة.',
      monitor: 'مراقبة',
      stopMonitoring: 'إيقاف المراقبة',
      share: 'مشاركة',
      view: 'عرض',
      languages: 'اللغات',
      configureAndStart: 'تكوين وبدء غرفة جديدة',
      templateDescription: 'إعدادات سريعة لأنواع الغرف الشائعة. اختر "مخصص" للتحكم اليدوي.',
      delayLabel: 'التأخير',
      punctuationLabel: 'علامات الترقيم',
      publicDisplay: 'العرض العام',
      kioskMode: 'وضع الكشك',
      urlCopied: 'تم نسخ رابط العرض العام إلى الحافظة',
      promptTemplate: 'نمط الترجمة',
      selectPromptTemplate: 'اختر نمط الترجمة',
      defaultPrompt: 'نمط الترجمة الافتراضي',
      promptTemplateDescription: 'اختر كيفية ترجمة الذكاء الاصطناعي للمحتوى (خطبة، إعلان، إلخ)',
      editRoom: 'تعديل إعدادات الغرفة',
      updateRoom: 'تحديث الغرفة',
      updating: 'جاري التحديث...',
      roomUpdated: 'تم تحديث الغرفة بنجاح',
      roomUpdateFailed: 'فشل في تحديث الغرفة',
      statusUpdated: 'تم تحديث حالة الغرفة',
      statusUpdateFailed: 'فشل في تحديث حالة الغرفة',
      contentType: 'نوع المحتوى',
      selectContentType: 'اختر نوع المحتوى',
      contentTypeDescription: 'اختر نوع المحتوى للحصول على أفضل دقة في التعرف على الكلام',
      domain: {
        broadcast: 'خطبة/محاضرة (كلام رسمي)',
        conversational: 'نقاش/أسئلة وأجوبة (غير رسمي)',
        general: 'محتوى عام/متنوع',
      },
    },
    monitor: {
      noRoomSelected: 'لم يتم اختيار غرفة',
      selectRoomDescription: 'اختر غرفة من تبويب إدارة الغرف لبدء المراقبة المباشرة.',
      goToRoomManagement: 'الذهاب إلى إدارة الغرف',
      liveMonitorTitle: 'المراقب المباشر',
      roomId: 'معرف الغرفة',
      status: 'الحالة',
      launchDisplay: 'تشغيل العرض',
      display: 'عرض',
      goLive: 'البث المباشر',
      live: 'مباشر',
      leaveRoom: 'مغادرة الغرفة',
      leave: 'مغادرة',
      complete: 'مكتمل',
      translating: 'جارٍ الترجمة...',
      waitingForTranslation: 'في انتظار الترجمة...',
      waitingForTranscription: 'في انتظار الكلام...',
      translationActivityLog: 'سجل نشاط الترجمة',
      participantCount: 'عدد المشاركين',
      connectionStatus: 'حالة الاتصال',
      currentActivity: 'النشاط الحالي',
      transcriptCount: 'عدد النصوص',
      translationWillAppear: 'ستظهر الترجمة عند اكتمال الجملة...',
    },
    validation: {
      roomTitleMin: 'يجب أن يكون عنوان الغرفة على الأقل حرفين',
      roomTitleMax: 'يجب أن يكون عنوان الغرفة أقل من 200 حرف',
      spokenLanguageRequired: 'يرجى اختيار اللغة المنطوقة',
      translationLanguageRequired: 'يرجى اختيار لغة الترجمة',
      maxDelayMin: 'يجب أن يكون أقصى تأخير على الأقل 1.0 ثانية',
      maxDelayMax: 'يجب أن يكون أقصى تأخير على الأكثر 5.0 ثانية',
      punctuationMin: 'يجب أن تكون حساسية علامات الترقيم على الأقل 0.0',
      punctuationMax: 'يجب أن تكون حساسية علامات الترقيم على الأكثر 1.0',
    },
  },
  languages: {
    ar: 'العربية',
    en: 'الإنجليزية',
    nl: 'الهولندية',
    fr: 'الفرنسية',
    de: 'الألمانية',
    es: 'الإسبانية',
  },
  auth: {
    bayanPlatform: 'منصة بيان',
    adminPanel: 'لوحة إدارة المسجد والترجمة',
    signIn: 'تسجيل الدخول',
    signOut: 'تسجيل الخروج',
    signInPrompt: 'أدخل بيانات الاعتماد الخاصة بك للوصول إلى لوحة التحكم',
    emailLabel: 'البريد الإلكتروني',
    emailPlaceholder: 'admin@example.com',
    passwordLabel: 'كلمة المرور',
    passwordPlaceholder: 'أدخل كلمة المرور الخاصة بك',
    signingIn: 'جارٍ تسجيل الدخول...',
    unexpectedError: 'حدث خطأ غير متوقع. يرجى المحاولة مرة أخرى.',
  },
  history: {
    title: 'سجل الجلسات',
    description: 'عرض وإعادة تشغيل الجلسات المكتملة',
    loading: 'جارٍ التحميل...',
    backToDashboard: 'لوحة التحكم',
    signOut: 'تسجيل الخروج',
  },
  publicDisplay: {
    connectError: 'يرجى إدخال رمز الغرفة',
    validationError: 'فشل في التحقق من صحة رمز الغرفة',
    invalidCode: 'رمز غرفة غير صالح أو الغرفة غير متاحة للوصول العام',
    connectionFailed: 'فشل الاتصال بالغرفة',
    disconnect: 'قطع الاتصال',
    title: 'الاتصال بالعرض المباشر',
    description: 'أدخل رمز الغرفة للاتصال بالعرض المباشر',
    roomCodeLabel: 'رمز الغرفة',
    roomCodePlaceholder: 'مثال: 870218',
    connecting: 'جارٍ الاتصال...',
    connectButton: 'الاتصال بالعرض',
    instructions: 'يتم توفير رموز الغرف من قبل مسؤول المسجد',
  },
  sessionHistory: {
    title: 'سجل الجلسات',
    description: 'عرض وإعادة تشغيل جلسات الترجمة المكتملة',
    loading: 'جار تحميل سجل الجلسات...',
    searchPlaceholder: 'البحث باسم الغرفة...',
    filterByRoom: 'تصفية حسب الغرفة',
    allRooms: 'كل الغرف',
    sortBy: 'ترتيب حسب',
    dateNewest: 'التاريخ (الأحدث أولاً)',
    duration: 'المدة',
    transcriptCount: 'عدد النصوص',
    completedSessions: 'الجلسات المكتملة',
    noSessionsFound: 'لم يتم العثور على جلسات',
    noCompletedSessions: 'لا توجد جلسات مكتملة حتى الآن. ابدأ جلستك المباشرة الأولى من لوحة التحكم.',
    noMatchingSessions: 'لا توجد جلسات تطابق عوامل التصفية الحالية.',
    table: {
      room: 'الغرفة',
      languages: 'اللغات',
      started: 'بدأت في',
      duration: 'المدة',
      transcripts: 'النصوص',
      actions: 'الإجراءات',
    },
    viewSession: 'عرض الجلسة',
    roomFallback: 'غرفة',
    languageFrom: 'من',
    languageTo: 'إلى',
    notAvailable: 'غير متاح',
    hours: 'س',
    minutes: 'د',
    seconds: 'ث',
    publicTitleLabel: 'العنوان العام',
    publicTitlePlaceholder: 'أدخل عنوانًا للخطاب العام...',
    showingResults: 'عرض {start} إلى {end} من {total} جلسات',
  },
  sessionReplay: {
    sessionNotFound: 'الجلسة غير موجودة',
    sessionNotFoundDescription: 'تعذر العثور على الجلسة المطلوبة.',
    backButton: 'عودة',
    refreshAll: 'تحديث الكل',
    exportButton: 'تصدير',
    export: {
      fullTranscript: 'النص الكامل',
      translationOnly: 'الترجمة فقط',
      srtSubtitles: 'ترجمات SRT',
      formattedCards: 'بطاقات منسقة',
    },
    noTranscriptsFound: 'لم يتم العثور على نصوص لهذه الجلسة',
    noTranslationAvailable: 'لا توجد ترجمة متاحة',
  },
  mosqueAdminDashboard: {
    health: 'الصحة',
    statusTooltip: 'يتم تحديث الحالة تلقائياً بناءً على الجلسات النشطة',
  },
  impersonation: {
    impersonating: 'أنت تنتحل شخصية:',
    actionsAsUser: 'سيتم تنفيذ جميع الإجراءات بصفتك هذا المستخدم',
    returnToSuperAdmin: 'العودة إلى المدير العام',
    startedTitle: 'بدء انتحال الشخصية',
    startedDescription: 'تم تسجيل الدخول الآن بصفتك {email}',
    failedTitle: 'فشل انتحال الشخصية',
    failedDescription: 'فشل في بدء انتحال الشخصية',
    endedTitle: 'انتهاء انتحال الشخصية',
    endedDescription: 'تمت العودة إلى حساب المدير العام',
    endFailed: 'فشل في إنهاء انتحال الشخصية بشكل صحيح',
  },
  roomCodeManager: {
    updatedTitle: 'تم تحديث الوصول العام',
    enabledDescription: 'الغرفة {id} متاحة الآن للوصول العام',
    disabledDescription: 'تم تعطيل الوصول العام للغرفة {id}',
    updateFailed: 'فشل في تحديث إعداد الوصول العام',
    copiedTitle: 'تم النسخ',
    copiedDescription: 'تم نسخ رمز الغرفة',
    codeLabel: 'الرمز',
  },
  kioskToggle: {
    updatedTitle: 'تم تحديث وضع الكشك',
    enabledDescription: 'تم تفعيل وضع الكشك لـ {name}. ستبقى هذه الغرفة نشطة بشكل دائم.',
    disabledDescription: 'تم تعطيل وضع الكشك لـ {name}',
    updateFailed: 'فشل في تحديث وضع الكشك',
  },
  liveMonitor: {
    users: 'المستخدمون',
    messages: 'الرسائل',
    transcripts: 'النصوص',
    status: 'الحالة',
    setupRequiredTitle: 'الإعداد مطلوب',
    setupRequiredDescription: 'تحتاج هذه الغرفة إلى تكوين LiveKit لبدء الجلسات الصوتية.',
    startAudioTitle: 'بدء جلسة صوتية',
    startAudioDescription: 'اتصل لبدء الترجمة الصوتية المباشرة',
    connecting: 'جارٍ الاتصال...',
    startSession: 'بدء الجلسة',
    audioLive: 'صوت مباشر',
    mic: 'مايك',
    endSession: 'إنهاء الجلسة',
    serverConfigRequired: 'تكوين الخادم مطلوب',
    serverConfigDescription: 'يرجى الاتصال بالدعم لتكوين خادم LiveKit.',
    activityTitle: 'نشاط الترجمة المباشرة',
    activityDescription: 'العربية → {language} • في الوقت الفعلي من وكيل بايثون',
    waitingForActivity: 'في انتظار نشاط الترجمة...',
    startMonitoringPrompt: 'ابدأ المراقبة لعرض النشاط المباشر',
    liveTranslation: 'الترجمة المباشرة',
    liveTranscription: 'النسخ المباشر',
    typing: 'جارٍ الكتابة...',
    waitingForTranslation: 'في انتظار الترجمة...',
    display: 'عرض',
    launchDisplay: 'تشغيل العرض',
  },
  quranDisplay: {
    cameraFeed: 'منطقة العرض المرئي / الكاميرا',
    waitingForArabic: 'انتظار النص العربي...',
    demoArabic: 'وضع تجريبي - النص العربي',
    waitingForTranslation: 'في انتظار الترجمة...',
    demoTranslation: 'وضع تجريبي - عرض الترجمة المباشرة',
    translationTitle: 'الترجمة المباشرة',
    latest: 'الأحدث',
  },
  superAdminDashboard: {
    from: 'من',
    to: 'إلى',
    unknownMosque: 'مسجد غير معروف',
    noTemplatesDescription: 'أنشئ قوالب لتوحيد تكوينات الغرف في جميع المساجد.',
  },
  form: {
    validation: {
      required: 'هذا الحقل مطلوب',
      minLength: 'يجب أن يكون على الأقل {min} أحرف',
      maxLength: 'يجب أن يكون أقل من {max} حرف',
      selectRequired: 'يرجى اختيار خيار',
      titleRequired: 'يجب أن يكون عنوان الغرفة على الأقل حرفين',
      titleMaxLength: 'يجب أن يكون عنوان الغرفة أقل من 200 حرف',
      mosqueNameMin: 'يجب أن يكون اسم المسجد على الأقل حرفين',
      mosqueNameMax: 'يجب أن يكون اسم المسجد أقل من 100 حرف',
      templateNameMin: 'يجب أن يكون اسم القالب على الأقل حرفين',
      maxDelayRange: 'يجب أن يكون أقصى تأخير بين 1.0 و 5.0 ثانية',
      punctuationRange: 'يجب أن تكون حساسية علامات الترقيم بين 0.0 و 1.0',
      languageRequired: 'يرجى اختيار لغة',
    }
  },
  technical: {
    livekit: 'LiveKit',
    websocket: 'WebSocket',
    errors: {
      fetchFailed: 'فشل في جلب البيانات',
      createFailed: 'فشل في الإنشاء',
      updateFailed: 'فشل في التحديث',
      deleteFailed: 'فشل في الحذف',
      connectionError: 'خطأ في الاتصال',
      authError: 'خطأ في المصادقة',
      permissionDenied: 'تم رفض الإذن',
      notFound: 'غير موجود',
      alreadyExists: 'موجود بالفعل',
      invalidData: 'بيانات غير صحيحة',
      mosqueNotFound: 'المسجد بالمعرف {id} غير موجود',
      userNotAuthenticated: 'المستخدم غير مصادق عليه',
      subdomaineExists: 'يوجد مسجد بالنطاق الفرعي "{subdomain}" بالفعل',
      noAuthSession: 'لا توجد جلسة مصادقة',
      livekitRoomFailed: 'فشل في إنشاء غرفة LiveKit',
      fetchMosquesFailed: 'فشل في جلب المساجد',
      fetchTemplatesFailed: 'فشل في جلب القوالب',
      fetchUsersFailed: 'فشل في جلب المستخدمين',
    }
  },
  toast: {
    success: {
      created: 'تم الإنشاء بنجاح',
      updated: 'تم التحديث بنجاح',
      deleted: 'تم الحذف بنجاح',
      copied: 'تم النسخ إلى الحافظة',
      saved: 'تم حفظ الإعدادات',
    },
    error: {
      generic: 'حدث خطأ ما',
      network: 'حدث خطأ في الشبكة',
      validation: 'يرجى التحقق من إدخالك',
      unauthorized: 'أنت غير مخول',
      timeout: 'انتهت مهلة الطلب',
    },
    warning: {
      unsavedChanges: 'لديك تغييرات غير محفوظة',
      dataLoss: 'لا يمكن التراجع عن هذا الإجراء',
    }
  },
  users: {
    title: 'المستخدمون',
    email: 'البريد الإلكتروني',
    actions: 'الإجراءات',
    loginAs: 'تسجيل الدخول كـ',
    starting: 'جارٍ البدء...',
    loadingUsers: 'جارٍ تحميل المستخدمين...',
    noUsersFound: 'لم يتم العثور على مستخدمين',
    noUsersDescription: 'هذا المسجد ليس لديه أي مستخدمين بعد.',
    impersonationFailed: 'فشل في بدء انتحال الشخصية',
    mosqueUsers: 'مستخدمو {mosqueName}',
  },
  monitoring: {
    status: 'الحالة',
    active: 'نشط',
    inactive: 'غير نشط',
    live: 'مباشر',
    empty: 'فارغ',
    pending: 'في الانتظار',
    error: 'خطأ',
    connecting: 'جارٍ الاتصال...',
    connected: 'متصل',
    disconnected: 'منقطع',
    reconnecting: 'جارٍ إعادة الاتصال...',
  },
  advanced: {
    title: 'الإعدادات المتقدمة',
    show: 'إظهار المتقدم',
    hide: 'إخفاء المتقدم',
    configuration: 'التكوين',
    template: 'قالب',
    custom: 'مخصص',
    default: 'افتراضي',
    reset: 'إعادة تعيين إلى الافتراضي',
    apply: 'تطبيق الإعدادات',
  },
  settings: {
    profile: 'الملف الشخصي',
    security: 'الأمان',
    notifications: 'الإشعارات',
    system: 'النظام',
    publicDisplay: 'العرض العام',
    description: 'إدارة إعدادات حسابك وتفضيلاتك',
    profileSettings: 'إعدادات الملف الشخصي',
    profileDescription: 'تحديث معلوماتك الشخصية',
    fullName: 'الاسم الكامل',
    emailCannotChange: 'لا يمكن تغيير البريد الإلكتروني',
    profileUpdated: 'تم تحديث الملف الشخصي بنجاح',
    securitySettings: 'إعدادات الأمان',
    securityDescription: 'إدارة كلمة المرور وتفضيلات الأمان',
    currentPassword: 'كلمة المرور الحالية',
    newPassword: 'كلمة المرور الجديدة',
    confirmPassword: 'تأكيد كلمة المرور',
    updatePassword: 'تحديث كلمة المرور',
    passwordUpdated: 'تم تحديث كلمة المرور بنجاح',
    notificationSettings: 'إعدادات الإشعارات',
    notificationDescription: 'تكوين كيفية استقبال الإشعارات',
    emailNotifications: 'إشعارات البريد الإلكتروني',
    emailNotificationsDescription: 'استلام التحديثات عبر البريد الإلكتروني',
    systemAlerts: 'تنبيهات النظام',
    systemAlertsDescription: 'إشعارات النظام المهمة',
    systemSettings: 'إعدادات النظام',
    systemDescription: 'تكوين الإعدادات على مستوى النظام',
    apiConfiguration: 'تكوين API',
    publicDisplaySettings: 'إعدادات العرض العام',
    publicDisplayDescription: 'تكوين إعدادات شاشات العرض العام',
    inactivityTimeout: 'مهلة عدم النشاط',
    inactivityTimeoutDescription: 'الوقت قبل العودة إلى شاشة أوقات الصلاة (10-600 ثانية)',
    seconds: 'ثواني',
    publicDisplayUpdated: 'تم تحديث إعدادات العرض العام بنجاح',
    systemInfo: 'معلومات النظام',
    version: 'الإصدار',
    environment: 'البيئة',
    database: 'قاعدة البيانات',
    maintenanceMode: 'وضع الصيانة',
    maintenanceModeDescription: 'تفعيل وضع الصيانة لتعطيل الوصول مؤقتاً لجميع المستخدمين',
    enableMaintenanceMode: 'تفعيل وضع الصيانة',
    maintenanceModeWarning: 'هذا سيمنع جميع المستخدمين من الوصول إلى المنصة',
    maintenanceMessage: 'رسالة الصيانة',
    maintenanceMessagePlaceholder: 'أدخل رسالة مخصصة للمستخدمين...',
    systemHealth: 'صحة النظام',
    systemHealthDescription: 'مراقبة أداء النظام ومقاييس الصحة',
    apiStatus: 'حالة API',
    databaseStatus: 'حالة قاعدة البيانات',
    livekitStatus: 'حالة LiveKit',
    cpuUsage: 'استخدام المعالج',
    memoryUsage: 'استخدام الذاكرة',
    diskUsage: 'استخدام القرص',
    runDatabaseMaintenance: 'تشغيل صيانة قاعدة البيانات',
    clearCache: 'مسح التخزين المؤقت',
    livekitUrl: 'عنوان LiveKit URL',
    webhookSecret: 'سر Webhook',
    versionValue: 'v1.0.0',
    environmentValue: 'إنتاج',
    databaseValue: 'PostgreSQL',
    maintenanceMessageDefault: 'نقوم حاليًا بإجراء صيانة مجدولة. يرجى معاودة التحقق لاحقًا.',
  },
  dialogs: {
    confirm: 'تأكيد',
    cancel: 'إلغاء',
    delete: 'حذف',
    save: 'حفظ',
    discard: 'تجاهل',
    areYouSure: 'هل أنت متأكد؟',
    deleteConfirm: 'لا يمكن التراجع عن هذا الإجراء',
    unsavedWarning: 'لديك تغييرات غير محفوظة. هل تريد تجاهلها؟',
    browserWarning: 'لديك جلسة مراقبة نشطة. هل أنت متأكد من أنك تريد المغادرة؟',
  },
  promptTemplates: {
    title: 'قوالب الأوامر',
    createTemplate: 'إنشاء قالب',
    editTitle: 'تعديل قالب الأمر',
    createTitle: 'إنشاء قالب أمر',
    templateName: 'اسم القالب',
    templateNamePlaceholder: 'مثال: خطبة جمعة رسمية',
    contentType: 'نوع المحتوى',
    selectContentType: 'اختر نوع المحتوى',
    descriptionLabel: 'الوصف (اختياري)',
    descriptionPlaceholder: 'وصف موجز لوقت استخدام هذا القالب',
    style: 'النمط',
    context: 'السياق',
    terminology: 'المصطلحات',
    audience: 'الجمهور',
    promptTemplate: 'قالب الأمر',
    promptPlaceholder: 'أنت تترجم {content_type} من {source_language} إلى {target_language}. استخدم لغة {style} مناسبة لجمهور {audience}. للتعامل مع المصطلحات: {terminology}...',
    variablesHint: 'استخدم المتغيرات:',
    preview: 'معاينة:',
    updateButton: 'تحديث القالب',
    createButton: 'إنشاء القالب',
    noTemplatesFound: 'لم يتم العثور على قوالب أوامر. أنشئ قالبك الأول للبدء.',
    default: 'افتراضي',
    previewTitle: 'معاينة: {name}',
    generatedPrompt: 'الأمر الذي تم إنشاؤه:',
    columns: {
      name: 'الاسم',
      contentType: 'نوع المحتوى',
      style: 'النمط',
      status: 'الحالة',
      created: 'تم الإنشاء',
    },
    contentTypes: {
      sermon: 'خطبة',
      announcement: 'إعلان',
      lecture: 'محاضرة',
      dua: 'دعاء',
    },
    styleOptions: {
      formal: 'رسمي',
      casual: 'غير رسمي',
      youth: 'شبابي',
      academic: 'أكاديمي',
      default: 'افتراضي',
    },
    contextOptions: {
      friday: 'الجمعة',
      eid: 'العيد',
      ramadan: 'رمضان',
      special: 'خاص',
    },
    terminologyOptions: {
      preserve: 'الحفاظ',
      translate: 'ترجمة',
      simplify: 'تبسيط',
    },
    audienceOptions: {
      general: 'عام',
      children: 'أطفال',
      scholars: 'علماء',
    },
  },
  mosqueCreation: {
    title: 'إنشاء مسجد جديد',
    description: 'إنشاء مسجد جديد. يمكنك إضافة مسؤولين لاحقًا.',
    successTitle: 'تم إنشاء المسجد بنجاح!',
    successDescription: 'تم إنشاء المسجد وحساب المسؤول جاهز',
    mosqueDetails: 'تفاصيل المسجد',
    nameLabel: 'الاسم',
    subdomainLabel: 'النطاق الفرعي',
    urlLabel: 'الرابط',
    successAlert: 'تم إنشاء المسجد بنجاح. يمكنك الآن إضافة مسؤولين من خلال صفحة المستخدمين.',
    mosqueNameLabel: 'اسم المسجد',
    mosqueNamePlaceholder: 'مثال: مركز النور الإسلامي',
    subdomainPlaceholder: 'al-noor',
    subdomainDescription: 'سيكون هذا هو الرابط الفريد للمسجد',
    descriptionLabel: 'الوصف',
    descriptionPlaceholder: 'وصف موجز للمسجد...',
    cityLabel: 'المدينة',
    cityPlaceholder: 'مثال: أمستردام',
    countryLabel: 'الدولة',
    countryPlaceholder: 'مثال: هولندا',
    timezoneLabel: 'المنطقة الزمنية',
    timezonePlaceholder: 'اختر المنطقة الزمنية',
    contactEmailLabel: 'البريد الإلكتروني للاتصال',
    contactEmailPlaceholder: 'info@mosque.com',
    contactPhoneLabel: 'هاتف الاتصال',
    contactPhonePlaceholder: '+31 20 123 4567',
    creatingButton: 'جار الإنشاء...',
    createButton: 'إنشاء مسجد',
  },
  publicSpeech: {
    loading: 'جار تحميل نص الخطاب...',
    loadingTranscripts: 'جار تحميل {fetched} من {total} نصوص...',
    sessionNotFound: 'الجلسة غير موجودة',
    sessionNotFoundDescription: 'هذه الجلسة غير موجودة أو تم حذفها.',
    backToSpeeches: 'العودة إلى الخطب',
    back: 'عودة',
    exportFormatPlaceholder: 'تنسيق التصدير',
    exportOptions: {
      formatted: 'نص منسق',
      transcript: 'النص فقط',
      translation: 'الترجمة فقط',
      srt: 'ترجمات SRT',
    },
    transcriptTitle: 'النص',
    noTranscriptData: 'لا توجد بيانات نصية متاحة لهذه الجلسة.',
    noTranscription: 'لا يوجد نص',
    noTranslation: 'لا توجد ترجمة',
  },
  publicSpeechList: {
    title: 'الخطب العامة',
    description: 'تصفح واقرأ نصوص الخطب السابقة',
    searchPlaceholder: 'ابحث باسم المسجد أو الغرفة...',
    sortByPlaceholder: 'ترتيب حسب',
    sortOptions: {
      date: 'التاريخ (الأحدث)',
      duration: 'المدة',
      transcripts: 'عدد النصوص',
    },
    noSpeechesFound: 'لم يتم العثور على خطب',
    noSpeechesAvailable: 'لا توجد خطب عامة متاحة في الوقت الحالي.',
    noMatch: 'لا توجد خطب تطابق معايير البحث الخاصة بك.',
    started: 'بدأت',
    duration: 'المدة',
    transcripts: 'النصوص',
    viewSpeech: 'عرض الخطبة',
    showingResults: 'عرض {start} إلى {end} من {total} خطب',
  },
  remoteControl: {
    title: 'التحكم عن بعد',
    description: 'التحكم في جلسات المراقبة عن بعد',
    activeSessions: 'جلسات المراقبة النشطة',
    connected: 'متصل',
    connecting: 'جار الاتصال...',
    noActiveSessions: 'لا توجد جلسات مراقبة نشطة. افتح مراقب غرفة لرؤيتها هنا.',
    roomIsOpen: 'غرفة {roomName} مفتوحة',
    session: 'جلسة',
    goLive: 'بث مباشر',
    toggleMic: 'تبديل الميكروفون',
    end: 'إنهاء',
  },
  userMosqueAssignment: {
    title: 'تعيين المستخدمين للمساجد',
    description: 'إدارة المسجد الذي ينتمي إليه كل مستخدم',
    showAllUsers: 'عرض كل المستخدمين',
    showUnassignedOnly: 'عرض غير المعينين فقط',
    noUnassignedUsers: 'لم يتم العثور على مستخدمين غير معينين. تم تعيين جميع المستخدمين للمساجد.',
    noUsersFound: 'لم يتم العثور على مستخدمين.',
    currently: 'حاليًا',
    noMosqueAssigned: 'لم يتم تعيين مسجد',
    selectMosque: 'اختر مسجدًا',
  },
  userCreation: {
    title: 'إنشاء مستخدم جديد',
    description: 'إنشاء مستخدم جديد لمسجد',
    emailPlaceholder: 'user@example.com',
    fullNameLabel: 'الاسم الكامل',
    fullNamePlaceholder: 'فلان الفلاني',
    passwordLabel: 'كلمة المرور',
    selectMosquePlaceholder: 'اختر مسجدًا',
    creatingButton: 'جار الإنشاء...',
    createButton: 'إنشاء مستخدم',
  },
  conversation: {
    title: 'وضع المحادثة',
    description: 'محادثة ثنائية الاتجاه بين الغرف مع ترجمة في الوقت الفعلي',
    controlCenterTitle: 'مركز التحكم في المحادثة',
    controlCenterDescription: 'اختر كيفية فتح نوافذ المحادثة - كلاهما مرة واحدة أو بشكل فردي للتحكم متعدد الأجهزة.',
    howToUseTitle: 'كيفية استخدام وضع المحادثة:',
    step1: 'اختر فتح كلا النافذتين أو النوافذ الفردية أدناه',
    step2: 'في النافذة الأساسية، حدد الغرف لمحادثتك',
    step3: 'انقر فوق "بدء المحادثة" لتحميل كلتا الغرفتين',
    step4: 'انقر فوق "بث مباشر" لبدء الجلسة',
    step5: 'يمكن أن يكون ميكروفون واحد فقط نشطًا في كل مرة (نمط الضغط والتحدث)',
    step6: 'استخدم "مغادرة الغرفة" للعودة إلى اختيار الغرفة',
    openBothWindows: 'افتح كلا النافذتين',
    manualControlTitle: 'التحكم اليدوي في الغرفة',
    manualControlDescription: 'افتح نوافذ محادثة فردية للتحكم متعدد الأجهزة',
    openPrimaryOnly: 'افتح الغرفة الأساسية فقط',
    openSecondaryOnly: 'افتح الغرفة الثانوية فقط',
    tipTitle: 'نصيحة',
    tipDescription: 'يمكنك التحكم في كل غرفة من أجهزة مختلفة عند تسجيل الدخول بنفس الحساب.',
    noteTitle: 'ملاحظة',
    noteDescription: 'إذا لم تفتح النوافذ، يرجى التحقق من إعدادات مانع النوافذ المنبثقة في متصفحك.',
  },
  conversationSelector: {
    participantWaitingTitle: 'غرفة انتظار المشاركين',
    participantWaitingDescription: 'يقوم المضيف بإعداد جلسة المحادثة. سيتم توصيلك تلقائيًا.',
    pleaseWait: 'يرجى الانتظار بينما يقوم المضيف بإعداد غرف الترجمة...',
    hostControlTitle: 'لوحة تحكم المضيف',
    hostControlDescription: 'اختر غرف الترجمة لمحادثتك مع المشارك.',
    hostLanguageRoom: 'غرفة لغة المضيف',
    hostRoomDescription: 'اختر الغرفة التي تترجم من لغتك إلى لغة المشارك',
    selectHostRoom: 'اختر غرفة المضيف',
    participantLanguageRoom: 'غرفة لغة المشارك',
    participantRoomDescription: 'اختر الغرفة التي تترجم من لغة المشارك إلى لغتك',
    selectParticipantRoom: 'اختر غرفة المشارك',
    startConversation: 'بدء المحادثة',
    selectedRooms: 'الغرف المختارة',
    primary: 'الأساسية',
    secondary: 'الثانوية',
  },
  participantInfo: {
    participants: 'المشاركون',
    activeMics: 'الميكروفونات النشطة',
    listening: 'مستمعون',
    users: 'المستخدمون',
    active: 'نشط',
    mics: 'ميكروفونات',
  },
  hostControls: {
    setupRequiredTitle: 'الإعداد مطلوب',
    setupRequiredDescription: 'تحتاج هذه الغرفة إلى تكوين قبل أن تتمكن من بدء جلسة صوتية.',
    readyToBroadcastTitle: 'جاهز للبث',
    readyToBroadcastDescription: 'ابدأ جلستك الصوتية لـ {roomTitle}',
    connectingButton: 'جار الاتصال...',
    startBroadcastingButton: 'بدء البث',
    configErrorTitle: 'خطأ في التكوين',
    configErrorDescription: 'تكوين الخادم مفقود. يرجى الاتصال بالدعم.',
    liveBroadcasting: 'البث المباشر',
    endBroadcastButton: 'إنهاء البث',
  },
  connectedControls: {
    live: 'مباشر',
    end: 'إنهاء',
  },
  displayPage: {
    notConnectedTitle: 'العرض غير متصل',
    notConnectedDescription: 'هذا العرض غير متصل بغرفة. يرجى تشغيله من صفحة المراقبة.',
    exampleUrl: '/display?room=ROOM_NAME&mosque_id=1&room_id=123',
  },
  videoStream: {
    noCameraSelected: 'لم يتم تحديد كاميرا',
    selectCamera: 'اختر كاميرا...',
    camera: 'كاميرا',
    enableCamera: 'تمكين الكاميرا',
    connectingToCamera: 'جار الاتصال بالكاميرا...',
    noCameraFound: 'لم يتم العثور على كاميرا',
    accessDenied: 'تم رفض الوصول إلى الكاميرا',
    cameraInUse: 'الكاميرا قيد الاستخدام',
    cameraUnavailable: 'الكاميرا غير متاحة',
    startCamera: 'بدء الكاميرا',
  },
  mediaDeviceMenu: {
    currentDevice: 'الجهاز الحالي',
    device: 'جهاز',
    devicesAvailable: '{count} جهاز متاح',
    devicesAvailable_plural: '{count} أجهزة متاحة',
  },
  disconnectedControls: {
    readyToBroadcast: 'جاهز للبث',
    audioSession: 'جلسة صوتية',
    connecting: 'جار الاتصال...',
    startBroadcasting: 'بدء البث',
  },
};


================================================
FILE: src/lib/translations/en.ts
================================================
import { TranslationStructure } from './types';

export const en: TranslationStructure = {
  common: {
    signOut: 'Sign Out',
    loading: 'Loading...',
    error: 'Error',
    retry: 'Retry',
    save: 'Save',
    cancel: 'Cancel',
    delete: 'Delete',
    edit: 'Edit',
    create: 'Create',
    update: 'Update',
    actions: 'Actions',
    tryAgain: 'Try Again',
    success: 'Success',
    id: 'ID',
    status: 'Status',
    created: 'Created',
    saveChanges: 'Save Changes',
    updating: 'Updating...',
    refresh: 'Refresh',
    lastUpdated: 'Last updated',
    active: 'Active',
    pending: 'Pending',
    notSet: 'Not set',
    live: 'Live',
    offline: 'Offline',
    monitor: 'Monitor',
    preparing: 'Preparing...',
    inactive: 'Inactive',
    completed: 'Completed',
    total: 'Total',
    title: 'Title',
    mosque: 'Mosque',
    from: 'From',
    to: 'To',
    createdAt: 'Created At',
    unknown: 'Unknown',
    room: 'Room',
    user: 'User',
    email: 'Email',
    role: 'Role',
    joinedAt: 'Joined At',
    admin: 'Admin',
    superAdmin: 'Super Admin',
    users: 'Users',
    admins: 'Admins',
    all: 'All',
    allMosques: 'All Mosques',
    allStatuses: 'All Statuses',
    allTime: 'All Time',
    today: 'Today',
    lastWeek: 'Last Week',
    lastMonth: 'Last Month',
    search: 'Search',
    filter: 'Filter',
    export: 'Export',
    import: 'Import',
    noResultsFound: 'No results found for your search',
    unauthorized: 'You are not authorized to access this page',
    comingSoon: 'Coming Soon',
    featureNotImplemented: 'This feature is not yet implemented',
    avgDuration: 'Avg Duration',
    avgSentences: 'Avg Sentences',
    sentences: 'Sentences',
    transcripts: 'Transcripts',
    startTime: 'Start Time',
    replay: 'Replay',
    confirmDelete: 'Confirm Delete',
    saving: 'Saving...',
    quickActions: 'Quick Actions',
    recentActivity: 'Recent Activity',
    noRecentActivity: 'No recent activity to display',
    noRecentActivityDescription: 'Activity will appear here as actions are performed',
    noMosque: 'No Mosque',
    unnamed: 'Unnamed',
    editMosque: 'Edit Mosque',
    editDescription: 'Update mosque details',
    deleteConfirmation: 'Are you sure you want to delete {name}? This action cannot be undone.',
    mosqueDeleted: 'Mosque deleted successfully',
    mosqueUpdated: 'Mosque updated successfully',
    description: 'Description',
    subdomain: 'Subdomain',
    bayanPlatform: 'bayaan Platform',
    goToDashboard: 'Go to Dashboard',
    viewPublicSpeeches: 'View Public Speeches',
    showing: 'Showing',
    of: 'of',
    previous: 'Previous',
    next: 'Next',
    rooms: 'rooms',
    sessions: 'sessions',
  },
  dashboard: {
    title: 'Dashboard',
    superAdminTitle: 'super admin dashboard',
    mosqueAdminTitle: 'mosque admin dashboard',
    welcome: 'Welcome',
    loadingProfile: 'Loading user profile...',
    errorLoadingProfile: 'Error loading user profile. Please try again.',
    loadingDashboard: 'Loading dashboard...',
    profileNotFound: 'User profile not found. Please contact an administrator to set up your account.',
    defaultMosqueName: 'Al Fourqaan',
    superAdminSubtitle: 'Manage mosque tenants',
    mosqueAdminSubtitle: 'Manage sermons and events',
    history: 'History',
    overview: 'Overview',
    mosques: 'Mosques',
    users: 'Users',
    prompts: 'Prompts',
    settings: 'Settings',
    rooms: 'Rooms',
    monitor: 'Monitor',
    sessions: 'Sessions',
    billing: 'Usage',
    sessionArchive: 'Session Archive',
  },
  navigation: {
    dashboard: 'Dashboard',
    rooms: 'Rooms',
    users: 'Users',
    settings: 'Settings',
  },
  superAdmin: {
    stats: {
      totalMosques: 'Total Mosques',
      activeTenants: 'Active tenants on the platform',
      liveUpdates: 'Live Updates',
      realTime: 'Real-time',
      autoRefreshing: 'Auto-refreshing data',
      quickAction: 'Quick Action',
      addNewMosque: 'Add New Mosque',
      systemOverview: 'System-wide overview and statistics',
      registeredUsers: 'Registered users',
      configuredTemplates: 'Configured templates',
    },
    onboarding: {
      title: 'Onboard New Tenant',
      description: 'Create a new mosque with an admin account',
      mosqueName: 'Mosque Name',
      mosqueNamePlaceholder: 'Enter mosque name...',
      createMosque: 'Create Mosque & Deploy',
      creatingMosque: 'Creating Mosque...',
      mosqueCreated: 'Mosque "{name}" has been created with subdomain "{subdomain}".',
      mosqueExists: 'A mosque with subdomain "{subdomain}" already exists',
      mosqueFailed: 'Failed to create mosque',
    },
    mosques: {
      title: 'Managed Mosques',
      loadingMosques: 'Loading mosques...',
      noMosquesFound: 'No mosques found',
      noMosquesDescription: 'Get started by adding your first mosque to the platform.',
      addFirstMosque: 'Add First Mosque',
      mosqueName: 'Mosque Name',
      subdomain: 'Subdomain',
      viewUsers: 'View Users',
      hideUsers: 'Hide Users',
      description: 'Manage all mosques on the platform',
      editMosque: 'Edit Mosque',
      editDescription: 'Update mosque details',
      deleteConfirmation: 'Are you sure you want to delete {name}? This action cannot be undone.',
      mosqueDeleted: 'Mosque deleted successfully',
      mosqueUpdated: 'Mosque updated successfully',
    },
    validation: {
      mosqueNameMin: 'Mosque name must be at least 2 characters',
      mosqueNameMax: 'Mosque name must be less than 100 characters',
      templateNameMin: 'Template name must be at least 2 characters',
    },
    templates: {
      spokenLanguage: 'Spoken Language',
      translationLanguage: 'Translation Language',
    },
    rooms: {
      description: 'Manage all rooms across all mosques in the system',
      totalRooms: 'Total rooms across all mosques',
      activeRooms: 'Currently streaming',
      pendingRooms: 'Being set up',
      inactiveRooms: 'Not in use',
      allRooms: 'All Rooms',
      searchPlaceholder: 'Search by room title, mosque, or LiveKit name...',
      filterByMosque: 'Filter by Mosque',
      filterByStatus: 'Filter by Status',
      noRoomsFound: 'No Rooms Found',
      noRoomsDescription: 'No rooms have been created yet.',
      monitoringComingSoon: 'Cross-mosque monitoring coming soon',
      statusUpdated: 'Room status updated successfully',
      roomsDeleted: 'Selected rooms deleted successfully',
    },
    sessions: {
      description: 'View and manage session history across all mosques',
      totalSessions: 'Total sessions recorded',
      activeSessions: 'Currently live',
      completedSessions: 'Finished sessions',
      averageDuration: 'Average session length',
      averageSentences: 'Average sentences per session',
      totalSentences: 'Total sentences translated',
      sessionHistory: 'Session History',
      searchPlaceholder: 'Search by room, mosque, or session ID...',
      filterByMosque: 'Filter by Mosque',
      filterByDate: 'Filter by Date',
      noSessionsFound: 'No Sessions Found',
      noSessionsDescription: 'No sessions have been recorded yet.',
    },
    users: {
      description: 'Manage all users across the platform',
      title: 'All Users',
      searchPlaceholder: 'Search by name, email, or mosque...',
      filterByMosque: 'Filter by Mosque',
      noUsersFound: 'No Users Found',
      noUsersDescription: 'No users have been registered yet.',
      userDeleted: 'User deleted successfully',
      roleUpdated: 'User role updated successfully',
      impersonate: 'Impersonate User',
      impersonating: 'Impersonating {name}',
      deleteConfirmation: 'Are you sure you want to delete {name}? This action cannot be undone.',
      bulkActions: 'Bulk Actions',
      makeAdmin: 'Make Admin',
      makeUser: 'Make User',
      deleteSelected: 'Delete Selected',
      bulkDeleteConfirmation: 'Are you sure you want to delete {count} users? This action cannot be undone.',
      bulkDeleteSuccess: 'Successfully deleted {count} users',
      bulkRoleUpdateSuccess: 'Successfully updated role for {count} users',
      exportSuccess: 'Users exported successfully',
    },
    prompts: {
      description: 'Manage AI prompt templates for all mosques',
    },
  },
  mosqueAdmin: {
    tabs: {
      roomManagement: 'Room Management',
      liveMonitor: 'Live Monitor',
    },
    stats: {
      totalRooms: 'Total Rooms',
      available: 'Available',
      statusMonitorError: 'Status Monitor Error',
      activeRooms: 'Active Rooms',
      currentlyActive: 'Currently active',
      mosqueOverview: 'Mosque overview and statistics',
    },
    rooms: {
      title: 'Room Status Monitoring',
      createNew: 'Create New Room',
      manageRooms: 'Manage Rooms',
      roomTitle: 'Room Title',
      roomTitlePlaceholder: 'Enter room title...',
      maxDelay: 'Max Delay (seconds)',
      maxDelayDescription: 'Higher delay provides more accurate translations by waiting longer for complete sentences. Lower values prioritize speed over accuracy.',
      punctuationSensitivity: 'Punctuation Sensitivity',
      punctuationSensitivityDescription: 'Higher sensitivity creates sentences faster by detecting punctuation marks more aggressively. Lower values wait for clearer sentence boundaries.',
      contextWindowSize: 'Context Window Size',
      contextWindowSizeDescription: 'Number of previous sentence pairs to maintain for translation context. Higher values provide better continuity but may increase response time.',
      sentences: 'sentences',
      advancedSettings: 'Advanced Settings',
      showAdvanced: 'Show Advanced',
      hideAdvanced: 'Hide Advanced',
      createRoom: 'Create Room',
      creatingRoom: 'Creating Room...',
      roomCreated: 'Room "{title}" has been created. Opening monitor...',
      roomFailed: 'Failed to create room',
      deleteConfirm: 'Are you sure you want to delete "{title}"? This action cannot be undone.',
      roomDeleted: '"{title}" has been deleted successfully.',
      deleteFailed: 'Failed to delete room',
      noRoomsFound: 'No rooms found',
      noRoomsDescription: 'Create your first room to get started with live translation.',
      monitor: 'Monitor',
      stopMonitoring: 'Stop Monitoring',
      share: 'Share',
      view: 'View',
      languages: 'Languages',
      configureAndStart: 'Configure and start a new room',
      templateDescription: 'Quick presets for common room types. Select "Custom" for manual control.',
      delayLabel: 'Delay',
      punctuationLabel: 'Punctuation',
      publicDisplay: 'Public Display',
      kioskMode: 'Kiosk Mode',
      urlCopied: 'Public display URL copied to clipboard',
      promptTemplate: 'Translation Style',
      selectPromptTemplate: 'Select a translation style',
      defaultPrompt: 'Default Translation Style',
      promptTemplateDescription: 'Choose how the AI should translate the content (sermon, announcement, etc.)',
      editRoom: 'Edit Room Settings',
      updateRoom: 'Update Room',
      updating: 'Updating...',
      roomUpdated: 'Room updated successfully',
      roomUpdateFailed: 'Failed to update room',
      statusUpdated: 'Room status updated',
      statusUpdateFailed: 'Failed to update room status',
      contentType: 'Content Type',
      selectContentType: 'Select content type',
      contentTypeDescription: 'Choose the type of content for optimized speech recognition',
      domain: {
        broadcast: 'Sermon/Lecture (Formal Speech)',
        conversational: 'Discussion/Q&A (Informal)',
        general: 'General/Mixed Content',
      },
    },
    monitor: {
      noRoomSelected: 'No Room Selected',
      selectRoomDescription: 'Select a room from the Room Management tab to start live monitoring.',
      goToRoomManagement: 'Go to Room Management',
      liveMonitorTitle: 'Live Monitor',
      roomId: 'Room ID',
      status: 'Status',
      launchDisplay: 'Launch Display',
      display: 'Display',
      goLive: 'Go Live',
      live: 'Live',
      leaveRoom: 'Leave Room',
      leave: 'Leave',
      complete: 'Complete',
      translating: 'Translating...',
      waitingForTranslation: 'Waiting for translation...',
      waitingForTranscription: 'Waiting for speech...',
      translationActivityLog: 'Translation Activity Log',
      participantCount: 'Participant count',
      connectionStatus: 'Connection Status',
      currentActivity: 'Current activity',
      transcriptCount: 'Transcript count',
      translationWillAppear: 'Translation will appear when sentence is complete...',
    },
    validation: {
      roomTitleMin: 'Room title must be at least 2 characters',
      roomTitleMax: 'Room title must be less than 200 characters',
      spokenLanguageRequired: 'Please select a spoken language',
      translationLanguageRequired: 'Please select a translation language',
      maxDelayMin: 'Max delay must be at least 1.0 seconds',
      maxDelayMax: 'Max delay must be at most 5.0 seconds',
      punctuationMin: 'Punctuation sensitivity must be at least 0.0',
      punctuationMax: 'Punctuation sensitivity must be at most 1.0',
    },
  },
  languages: {
    ar: 'Arabic',
    en: 'English',
    nl: 'Dutch',
    fr: 'French',
    de: 'German',
    es: 'Spanish',
  },
  auth: {
    bayanPlatform: 'bayaan Platform',
    adminPanel: 'Mosque management & translation service',
    signIn: 'Sign In',
    signOut: 'Sign Out',
    signInPrompt: 'Enter your credentials to access the admin panel',
    emailLabel: 'Email',
    emailPlaceholder: 'admin@example.com',
    passwordLabel: 'Password',
    passwordPlaceholder: 'Enter your password',
    signingIn: 'Signing in...',
    unexpectedError: 'An unexpected error occurred. Please try again.',
  },
  history: {
    title: 'Session History',
    description: 'View and replay completed sessions',
    loading: 'Loading...',
    backToDashboard: 'Dashboard',
    signOut: 'Sign Out',
  },
  publicDisplay: {
    connectError: 'Please enter a room code',
    validationError: 'Failed to validate room code',
    invalidCode: 'Invalid room code or room not available for public access',
    connectionFailed: 'Failed to connect to room',
    disconnect: 'Disconnect',
    title: 'Connect to Live Display',
    description: 'Enter the room code to connect to the live display',
    roomCodeLabel: 'Room Code',
    roomCodePlaceholder: 'e.g., 870218',
    connecting: 'Connecting...',
    connectButton: 'Connect to Display',
    instructions: 'Room codes are provided by your mosque administrator',
  },
  sessionHistory: {
    title: 'Session History',
    description: 'View and replay completed translation sessions',
    loading: 'Loading session history...',
    searchPlaceholder: 'Search by room name...',
    filterByRoom: 'Filter by room',
    allRooms: 'All Rooms',
    sortBy: 'Sort by',
    dateNewest: 'Date (newest first)',
    duration: 'Duration',
    transcriptCount: 'Transcript count',
    completedSessions: 'Completed Sessions',
    noSessionsFound: 'No sessions found',
    noCompletedSessions: 'No completed sessions yet. Start your first live session from the dashboard.',
    noMatchingSessions: 'No sessions match your current filters.',
    table: {
      room: 'Room',
      languages: 'Languages',
      started: 'Started',
      duration: 'Duration',
      transcripts: 'Transcripts',
      actions: 'Actions',
    },
    viewSession: 'View Session',
    roomFallback: 'Room',
    languageFrom: 'From',
    languageTo: 'To',
    notAvailable: 'N/A',
    hours: 'h',
    minutes: 'm',
    seconds: 's',
    publicTitleLabel: 'Public Title',
    publicTitlePlaceholder: 'Enter a title for the public speech...',
    showingResults: 'Showing {start} to {end} of {total} sessions',
  },
  sessionReplay: {
    sessionNotFound: 'Session Not Found',
    sessionNotFoundDescription: 'The requested session could not be found.',
    backButton: 'Back',
    refreshAll: 'Refresh All',
    exportButton: 'Export',
    export: {
      fullTranscript: 'Full Transcript',
      translationOnly: 'Translation Only',
      srtSubtitles: 'SRT Subtitles',
      formattedCards: 'Formatted Cards',
    },
    noTranscriptsFound: 'No transcripts found for this session',
    noTranslationAvailable: 'No translation available',
  },
  mosqueAdminDashboard: {
    health: 'Health',
    statusTooltip: 'Status updates automatically based on active sessions',
  },
  impersonation: {
    impersonating: 'You are impersonating:',
    actionsAsUser: 'All actions will be performed as this user',
    returnToSuperAdmin: 'Return to Super Admin',
    startedTitle: 'Impersonation Started',
    startedDescription: 'Now logged in as {email}',
    failedTitle: 'Impersonation Failed',
    failedDescription: 'Failed to start impersonation',
    endedTitle: 'Impersonation Ended',
    endedDescription: 'Returned to super admin account',
    endFailed: 'Failed to end impersonation properly',
  },
  roomCodeManager: {
    updatedTitle: 'Public Access Updated',
    enabledDescription: 'Room {id} is now publicly accessible',
    disabledDescription: 'Public access disabled for room {id}',
    updateFailed: 'Failed to update public access setting',
    copiedTitle: 'Copied',
    copiedDescription: 'Room code copied',
    codeLabel: 'Code',
  },
  kioskToggle: {
    updatedTitle: 'Kiosk Mode Updated',
    enabledDescription: 'Kiosk mode enabled for {name}. This room will remain active permanently.',
    disabledDescription: 'Kiosk mode disabled for {name}',
    updateFailed: 'Failed to update kiosk mode',
  },
  liveMonitor: {
    users: 'Users',
    messages: 'Messages',
    transcripts: 'Transcripts',
    status: 'Status',
    setupRequiredTitle: 'Setup Required',
    setupRequiredDescription: 'This room needs LiveKit configuration to start audio sessions.',
    startAudioTitle: 'Start Audio Session',
    startAudioDescription: 'Connect to begin live audio translation',
    connecting: 'Connecting...',
    startSession: 'Start Session',
    audioLive: 'Audio Live',
    mic: 'Mic',
    endSession: 'End Session',
    serverConfigRequired: 'Server Configuration Required',
    serverConfigDescription: 'Please contact support to configure the LiveKit server.',
    activityTitle: 'Live Translation Activity',
    activityDescription: 'Arabic → {language} • Real-time from Python Agent',
    waitingForActivity: 'Waiting for translation activity...',
    startMonitoringPrompt: 'Start monitoring to view live activity',
    liveTranslation: 'Live Translation',
    liveTranscription: 'Live Transcription',
    typing: 'Typing...',
    waitingForTranslation: 'Waiting for translation...',
    display: 'Display',
    launchDisplay: 'Launch Display',
  },
  quranDisplay: {
    cameraFeed: 'Visuals / Camera Feed Area',
    waitingForArabic: 'انتظار النص العربي...',
    demoArabic: 'وضع تجريبي - النص العربي',
    waitingForTranslation: 'Waiting for translation...',
    demoTranslation: 'Demo Mode - Live Translation Display',
    translationTitle: 'Live Translation',
    latest: 'Latest',
  },
  superAdminDashboard: {
    from: 'From',
    to: 'To',
    unknownMosque: 'Unknown Mosque',
    noTemplatesDescription: 'Create templates to standardize room configurations across all mosques.',
  },
  form: {
    validation: {
      required: 'This field is required',
      minLength: 'Must be at least {min} characters',
      maxLength: 'Must be less than {max} characters',
      selectRequired: 'Please select an option',
      titleRequired: 'Room title must be at least 2 characters',
      titleMaxLength: 'Room title must be less than 200 characters',
      mosqueNameMin: 'Mosque name must be at least 2 characters',
      mosqueNameMax: 'Mosque name must be less than 100 characters',
      templateNameMin: 'Template name must be at least 2 characters',
      maxDelayRange: 'Max delay must be between 1.0 and 5.0 seconds',
      punctuationRange: 'Punctuation sensitivity must be between 0.0 and 1.0',
      languageRequired: 'Please select a language',
    }
  },
  technical: {
    livekit: 'LiveKit',
    websocket: 'WebSocket',
    errors: {
      fetchFailed: 'Failed to fetch data',
      createFailed: 'Failed to create',
      updateFailed: 'Failed to update',
      deleteFailed: 'Failed to delete',
      connectionError: 'Connection error',
      authError: 'Authentication error',
      permissionDenied: 'Permission denied',
      notFound: 'Not found',
      alreadyExists: 'Already exists',
      invalidData: 'Invalid data',
      mosqueNotFound: 'Mosque with ID {id} not found',
      userNotAuthenticated: 'User not authenticated',
      subdomaineExists: 'A mosque with subdomain "{subdomain}" already exists',
      noAuthSession: 'No authentication session',
      livekitRoomFailed: 'Failed to create LiveKit room',
      fetchMosquesFailed: 'Failed to fetch mosques',
      fetchTemplatesFailed: 'Failed to fetch templates',
      fetchUsersFailed: 'Failed to fetch users',
    }
  },
  toast: {
    success: {
      created: 'Successfully created',
      updated: 'Successfully updated',
      deleted: 'Successfully deleted',
      copied: 'Copied to clipboard',
      saved: 'Settings saved',
    },
    error: {
      generic: 'Something went wrong',
      network: 'Network error occurred',
      validation: 'Please check your input',
      unauthorized: 'You are not authorized',
      timeout: 'Request timed out',
    },
    warning: {
      unsavedChanges: 'You have unsaved changes',
      dataLoss: 'This action cannot be undone',
    }
  },
  users: {
    title: 'Users',
    email: 'Email',
    actions: 'Actions',
    loginAs: 'Login As',
    starting: 'Starting...',
    loadingUsers: 'Loading users...',
    noUsersFound: 'No users found',
    noUsersDescription: 'This mosque doesn\'t have any users yet.',
    impersonationFailed: 'Failed to start impersonation',
    mosqueUsers: '{mosqueName} Users',
  },
  monitoring: {
    status: 'Status',
    active: 'Active',
    inactive: 'Inactive',
    live: 'Live',
    empty: 'Empty',
    pending: 'Pending',
    error: 'Error',
    connecting: 'Connecting...',
    connected: 'Connected',
    disconnected: 'Disconnected',
    reconnecting: 'Reconnecting...',
  },
  advanced: {
    title: 'Advanced Settings',
    show: 'Show Advanced',
    hide: 'Hide Advanced',
    configuration: 'Configuration',
    template: 'Template',
    custom: 'Custom',
    default: 'Default',
    reset: 'Reset to Default',
    apply: 'Apply Settings',
  },
  settings: {
    profile: 'Profile',
    security: 'Security',
    notifications: 'Notifications',
    system: 'System',
    publicDisplay: 'Public Display',
    description: 'Manage your account settings and preferences',
    profileSettings: 'Profile Settings',
    profileDescription: 'Update your personal information',
    fullName: 'Full Name',
    emailCannotChange: 'Email cannot be changed',
    profileUpdated: 'Profile updated successfully',
    securitySettings: 'Security Settings',
    securityDescription: 'Manage your password and security preferences',
    currentPassword: 'Current Password',
    newPassword: 'New Password',
    confirmPassword: 'Confirm Password',
    updatePassword: 'Update Password',
    passwordUpdated: 'Password updated successfully',
    notificationSettings: 'Notification Settings',
    notificationDescription: 'Configure how you receive notifications',
    emailNotifications: 'Email Notifications',
    emailNotificationsDescription: 'Receive updates via email',
    systemAlerts: 'System Alerts',
    systemAlertsDescription: 'Important system notifications',
    systemSettings: 'System Settings',
    systemDescription: 'Configure system-wide settings',
    apiConfiguration: 'API Configuration',
    publicDisplaySettings: 'Public Display Settings',
    publicDisplayDescription: 'Configure settings for public display screens',
    inactivityTimeout: 'Inactivity Timeout',
    inactivityTimeoutDescription: 'Time before switching back to prayer times screen (10-600 seconds)',
    seconds: 'seconds',
    publicDisplayUpdated: 'Public display settings updated successfully',
    systemInfo: 'System Information',
    version: 'Version',
    environment: 'Environment',
    database: 'Database',
    maintenanceMode: 'Maintenance Mode',
    maintenanceModeDescription: 'Enable maintenance mode to temporarily disable access for all users',
    enableMaintenanceMode: 'Enable Maintenance Mode',
    maintenanceModeWarning: 'This will prevent all users from accessing the platform',
    maintenanceMessage: 'Maintenance Message',
    maintenanceMessagePlaceholder: 'Enter a custom message for users...',
    systemHealth: 'System Health',
    systemHealthDescription: 'Monitor system performance and health metrics',
    apiStatus: 'API Status',
    databaseStatus: 'Database Status',
    livekitStatus: 'LiveKit Status',
    cpuUsage: 'CPU Usage',
    memoryUsage: 'Memory Usage',
    diskUsage: 'Disk Usage',
    runDatabaseMaintenance: 'Run Database Maintenance',
    clearCache: 'Clear Cache',
    livekitUrl: 'LiveKit URL',
    webhookSecret: 'Webhook Secret',
    versionValue: 'v1.0.0',
    environmentValue: 'production',
    databaseValue: 'PostgreSQL',
    maintenanceMessageDefault: 'We are currently performing scheduled maintenance. Please check back later.',
  },
  dialogs: {
    confirm: 'Confirm',
    cancel: 'Cancel',
    delete: 'Delete',
    save: 'Save',
    discard: 'Discard',
    areYouSure: 'Are you sure?',
    deleteConfirm: 'This action cannot be undone',
    unsavedWarning: 'You have unsaved changes. Do you want to discard them?',
    browserWarning: 'You have an active monitoring session. Are you sure you want to leave?',
  },
  promptTemplates: {
    title: 'Prompt Templates',
    createTemplate: 'Create Template',
    editTitle: 'Edit Prompt Template',
    createTitle: 'Create Prompt Template',
    templateName: 'Template Name',
    templateNamePlaceholder: 'e.g., Formal Friday Sermon',
    contentType: 'Content Type',
    selectContentType: 'Select content type',
    descriptionLabel: 'Description (Optional)',
    descriptionPlaceholder: 'Brief description of when to use this template',
    style: 'Style',
    context: 'Context',
    terminology: 'Terminology',
    audience: 'Audience',
    promptTemplate: 'Prompt Template',
    promptPlaceholder: 'You are translating a {content_type} from {source_language} to {target_language}. Use {style} language appropriate for {audience} audience. For terminology handling: {terminology}...',
    variablesHint: 'Use variables:',
    preview: 'Preview:',
    updateButton: 'Update Template',
    createButton: 'Create Template',
    noTemplatesFound: 'No prompt templates found. Create your first template to get started.',
    default: 'Default',
    previewTitle: 'Preview: {name}',
    generatedPrompt: 'Generated Prompt:',
    columns: {
      name: 'Name',
      contentType: 'Content Type',
      style: 'Style',
      status: 'Status',
      created: 'Created',
    },
    contentTypes: {
      sermon: 'Sermon',
      announcement: 'Announcement',
      lecture: 'Lecture',
      dua: 'Dua',
    },
    styleOptions: {
      formal: 'Formal',
      casual: 'Casual',
      youth: 'Youth',
      academic: 'Academic',
      default: 'Default',
    },
    contextOptions: {
      friday: 'Friday',
      eid: 'Eid',
      ramadan: 'Ramadan',
      special: 'Special',
    },
    terminologyOptions: {
      preserve: 'Preserve',
      translate: 'Translate',
      simplify: 'Simplify',
    },
    audienceOptions: {
      general: 'General',
      children: 'Children',
      scholars: 'Scholars',
    },
  },
  mosqueCreation: {
    title: 'Create New Mosque',
    description: 'Create a new mosque. You can add admin users later.',
    successTitle: 'Mosque Created Successfully!',
    successDescription: 'The mosque has been created and the admin account is ready',
    mosqueDetails: 'Mosque Details',
    nameLabel: 'Name',
    subdomainLabel: 'Subdomain',
    urlLabel: 'URL',
    successAlert: 'The mosque has been created successfully. You can now add admin users through the Users page.',
    mosqueNameLabel: 'Mosque Name',
    mosqueNamePlaceholder: 'e.g., Al-Noor Islamic Center',
    subdomainPlaceholder: 'al-noor',
    subdomainDescription: 'This will be the unique URL for the mosque',
    descriptionLabel: 'Description',
    descriptionPlaceholder: 'Brief description of the mosque...',
    cityLabel: 'City',
    cityPlaceholder: 'e.g., Amsterdam',
    countryLabel: 'Country',
    countryPlaceholder: 'e.g., Netherlands',
    timezoneLabel: 'Timezone',
    timezonePlaceholder: 'Select timezone',
    contactEmailLabel: 'Contact Email',
    contactEmailPlaceholder: 'info@mosque.com',
    contactPhoneLabel: 'Contact Phone',
    contactPhonePlaceholder: '+31 20 123 4567',
    creatingButton: 'Creating...',
    createButton: 'Create Mosque',
  },
  publicSpeech: {
    loading: 'Loading speech transcript...',
    loadingTranscripts: 'Loading {fetched} of {total} transcripts...',
    sessionNotFound: 'Session Not Found',
    sessionNotFoundDescription: 'This session does not exist or has been removed.',
    backToSpeeches: 'Back to Speeches',
    back: 'Back',
    exportFormatPlaceholder: 'Export format',
    exportOptions: {
      formatted: 'Formatted Text',
      transcript: 'Transcript Only',
      translation: 'Translation Only',
      srt: 'SRT Subtitles',
    },
    transcriptTitle: 'Transcript',
    noTranscriptData: 'No transcript data available for this session.',
    noTranscription: 'No transcription',
    noTranslation: 'No translation',
  },
  publicSpeechList: {
    title: 'Public Speeches',
    description: 'Browse and read transcripts from past speeches',
    searchPlaceholder: 'Search by mosque or room name...',
    sortByPlaceholder: 'Sort by',
    sortOptions: {
      date: 'Date (Newest)',
      duration: 'Duration',
      transcripts: 'Transcript Count',
    },
    noSpeechesFound: 'No speeches found',
    noSpeechesAvailable: 'No public speeches available at this time.',
    noMatch: 'No speeches match your search criteria.',
    started: 'Started',
    duration: 'Duration',
    transcripts: 'Transcripts',
    viewSpeech: 'View Speech',
    showingResults: 'Showing {start} to {end} of {total} speeches',
  },
  remoteControl: {
    title: 'Remote Control',
    description: 'Control monitoring sessions remotely',
    activeSessions: 'Active Monitoring Sessions',
    connected: 'Connected',
    connecting: 'Connecting...',
    noActiveSessions: 'No active monitoring sessions. Open a room monitor to see it here.',
    roomIsOpen: 'ROOM {roomName} is open',
    session: 'Session',
    goLive: 'Go Live',
    toggleMic: 'Toggle Microphone',
    end: 'END',
  },
  participantInfo: {
    participants: 'Participants',
    activeMics: 'Active Mics',
    listening: 'Listening',
    users: 'users',
    active: 'active',
    mics: 'mics',
  },
  hostControls: {
    setupRequiredTitle: 'Setup Required',
    setupRequiredDescription: 'This room needs to be configured before you can start an audio session.',
    readyToBroadcastTitle: 'Ready to Broadcast',
    readyToBroadcastDescription: 'Start your audio session for {roomTitle}',
    connectingButton: 'Connecting...',
    startBroadcastingButton: 'Start Broadcasting',
    configErrorTitle: 'Configuration Error',
    configErrorDescription: 'Server configuration is missing. Please contact support.',
    liveBroadcasting: 'Live Broadcasting',
    endBroadcastButton: 'End Broadcast',
  },
  conversation: {
    title: 'Conversation Mode',
    description: 'Two-way conversation between rooms with real-time translation',
    controlCenterTitle: 'Conversation Control Center',
    controlCenterDescription: 'Choose how to open conversation windows - both at once or individually for multi-device control.',
    howToUseTitle: 'How to use Conversation Mode:',
    step1: 'Choose to open both windows or individual windows below',
    step2: 'In the Primary window, select the rooms for your conversation',
    step3: 'Click "Start Conversation" to load both rooms',
    step4: 'Click "Go Live" to begin the session',
    step5: 'Only one microphone can be active at a time (push-to-talk style)',
    step6: 'Use "Leave Room" to return to room selection',
    openBothWindows: 'Open Both Windows',
    manualControlTitle: 'Manual Room Control',
    manualControlDescription: 'Open individual conversation windows for multi-device control',
    openPrimaryOnly: 'Open Primary Room Only',
    openSecondaryOnly: 'Open Secondary Room Only',
    tipTitle: 'Tip',
    tipDescription: 'You can control each room from different devices when logged in with the same account.',
    noteTitle: 'Note',
    noteDescription: 'If windows don\'t open, please check your browser\'s popup blocker settings.',
  },
  conversationSelector: {
    participantWaitingTitle: 'Participant Waiting Room',
    participantWaitingDescription: 'The host is preparing the conversation session. You\'ll be connected automatically.',
    pleaseWait: 'Please wait while the host sets up the translation rooms...',
    hostControlTitle: 'Host Control Panel',
    hostControlDescription: 'Select translation rooms for your conversation with the participant.',
    hostLanguageRoom: 'Host\'s Language Room',
    hostRoomDescription: 'Select the room that translates from your language to the participant\'s language',
    selectHostRoom: 'Select host\'s room',
    participantLanguageRoom: 'Participant\'s Language Room',
    participantRoomDescription: 'Select the room that translates from participant\'s language to your language',
    selectParticipantRoom: 'Select participant\'s room',
    startConversation: 'Start Conversation',
    selectedRooms: 'Selected rooms',
    primary: 'Primary',
    secondary: 'Secondary',
  },
  userMosqueAssignment: {
    title: 'User Mosque Assignment',
    description: 'Manage which mosque each user belongs to',
    showAllUsers: 'Show All Users',
    showUnassignedOnly: 'Show Unassigned Only',
    noUnassignedUsers: 'No unassigned users found. All users are assigned to mosques.',
    noUsersFound: 'No users found.',
    currently: 'Currently',
    noMosqueAssigned: 'No Mosque Assigned',
    selectMosque: 'Select mosque',
  },
  userCreation: {
    title: 'Create New User',
    description: 'Create a new user for a mosque',
    emailPlaceholder: 'user@example.com',
    fullNameLabel: 'Full Name',
    fullNamePlaceholder: 'John Doe',
    passwordLabel: 'Password',
    selectMosquePlaceholder: 'Select a mosque',
    creatingButton: 'Creating...',
    createButton: 'Create User',
  },
  mediaDeviceMenu: {
    currentDevice: 'Current Device',
    device: 'Device',
    devicesAvailable: '{count} device available',
    devicesAvailable_plural: '{count} devices available',
  },
  disconnectedControls: {
    readyToBroadcast: 'Ready to Broadcast',
    audioSession: 'Audio Session',
    connecting: 'Connecting...',
    startBroadcasting: 'Start Broadcasting',
  },
  connectedControls: {
    live: 'Live',
    end: 'End',
  },
  displayPage: {
    notConnectedTitle: 'Display Not Connected',
    notConnectedDescription: 'This display is not connected to a room. Please launch it from the monitor page.',
    exampleUrl: '/display?room=ROOM_NAME&mosque_id=1&room_id=123',
  },
  videoStream: {
    noCameraSelected: 'No camera selected',
    selectCamera: 'Select camera...',
    camera: 'Camera',
    enableCamera: 'Enable Camera',
    connectingToCamera: 'Connecting to camera...',
    noCameraFound: 'No camera found',
    accessDenied: 'Camera access denied',
    cameraInUse: 'Camera in use',
    cameraUnavailable: 'Camera unavailable',
    startCamera: 'Start Camera',
  }
};


================================================
FILE: src/lib/translations/index.ts
================================================
import { TranslationStructure, LanguageCode } from './types';
import { en } from './en';
import { ar } from './ar';
import { nl } from './nl';
import { getNestedTranslation, validateTranslationCompleteness } from './utils';

// Translation registry
const translationRegistry: Record<LanguageCode, TranslationStructure> = {
  en,
  ar,
  nl,
};

// Validate translations in development
if (process.env.NODE_ENV === 'development') {
  // Validate Arabic translations against English base
  validateTranslationCompleteness(en, ar, 'ar');
  // Validate Dutch translations against English base
  validateTranslationCompleteness(en, nl, 'nl');
}

/**
 * Get all available translations
 */
export const translations = translationRegistry;

/**
 * Get translation for a specific language with fallback to English
 * @param language Language code
 * @returns Translation object
 */
export function getTranslation(language: LanguageCode): TranslationStructure {
  return translationRegistry[language] || translationRegistry.en;
}

/**
 * Get available language codes
 */
export function getAvailableLanguages(): LanguageCode[] {
  return Object.keys(translationRegistry) as LanguageCode[];
}

/**
 * Check if a language is available
 * @param language Language code to check
 */
export function isLanguageAvailable(language: string): language is LanguageCode {
  return language in translationRegistry;
}

// Re-export utilities
export { getNestedTranslation, interpolate, isRTL, getDirection } from './utils';
export type { TranslationStructure, LanguageCode, TranslationKey } from './types';


================================================
FILE: src/lib/translations/nl.ts
================================================
import { TranslationStructure } from './types';

export const nl: TranslationStructure = {
  common: {
    signOut: 'Uitloggen',
    loading: 'Laden...',
    error: 'Fout',
    retry: 'Opnieuw proberen',
    save: 'Opslaan',
    cancel: 'Annuleren',
    delete: 'Verwijderen',
    edit: 'Bewerken',
    create: 'Aanmaken',
    update: 'Bijwerken',
    actions: 'Acties',
    tryAgain: 'Probeer opnieuw',
    success: 'Succes',
    id: 'ID',
    status: 'Status',
    created: 'Aangemaakt',
    active: 'Actief',
    pending: 'In behandeling',
    notSet: 'Niet ingesteld',
    live: 'Live',
    offline: 'Offline',
    monitor: 'Monitor',
    preparing: 'Voorbereiden...',
    bayanPlatform: 'bayaan Platform',
    goToDashboard: 'Ga naar Dashboard',
    viewPublicSpeeches: 'Bekijk Openbare Toespraken',
    showing: 'Toont',
    of: 'van',
    previous: 'Vorige',
    next: 'Volgende',
    rooms: 'kamers',
    sessions: 'sessies',
  },
  dashboard: {
    title: 'Dashboard',
    superAdminTitle: 'Super Admin Dashboard',
    mosqueAdminTitle: 'Moskee Admin Dashboard',
    welcome: 'Welkom',
    loadingProfile: 'Gebruikersprofiel laden...',
    errorLoadingProfile: 'Fout bij het laden van gebruikersprofiel. Probeer het opnieuw.',
    loadingDashboard: 'Dashboard laden...',
    profileNotFound: 'Gebruikersprofiel niet gevonden. Neem contact op met een beheerder om je account in te stellen.',
    defaultMosqueName: 'Al Fourqaan',
    superAdminSubtitle: 'Beheer moskee-huurders',
    mosqueAdminSubtitle: 'Beheer preken en evenementen',
    history: 'Geschiedenis',
    overview: 'Overzicht',
    mosques: 'Moskeeën',
    users: 'Gebruikers',
    prompts: 'Prompts',
    settings: 'Instellingen',
    rooms: 'Kamers',
    monitor: 'Monitor',
    sessions: 'Sessies',
    billing: 'Gebruik',
    sessionArchive: 'Sessie Archief',
  },
  navigation: {
    dashboard: 'Dashboard',
    rooms: 'Kamers',
    users: 'Gebruikers',
    settings: 'Instellingen',
  },
  superAdmin: {
    stats: {
      totalMosques: 'Totaal Moskeeën',
      activeTenants: 'Actieve huurders op het platform',
      liveUpdates: 'Live Updates',
      realTime: 'Real-time',
      autoRefreshing: 'Automatisch vernieuwen van gegevens',
      quickAction: 'Snelle Actie',
      addNewMosque: 'Nieuwe Moskee Toevoegen',
    },
    onboarding: {
      title: 'Nieuwe Huurder Toevoegen',
      mosqueName: 'Moskee Naam',
      mosqueNamePlaceholder: 'Voer moskee naam in...',
      createMosque: 'Moskee Aanmaken & Implementeren',
      creatingMosque: 'Moskee aanmaken...',
      mosqueCreated: 'Moskee "{name}" is aangemaakt met subdomein "{subdomain}".',
      mosqueExists: 'Een moskee met subdomein "{subdomain}" bestaat al',
      mosqueFailed: 'Moskee aanmaken mislukt',
    },
    mosques: {
      title: 'Beheerde Moskeeën',
      loadingMosques: 'Moskeeën laden...',
      noMosquesFound: 'Geen moskeeën gevonden',
      noMosquesDescription: 'Begin door je eerste moskee toe te voegen aan het platform.',
      addFirstMosque: 'Eerste Moskee Toevoegen',
      mosqueName: 'Moskee Naam',
      subdomain: 'Subdomein',
      viewUsers: 'Gebruikers Bekijken',
      hideUsers: 'Gebruikers Verbergen',
    },
    sessions: {
      description: 'Bekijk en beheer sessiegeschiedenis voor alle moskeeën',
      totalSessions: 'Totaal opgenomen sessies',
      activeSessions: 'Momenteel live',
      completedSessions: 'Voltooide sessies',
      averageDuration: 'Gemiddelde sessielengte',
      averageSentences: 'Gemiddelde zinnen per sessie',
      totalSentences: 'Totaal vertaalde zinnen',
      sessionHistory: 'Sessiegeschiedenis',
      searchPlaceholder: 'Zoek op kamer, moskee of sessie-ID...',
      filterByMosque: 'Filter op Moskee',
      filterByDate: 'Filter op Datum',
      noSessionsFound: 'Geen Sessies Gevonden',
      noSessionsDescription: 'Er zijn nog geen sessies opgenomen.',
    },
    validation: {
      mosqueNameMin: 'Moskee naam moet minstens 2 tekens zijn',
      mosqueNameMax: 'Moskee naam moet minder dan 100 tekens zijn',
      templateNameMin: 'Sjabloon naam moet minstens 2 tekens zijn',
    },
    templates: {
      spokenLanguage: 'Gesproken Taal',
      translationLanguage: 'Vertaaltaal',
    },
  },
  mosqueAdmin: {
    tabs: {
      roomManagement: 'Kamer Beheer',
      liveMonitor: 'Live Monitor',
    },
    stats: {
      totalRooms: 'Totaal Kamers',
      available: 'Beschikbaar',
      statusMonitorError: 'Status Monitor Fout',
    },
    rooms: {
      title: 'Kamer Status Monitoring',
      createNew: 'Nieuwe Kamer Aanmaken',
      manageRooms: 'Kamers Beheren',
      roomTitle: 'Kamer Titel',
      roomTitlePlaceholder: 'Voer kamer titel in...',
      maxDelay: 'Max Vertraging (seconden)',
      maxDelayDescription: 'Hogere vertraging zorgt voor nauwkeurigere vertalingen door langer te wachten op volledige zinnen. Lagere waarden geven prioriteit aan snelheid boven nauwkeurigheid.',
      punctuationSensitivity: 'Interpunctie Gevoeligheid',
      punctuationSensitivityDescription: 'Hogere gevoeligheid creëert zinnen sneller door leestekens agressiever te detecteren. Lagere waarden wachten op duidelijkere zingrenzen.',
      contextWindowSize: 'Context Venstergrootte',
      contextWindowSizeDescription: 'Aantal vorige zinnenparen om te behouden voor vertalingscontext. Hogere waarden zorgen voor betere continuïteit maar kunnen de responstijd verhogen.',
      sentences: 'zinnen',
      advancedSettings: 'Geavanceerde Instellingen',
      showAdvanced: 'Geavanceerd Tonen',
      hideAdvanced: 'Geavanceerd Verbergen',
      createRoom: 'Kamer Aanmaken',
      creatingRoom: 'Kamer aanmaken...',
      roomCreated: 'Kamer "{title}" is aangemaakt. Monitor openen...',
      roomFailed: 'Kamer aanmaken mislukt',
      deleteConfirm: 'Weet je zeker dat je "{title}" wilt verwijderen? Deze actie kan niet ongedaan worden gemaakt.',
      roomDeleted: '"{title}" is succesvol verwijderd.',
      deleteFailed: 'Kamer verwijderen mislukt',
      noRoomsFound: 'Geen kamers gevonden',
      noRoomsDescription: 'Maak je eerste kamer aan om te beginnen met live vertaling.',
      monitor: 'Monitoren',
      stopMonitoring: 'Monitoring Stoppen',
      share: 'Delen',
      view: 'Bekijken',
      languages: 'Talen',
      configureAndStart: 'Configureer en start een nieuwe kamer',
      templateDescription: 'Snelle voorinstellingen voor veelvoorkomende kamertypes. Selecteer "Aangepast" voor handmatige controle.',
      delayLabel: 'Vertraging',
      punctuationLabel: 'Interpunctie',
      publicDisplay: 'Openbare Weergave',
      kioskMode: 'Kiosk Modus',
      urlCopied: 'Openbare weergave URL gekopieerd naar klembord',
      promptTemplate: 'Vertaalstijl',
      selectPromptTemplate: 'Selecteer een vertaalstijl',
      defaultPrompt: 'Standaard vertaalstijl',
      promptTemplateDescription: 'Kies hoe de AI de inhoud moet vertalen (preek, aankondiging, enz.)',
      editRoom: 'Kamer Instellingen Bewerken',
      updateRoom: 'Kamer Bijwerken',
      updating: 'Bijwerken...',
      roomUpdated: 'Kamer succesvol bijgewerkt',
      roomUpdateFailed: 'Kamer bijwerken mislukt',
      statusUpdated: 'Kamer status bijgewerkt',
      statusUpdateFailed: 'Kamer status bijwerken mislukt',
      contentType: 'Inhoudstype',
      selectContentType: 'Selecteer inhoudstype',
      contentTypeDescription: 'Kies het type inhoud voor geoptimaliseerde spraakherkenning',
      domain: {
        broadcast: 'Preek/Lezing (Formele spraak)',
        conversational: 'Discussie/Vraag & Antwoord (Informeel)',
        general: 'Algemeen/Gemengde inhoud',
      },
    },
    monitor: {
      noRoomSelected: 'Geen Kamer Geselecteerd',
      selectRoomDescription: 'Selecteer een kamer van het Kamer Beheer tabblad om live monitoring te starten.',
      goToRoomManagement: 'Ga naar Kamer Beheer',
      liveMonitorTitle: 'Live Monitor',
      roomId: 'Kamer ID',
      status: 'Status',
      launchDisplay: 'Weergave Starten',
      display: 'Weergave',
      goLive: 'Live Gaan',
      live: 'Live',
      leaveRoom: 'Kamer Verlaten',
      leave: 'Verlaten',
      complete: 'Voltooid',
      translating: 'Vertalen...',
      waitingForTranslation: 'Wachten op vertaling...',
      waitingForTranscription: 'Wachten op spraak...',
      translationActivityLog: 'Vertaal Activiteit Log',
      participantCount: 'Aantal deelnemers',
      connectionStatus: 'Verbindingsstatus',
      currentActivity: 'Huidige activiteit',
      transcriptCount: 'Transcript aantal',
      translationWillAppear: 'Vertaling verschijnt wanneer zin compleet is...',
    },
    validation: {
      roomTitleMin: 'Kamer titel moet minstens 2 tekens zijn',
      roomTitleMax: 'Kamer titel moet minder dan 200 tekens zijn',
      spokenLanguageRequired: 'Selecteer een gesproken taal',
      translationLanguageRequired: 'Selecteer een vertaal taal',
      maxDelayMin: 'Max vertraging moet minstens 1.0 seconden zijn',
      maxDelayMax: 'Max vertraging moet hoogstens 5.0 seconden zijn',
      punctuationMin: 'Interpunctie gevoeligheid moet minstens 0.0 zijn',
      punctuationMax: 'Interpunctie gevoeligheid moet hoogstens 1.0 zijn',
    },
  },
  languages: {
    ar: 'Arabisch',
    en: 'Engels',
    nl: 'Nederlands',
    fr: 'Frans',
    de: 'Duits',
    es: 'Spaans',
  },
  auth: {
    bayanPlatform: 'bayaan Platform',
    adminPanel: 'Moskeebeheer & Vertaling Admin Panel',
    signIn: 'Inloggen',
    signInPrompt: 'Voer uw gegevens in om toegang te krijgen tot het admin panel',
    emailLabel: 'E-mail',
    emailPlaceholder: 'admin@example.com',
    passwordLabel: 'Wachtwoord',
    passwordPlaceholder: 'Voer uw wachtwoord in',
    signingIn: 'Inloggen...',
    unexpectedError: 'Er is een onverwachte fout opgetreden. Probeer het opnieuw.',
    signOut: 'Afmelden',
  },
  history: {
    title: 'Sessiegeschiedenis',
    description: 'Bekijk en herhaal voltooide sessies',
    loading: 'Laden...',
    backToDashboard: 'Dashboard',
    signOut: 'Uitloggen',
  },
  publicDisplay: {
    connectError: 'Voer een kamercode in',
    validationError: 'Kon kamercode niet valideren',
    invalidCode: 'Ongeldige kamercode of kamer niet beschikbaar voor openbare toegang',
    connectionFailed: 'Kon geen verbinding maken met de kamer',
    disconnect: 'Verbinding verbreken',
    title: 'Verbinden met Live Display',
    description: 'Voer de kamercode in om verbinding te maken met de live weergave',
    roomCodeLabel: 'Kamercode',
    roomCodePlaceholder: 'bijv. 870218',
    connecting: 'Verbinden...',
    connectButton: 'Verbinden met Display',
    instructions: 'Kamercodes worden verstrekt door uw moskeebeheerder',
  },
  sessionHistory: {
    title: 'Sessiegeschiedenis',
    description: 'Bekijk en herhaal voltooide vertaalsessies',
    loading: 'Sessiegeschiedenis laden...',
    searchPlaceholder: 'Zoek op kamernaam...',
    filterByRoom: 'Filter op kamer',
    allRooms: 'Alle kamers',
    sortBy: 'Sorteer op',
    dateNewest: 'Datum (nieuwste eerst)',
    duration: 'Duur',
    transcriptCount: 'Aantal transcripties',
    completedSessions: 'Voltooide sessies',
    noSessionsFound: 'Geen sessies gevonden',
    noCompletedSessions: 'Nog geen voltooide sessies. Start uw eerste live sessie vanaf het dashboard.',
    noMatchingSessions: 'Geen sessies komen overeen met uw huidige filters.',
    table: {
      room: 'Kamer',
      languages: 'Talen',
      started: 'Gestart',
      duration: 'Duur',
      transcripts: 'Transcripties',
      actions: 'Acties',
    },
    viewSession: 'Sessie bekijken',
    roomFallback: 'Kamer',
    languageFrom: 'Van',
    languageTo: 'Naar',
    notAvailable: 'N/B',
    hours: 'u',
    minutes: 'm',
    seconds: 's',
    publicTitleLabel: 'Openbare Titel',
    publicTitlePlaceholder: 'Voer een titel in voor de openbare toespraak...',
    showingResults: 'Resultaten {start} tot {end} van {total} sessies',
  },
  sessionReplay: {
    sessionNotFound: 'Sessie niet gevonden',
    sessionNotFoundDescription: 'De gevraagde sessie kon niet worden gevonden.',
    backButton: 'Terug',
    refreshAll: 'Alles vernieuwen',
    exportButton: 'Exporteren',
    export: {
      fullTranscript: 'Volledig transcript',
      translationOnly: 'Alleen vertaling',
      srtSubtitles: 'SRT-ondertitels',
      formattedCards: 'Opgemaakte kaarten',
    },
    noTranscriptsFound: 'Geen transcripties gevonden voor deze sessie',
    noTranslationAvailable: 'Geen vertaling beschikbaar',
  },
  mosqueAdminDashboard: {
    health: 'Gezondheid',
    statusTooltip: 'Status wordt automatisch bijgewerkt op basis van actieve sessies',
  },
  impersonation: {
    impersonating: 'U imiteert:',
    actionsAsUser: 'Alle acties worden uitgevoerd als deze gebruiker',
    returnToSuperAdmin: 'Terugkeren naar Super Admin',
    startedTitle: 'Imitatie gestart',
    startedDescription: 'Nu ingelogd als {email}',
    failedTitle: 'Imitatie mislukt',
    failedDescription: 'Kon imitatie niet starten',
    endedTitle: 'Imitatie beëindigd',
    endedDescription: 'Teruggekeerd naar super admin account',
    endFailed: 'Kon imitatie niet correct beëindigen',
  },
  roomCodeManager: {
    updatedTitle: 'Openbare toegang bijgewerkt',
    enabledDescription: 'Kamer {id} is nu openbaar toegankelijk',
    disabledDescription: 'Openbare toegang uitgeschakeld voor kamer {id}',
    updateFailed: 'Kon instelling voor openbare toegang niet bijwerken',
    copiedTitle: 'Gekopieerd',
    copiedDescription: 'Kamercode gekopieerd',
    codeLabel: 'Code',
  },
  kioskToggle: {
    updatedTitle: 'Kiosk Modus Bijgewerkt',
    enabledDescription: 'Kiosk modus ingeschakeld voor {name}. Deze kamer blijft permanent actief.',
    disabledDescription: 'Kiosk modus uitgeschakeld voor {name}',
    updateFailed: 'Kon kiosk modus niet bijwerken',
  },
  liveMonitor: {
    users: 'Gebruikers',
    messages: 'Berichten',
    transcripts: 'Transcripties',
    status: 'Status',
    setupRequiredTitle: 'Installatie vereist',
    setupRequiredDescription: 'Deze kamer vereist LiveKit-configuratie om audiosessies te starten.',
    startAudioTitle: 'Start audiosessie',
    startAudioDescription: 'Maak verbinding om live audiovertaling te starten',
    connecting: 'Verbinden...',
    startSession: 'Start sessie',
    audioLive: 'Audio Live',
    mic: 'Microfoon',
    endSession: 'Sessie beëindigen',
    serverConfigRequired: 'Serverconfiguratie vereist',
    serverConfigDescription: 'Neem contact op met ondersteuning om de LiveKit-server te configureren.',
    activityTitle: 'Live vertaalactiviteit',
    activityDescription: 'Arabisch → {language} • Real-time van Python Agent',
    waitingForActivity: 'Wachten op vertaalactiviteit...',
    startMonitoringPrompt: 'Start monitoring om live activiteit te bekijken',
    liveTranslation: 'Live Vertaling',
    liveTranscription: 'Live Transcriptie',
    typing: 'Aan het typen...',
    waitingForTranslation: 'Wachten op vertaling...',
    display: 'Weergave',
    launchDisplay: 'Weergave Starten',
  },
  quranDisplay: {
    cameraFeed: 'Beeldmateriaal / Camerabeeld',
    waitingForArabic: 'Wachten op Arabische tekst...',
    demoArabic: 'Demomodus - Arabische tekst',
    waitingForTranslation: 'Wachten op vertaling...',
    demoTranslation: 'Demomodus - Live vertaalweergave',
    translationTitle: 'Live Vertaling',
    latest: 'Nieuwste',
  },
  superAdminDashboard: {
    from: 'Van',
    to: 'Naar',
    unknownMosque: 'Onbekende moskee',
    noTemplatesDescription: 'Maak sjablonen om kamerconfiguraties voor alle moskeeën te standaardiseren.',
  },
  form: {
    validation: {
      required: 'Dit veld is verplicht',
      minLength: 'Moet minstens {min} tekens zijn',
      maxLength: 'Moet minder dan {max} tekens zijn',
      selectRequired: 'Selecteer een optie',
      titleRequired: 'Kamer titel moet minstens 2 tekens zijn',
      titleMaxLength: 'Kamer titel moet minder dan 200 tekens zijn',
      mosqueNameMin: 'Moskee naam moet minstens 2 tekens zijn',
      mosqueNameMax: 'Moskee naam moet minder dan 100 tekens zijn',
      templateNameMin: 'Sjabloon naam moet minstens 2 tekens zijn',
      maxDelayRange: 'Max vertraging moet tussen 1.0 en 5.0 seconden zijn',
      punctuationRange: 'Interpunctie gevoeligheid moet tussen 0.0 en 1.0 zijn',
      languageRequired: 'Selecteer een taal',
    }
  },
  technical: {
    livekit: 'LiveKit',
    websocket: 'WebSocket',
    errors: {
      fetchFailed: 'Gegevens ophalen mislukt',
      createFailed: 'Aanmaken mislukt',
      updateFailed: 'Bijwerken mislukt',
      deleteFailed: 'Verwijderen mislukt',
      connectionError: 'Verbindingsfout',
      authError: 'Authenticatie fout',
      permissionDenied: 'Toegang geweigerd',
      notFound: 'Niet gevonden',
      alreadyExists: 'Bestaat al',
      invalidData: 'Ongeldige gegevens',
      mosqueNotFound: 'Moskee met ID {id} niet gevonden',
      userNotAuthenticated: 'Gebruiker niet geauthenticeerd',
      subdomaineExists: 'Een moskee met subdomein "{subdomain}" bestaat al',
      noAuthSession: 'Geen authenticatie sessie',
      livekitRoomFailed: 'LiveKit kamer aanmaken mislukt',
      fetchMosquesFailed: 'Moskeeën ophalen mislukt',
      fetchTemplatesFailed: 'Sjablonen ophalen mislukt',
      fetchUsersFailed: 'Gebruikers ophalen mislukt',
    }
  },
  toast: {
    success: {
      created: 'Succesvol aangemaakt',
      updated: 'Succesvol bijgewerkt',
      deleted: 'Succesvol verwijderd',
      copied: 'Gekopieerd naar klembord',
      saved: 'Instellingen opgeslagen',
    },
    error: {
      generic: 'Er is iets misgegaan',
      network: 'Netwerkfout opgetreden',
      validation: 'Controleer je invoer',
      unauthorized: 'Je bent niet geautoriseerd',
      timeout: 'Verzoek verlopen',
    },
    warning: {
      unsavedChanges: 'Je hebt niet-opgeslagen wijzigingen',
      dataLoss: 'Deze actie kan niet ongedaan worden gemaakt',
    }
  },
  users: {
    title: 'Gebruikers',
    email: 'E-mail',
    actions: 'Acties',
    loginAs: 'Inloggen Als',
    starting: 'Starten...',
    loadingUsers: 'Gebruikers laden...',
    noUsersFound: 'Geen gebruikers gevonden',
    noUsersDescription: 'Deze moskee heeft nog geen gebruikers.',
    impersonationFailed: 'Imitatie starten mislukt',
    mosqueUsers: '{mosqueName} Gebruikers',
  },
  monitoring: {
    status: 'Status',
    active: 'Actief',
    inactive: 'Inactief',
    live: 'Live',
    empty: 'Leeg',
    pending: 'In behandeling',
    error: 'Fout',
    connecting: 'Verbinden...',
    connected: 'Verbonden',
    disconnected: 'Verbroken',
    reconnecting: 'Opnieuw verbinden...',
  },
  advanced: {
    title: 'Geavanceerde Instellingen',
    show: 'Geavanceerd Tonen',
    hide: 'Geavanceerd Verbergen',
    configuration: 'Configuratie',
    template: 'Sjabloon',
    custom: 'Aangepast',
    default: 'Standaard',
    reset: 'Terugzetten naar Standaard',
    apply: 'Instellingen Toepassen',
  },
  dialogs: {
    confirm: 'Bevestigen',
    cancel: 'Annuleren',
    delete: 'Verwijderen',
    save: 'Opslaan',
    discard: 'Verwerpen',
    areYouSure: 'Weet je het zeker?',
    deleteConfirm: 'Deze actie kan niet ongedaan worden gemaakt',
    unsavedWarning: 'Je hebt niet-opgeslagen wijzigingen. Wil je ze verwerpen?',
    browserWarning: 'Je hebt een actieve monitoring sessie. Weet je zeker dat je wilt vertrekken?',
  },
  promptTemplates: {
    title: 'Prompt Sjablonen',
    createTemplate: 'Sjabloon aanmaken',
    editTitle: 'Prompt Sjabloon bewerken',
    createTitle: 'Prompt Sjabloon aanmaken',
    templateName: 'Sjabloon naam',
    templateNamePlaceholder: 'bv. Formele Vrijdagpreek',
    contentType: 'Inhoudstype',
    selectContentType: 'Selecteer inhoudstype',
    descriptionLabel: 'Beschrijving (Optioneel)',
    descriptionPlaceholder: 'Korte beschrijving van wanneer dit sjabloon te gebruiken',
    style: 'Stijl',
    context: 'Context',
    terminology: 'Terminologie',
    audience: 'Publiek',
    promptTemplate: 'Prompt Sjabloon',
    promptPlaceholder: 'U vertaalt een {content_type} van {source_language} naar {target_language}. Gebruik {style} taal geschikt voor {audience} publiek. Voor terminologiehantering: {terminology}...',
    variablesHint: 'Gebruik variabelen:',
    preview: 'Voorbeeld:',
    updateButton: 'Sjabloon bijwerken',
    createButton: 'Sjabloon aanmaken',
    noTemplatesFound: 'Geen prompt sjablonen gevonden. Maak uw eerste sjabloon aan om te beginnen.',
    default: 'Standaard',
    previewTitle: 'Voorbeeld: {name}',
    generatedPrompt: 'Gegenereerde Prompt:',
    columns: {
      name: 'Naam',
      contentType: 'Inhoudstype',
      style: 'Stijl',
      status: 'Status',
      created: 'Aangemaakt',
    },
    contentTypes: {
      sermon: 'Preek',
      announcement: 'Aankondiging',
      lecture: 'Lezing',
      dua: 'Dua',
    },
    styleOptions: {
      formal: 'Formeel',
      casual: 'Informeel',
      youth: 'Jeugd',
      academic: 'Academisch',
      default: 'Standaard',
    },
    contextOptions: {
      friday: 'Vrijdag',
      eid: 'Eid',
      ramadan: 'Ramadan',
      special: 'Speciaal',
    },
    terminologyOptions: {
      preserve: 'Behouden',
      translate: 'Vertalen',
      simplify: 'Vereenvoudigen',
    },
    audienceOptions: {
      general: 'Algemeen',
      children: 'Kinderen',
      scholars: 'Geleerden',
    },
  },
  mosqueCreation: {
    title: 'Nieuwe moskee aanmaken',
    description: 'Maak een nieuwe moskee aan. U kunt later beheerders toevoegen.',
    successTitle: 'Moskee succesvol aangemaakt!',
    successDescription: 'De moskee is aangemaakt en het beheerdersaccount is klaar',
    mosqueDetails: 'Moskee Details',
    nameLabel: 'Naam',
    subdomainLabel: 'Subdomein',
    urlLabel: 'URL',
    successAlert: 'De moskee is succesvol aangemaakt. U kunt nu beheerders toevoegen via de Gebruikerspagina.',
    mosqueNameLabel: 'Naam van de moskee',
    mosqueNamePlaceholder: 'bv. Islamitisch Centrum Al-Noor',
    subdomainPlaceholder: 'al-noor',
    subdomainDescription: 'Dit wordt de unieke URL voor de moskee',
    descriptionLabel: 'Beschrijving',
    descriptionPlaceholder: 'Korte beschrijving van de moskee...',
    cityLabel: 'Stad',
    cityPlaceholder: 'bv. Amsterdam',
    countryLabel: 'Land',
    countryPlaceholder: 'bv. Nederland',
    timezoneLabel: 'Tijdzone',
    timezonePlaceholder: 'Selecteer tijdzone',
    contactEmailLabel: 'Contact E-mail',
    contactEmailPlaceholder: 'info@moskee.com',
    contactPhoneLabel: 'Contact Telefoon',
    contactPhonePlaceholder: '+31 20 123 4567',
    creatingButton: 'Aanmaken...',
    createButton: 'Moskee aanmaken',
  },
  publicSpeech: {
    loading: 'Toespraak transcript laden...',
    loadingTranscripts: '{fetched} van {total} transcripten laden...',
    sessionNotFound: 'Sessie niet gevonden',
    sessionNotFoundDescription: 'Deze sessie bestaat niet of is verwijderd.',
    backToSpeeches: 'Terug naar toespraken',
    back: 'Terug',
    exportFormatPlaceholder: 'Exporteer formaat',
    exportOptions: {
      formatted: 'Opgemaakte tekst',
      transcript: 'Alleen transcript',
      translation: 'Alleen vertaling',
      srt: 'SRT-ondertitels',
    },
    transcriptTitle: 'Transcript',
    noTranscriptData: 'Geen transcriptgegevens beschikbaar voor deze sessie.',
    noTranscription: 'Geen transcriptie',
    noTranslation: 'Geen vertaling',
  },
  publicSpeechList: {
    title: 'Openbare Toespraken',
    description: 'Blader en lees transcripties van eerdere toespraken',
    searchPlaceholder: 'Zoek op moskee of kamernaam...',
    sortByPlaceholder: 'Sorteer op',
    sortOptions: {
      date: 'Datum (Nieuwste)',
      duration: 'Duur',
      transcripts: 'Aantal transcripties',
    },
    noSpeechesFound: 'Geen toespraken gevonden',
    noSpeechesAvailable: 'Momenteel geen openbare toespraken beschikbaar.',
    noMatch: 'Geen toespraken voldoen aan uw zoekcriteria.',
    started: 'Gestart',
    duration: 'Duur',
    avgDuration: 'Gem. Duur',
    avgSentences: 'Gem. Zinnen',
    sentences: 'Zinnen',
    transcripts: 'Transcripties',
    viewSpeech: 'Bekijk Toespraak',
    showingResults: '{start} tot {end} van {total} toespraken weergegeven',
  },
  remoteControl: {
    title: 'Afstandsbediening',
    description: 'Bewaak sessies op afstand',
    activeSessions: 'Actieve monitoringsessies',
    connected: 'Verbonden',
    connecting: 'Verbinden...',
    noActiveSessions: 'Geen actieve monitoringsessies. Open een kamermonitor om deze hier te zien.',
    roomIsOpen: 'KAMER {roomName} is open',
    session: 'Sessie',
    goLive: 'GA LIVE',
    toggleMic: 'Microfoon in-/uitschakelen',
    end: 'EINDE',
  },
  participantInfo: {
    participants: 'Deelnemers',
    activeMics: 'Actieve microfoons',
    listening: 'Luisteren',
    users: 'gebruikers',
    active: 'actief',
    mics: 'microfoons',
  },
  hostControls: {
    setupRequiredTitle: 'Installatie vereist',
    setupRequiredDescription: 'Deze kamer moet worden geconfigureerd voordat u een audiosessie kunt starten.',
    readyToBroadcastTitle: 'Klaar om uit te zenden',
    readyToBroadcastDescription: 'Start uw audiosessie voor {roomTitle}',
    connectingButton: 'Verbinden...',
    startBroadcastingButton: 'Start uitzending',
    configErrorTitle: 'Configuratiefout',
    configErrorDescription: 'Serverconfiguratie ontbreekt. Neem contact op met ondersteuning.',
    liveBroadcasting: 'Live uitzending',
    endBroadcastButton: 'Uitzending beëindigen',
  },
  conversation: {
    title: 'Gespreksmodus',
    description: 'Tweerichtingsgesprek tussen kamers met real-time vertaling',
    controlCenterTitle: 'Gesprekscontrolecentrum',
    controlCenterDescription: 'Kies hoe u gespreksvensters wilt openen - beide tegelijk of afzonderlijk voor bediening op meerdere apparaten.',
    howToUseTitle: 'Hoe de gespreksmodus te gebruiken:',
    step1: 'Kies ervoor om beide vensters of afzonderlijke vensters hieronder te openen',
    step2: 'Selecteer in het primaire venster de kamers voor uw gesprek',
    step3: 'Klik op "Gesprek starten" om beide kamers te laden',
    step4: 'Klik op "Live gaan" om de sessie te beginnen',
    step5: 'Er kan slechts één microfoon tegelijk actief zijn (push-to-talk-stijl)',
    step6: 'Gebruik "Kamer verlaten" om terug te keren naar de kamerselectie',
    openBothWindows: 'Beide vensters openen',
    manualControlTitle: 'Handmatige kamerbediening',
    manualControlDescription: 'Open individuele gespreksvensters voor bediening op meerdere apparaten',
    openPrimaryOnly: 'Alleen primaire kamer openen',
    openSecondaryOnly: 'Alleen secundaire kamer openen',
    tipTitle: 'Tip',
    tipDescription: 'U kunt elke kamer vanaf verschillende apparaten bedienen wanneer u bent ingelogd met hetzelfde account.',
    noteTitle: 'Opmerking',
    noteDescription: 'Als de vensters niet worden geopend, controleer dan de pop-upblokkeringsinstellingen van uw browser.',
  },
  conversationSelector: {
    participantWaitingTitle: 'Wachtruimte voor deelnemers',
    participantWaitingDescription: 'De gastheer bereidt de gesprekssessie voor. U wordt automatisch verbonden.',
    pleaseWait: 'Even geduld terwijl de host de vertaalkamers instelt...',
    hostControlTitle: 'Host Configuratiescherm',
    hostControlDescription: 'Selecteer vertaalkamers voor uw gesprek met de deelnemer.',
    hostLanguageRoom: 'Taalkamer van de host',
    hostRoomDescription: 'Selecteer de kamer die vertaalt van uw taal naar de taal van de deelnemer',
    selectHostRoom: 'Selecteer de kamer van de host',
    participantLanguageRoom: 'Taalkamer van de deelnemer',
    participantRoomDescription: 'Selecteer de kamer die vertaalt van de taal van de deelnemer naar uw taal',
    selectParticipantRoom: 'Selecteer de kamer van de deelnemer',
    startConversation: 'Start gesprek',
    selectedRooms: 'Geselecteerde kamers',
    primary: 'Primair',
    secondary: 'Secundair',
  },
  disconnectedControls: {
    readyToBroadcast: 'Klaar om uit te zenden',
    audioSession: 'Audiosessie',
    connecting: 'Verbinden...',
    startBroadcasting: 'Start uitzending',
  },
  connectedControls: {
    live: 'Live',
    end: 'Einde',
  },
  userMosqueAssignment: {
    title: 'Gebruiker Moskee Toewijzing',
    description: 'Beheer aan welke moskee elke gebruiker is toegewezen',
    showAllUsers: 'Toon alle gebruikers',
    showUnassignedOnly: 'Toon alleen niet-toegewezen',
    noUnassignedUsers: 'Geen niet-toegewezen gebruikers gevonden. Alle gebruikers zijn toegewezen aan moskeeën.',
    noUsersFound: 'Geen gebruikers gevonden.',
    currently: 'Momenteel',
    noMosqueAssigned: 'Geen moskee toegewezen',
    selectMosque: 'Selecteer moskee',
  },
  userCreation: {
    title: 'Nieuwe gebruiker aanmaken',
    description: 'Maak een nieuwe gebruiker aan voor een moskee',
    emailPlaceholder: 'gebruiker@voorbeeld.com',
    fullNameLabel: 'Volledige naam',
    fullNamePlaceholder: 'Jan Jansen',
    passwordLabel: 'Wachtwoord',
    selectMosquePlaceholder: 'Selecteer een moskee',
    creatingButton: 'Aanmaken...',
    createButton: 'Gebruiker aanmaken',
  },
  mediaDeviceMenu: {
    currentDevice: 'Huidig apparaat',
    device: 'Apparaat',
    devicesAvailable: '{count} apparaat beschikbaar',
    devicesAvailable_plural: '{count} apparaten beschikbaar',
  },
  displayPage: {
    notConnectedTitle: 'Display niet verbonden',
    notConnectedDescription: 'Dit display is niet verbonden met een kamer. Start het vanaf de monitorpagina.',
    exampleUrl: '/display?room=ROOM_NAME&mosque_id=1&room_id=123',
  },
  videoStream: {
    noCameraSelected: 'Geen camera geselecteerd',
    selectCamera: 'Selecteer camera...',
    camera: 'Camera',
    enableCamera: 'Camera inschakelen',
    connectingToCamera: 'Verbinden met camera...',
    noCameraFound: 'Geen camera gevonden',
    accessDenied: 'Toegang tot camera geweigerd',
    cameraInUse: 'Camera in gebruik',
    cameraUnavailable: 'Camera niet beschikbaar',
    startCamera: 'Start Camera',
  },
  settings: {
    title: 'Instellingen',
    maintenanceMessagePlaceholder: 'Voer een aangepast bericht in voor gebruikers...',
    systemHealth: 'Systeemgezondheid',
    systemHealthDescription: 'Monitor systeemprestaties en gezondheidsstatistieken',
    apiStatus: 'API Status',
    databaseStatus: 'Database Status',
    livekitStatus: 'LiveKit Status',
    cpuUsage: 'CPU Gebruik',
    memoryUsage: 'Geheugengebruik',
    diskUsage: 'Schijfgebruik',
    runDatabaseMaintenance: 'Databaseonderhoud uitvoeren',
    clearCache: 'Cache wissen',
    livekitUrl: 'LiveKit URL',
    webhookSecret: 'Webhook Geheim',
    versionValue: 'v1.0.0',
    environmentValue: 'productie',
    databaseValue: 'PostgreSQL',
    maintenanceMessageDefault: 'We voeren momenteel gepland onderhoud uit. Probeer het later opnieuw.',
  },
};


================================================
FILE: src/lib/translations/types.ts
================================================
export interface TranslationStructure {
  common: {
    signOut: string;
    loading: string;
    error: string;
    retry: string;
    save: string;
    cancel: string;
    delete: string;
    edit: string;
    create: string;
    update: string;
    actions: string;
    tryAgain: string;
    success: string;
    id: string;
    status: string;
    created: string;
    active: string;
    pending: string;
    notSet: string;
    live: string;
    offline: string;
    monitor: string;
    preparing: string;
    inactive: string;
    completed: string;
    total: string;
    title: string;
    mosque: string;
    from: string;
    to: string;
    createdAt: string;
    unknown: string;
    room: string;
    user: string;
    email: string;
    role: string;
    joinedAt: string;
    admin: string;
    superAdmin: string;
    users: string;
    admins: string;
    all: string;
    allMosques: string;
    allStatuses: string;
    allTime: string;
    today: string;
    lastWeek: string;
    lastMonth: string;
    search: string;
    filter: string;
    export: string;
    import: string;
    noResultsFound: string;
    unauthorized: string;
    comingSoon: string;
    featureNotImplemented: string;
    avgDuration: string;
    transcripts: string;
    startTime: string;
    replay: string;
    confirmDelete: string;
    saving: string;
    quickActions: string;
    recentActivity: string;
    noRecentActivity: string;
    noRecentActivityDescription: string;
    noMosque: string;
    unnamed: string;
    editMosque: string;
    editDescription: string;
    deleteConfirmation: string;
    mosqueDeleted: string;
    mosqueUpdated: string;
    description: string;
    subdomain: string;
    saveChanges: string;
    updating: string;
    refresh: string;
    lastUpdated: string;
    connected: string;
  };
  dashboard: {
    title: string;
    superAdminTitle: string;
    mosqueAdminTitle: string;
    welcome: string;
    loadingProfile: string;
    errorLoadingProfile: string;
    loadingDashboard: string;
    profileNotFound: string;
    defaultMosqueName: string;
    superAdminSubtitle: string;
    mosqueAdminSubtitle: string;
    history: string;
  };
  navigation: {
    dashboard: string;
    rooms: string;
    users: string;
    settings: string;
  };
  superAdmin: {
    stats: {
      totalMosques: string;
      activeTenants: string;
      liveUpdates: string;
      realTime: string;
      autoRefreshing: string;
      quickAction: string;
      addNewMosque: string;
      systemOverview: string;
      registeredUsers: string;
      configuredTemplates: string;
    };
    onboarding: {
      title: string;
      mosqueName: string;
      mosqueNamePlaceholder: string;
      createMosque: string;
      creatingMosque: string;
      mosqueCreated: string;
      mosqueExists: string;
      mosqueFailed: string;
    };
    mosques: {
      title: string;
      loadingMosques: string;
      noMosquesFound: string;
      noMosquesDescription: string;
      addFirstMosque: string;
      mosqueName: string;
      subdomain: string;
      viewUsers: string;
      hideUsers: string;
      description: string;
      editMosque: string;
      editDescription: string;
      deleteConfirmation: string;
      mosqueDeleted: string;
      mosqueUpdated: string;
    };
    rooms: {
      description: string;
      totalRooms: string;
      activeRooms: string;
      pendingRooms: string;
      inactiveRooms: string;
      allRooms: string;
      searchPlaceholder: string;
      filterByMosque: string;
      filterByStatus: string;
      noRoomsFound: string;
      noRoomsDescription: string;
      monitoringComingSoon: string;
      statusUpdated: string;
      roomsDeleted: string;
    };
    sessions: {
      description: string;
      totalSessions: string;
      activeSessions: string;
      completedSessions: string;
      averageDuration: string;
      sessionHistory: string;
      searchPlaceholder: string;
      filterByMosque: string;
      filterByDate: string;
      noSessionsFound: string;
      noSessionsDescription: string;
    };
    users: {
      description: string;
      title: string;
      searchPlaceholder: string;
      filterByMosque: string;
      noUsersFound: string;
      noUsersDescription: string;
      userDeleted: string;
      roleUpdated: string;
      impersonate: string;
      impersonating: string;
      deleteConfirmation: string;
      bulkActions: string;
      makeAdmin: string;
      makeUser: string;
      deleteSelected: string;
      bulkDeleteConfirmation: string;
      bulkDeleteSuccess: string;
      bulkRoleUpdateSuccess: string;
      exportSuccess: string;
    };
    prompts: {
      description: string;
    };
    templates: {
      spokenLanguage: string;
      translationLanguage: string;
    };
    validation: {
      mosqueNameMin: string;
      mosqueNameMax: string;
      templateNameMin: string;
    };
  };
  mosqueAdmin: {
    tabs: {
      roomManagement: string;
      liveMonitor: string;
    };
    stats: {
      totalRooms: string;
      available: string;
      statusMonitorError: string;
    };
    rooms: {
      title: string;
      createNew: string;
      manageRooms: string;
      roomTitle: string;
      roomTitlePlaceholder: string;
      maxDelay: string;
      maxDelayDescription: string;
      punctuationSensitivity: string;
      punctuationSensitivityDescription: string;
      useTemplate: string;
      customTemplate: string;
      advancedSettings: string;
      showAdvanced: string;
      hideAdvanced: string;
      createRoom: string;
      creatingRoom: string;
      roomCreated: string;
      roomFailed: string;
      deleteConfirm: string;
      roomDeleted: string;
      deleteFailed: string;
      noRoomsFound: string;
      noRoomsDescription: string;
      monitor: string;
      stopMonitoring: string;
      share: string;
      view: string;
      languages: string;
      configureAndStart: string;
      templateDescription: string;
      delayLabel: string;
      punctuationLabel: string;
      publicDisplay: string;
      urlCopied: string;
      promptTemplate: string;
      selectPromptTemplate: string;
      defaultPrompt: string;
      promptTemplateDescription: string;
      editRoom: string;
      updateRoom: string;
      updating: string;
      roomUpdated: string;
      roomUpdateFailed: string;
    };
    monitor: {
      noRoomSelected: string;
      selectRoomDescription: string;
      goToRoomManagement: string;
      liveMonitorTitle: string;
      roomId: string;
      status: string;
      launchDisplay: string;
      display: string;
      goLive: string;
      live: string;
      leaveRoom: string;
      leave: string;
      complete: string;
      translating: string;
      waitingForTranslation: string;
      translationActivityLog: string;
      participantCount: string;
      connectionStatus: string;
      currentActivity: string;
      transcriptCount: string;
      translationWillAppear: string;
    };
    templates: {
      selectTemplate: string;
      systemTemplate: string;
      mosqueTemplate: string;
    };
    validation: {
      roomTitleMin: string;
      roomTitleMax: string;
      spokenLanguageRequired: string;
      translationLanguageRequired: string;
      maxDelayMin: string;
      maxDelayMax: string;
      punctuationMin: string;
      punctuationMax: string;
    };
  };
  languages: {
    ar: string;
    en: string;
    nl: string;
    fr: string;
    de: string;
    es: string;
  };
  auth: {
    bayanPlatform: string;
    adminPanel: string;
    signIn: string;
    signInPrompt: string;
    emailLabel: string;
    emailPlaceholder: string;
    passwordLabel: string;
    passwordPlaceholder: string;
    signingIn: string;
    unexpectedError: string;
  };
  history: {
    title: string;
    description: string;
    loading: string;
    backToDashboard: string;
    signOut: string;
  };
  publicDisplay: {
    connectError: string;
    validationError: string;
    invalidCode: string;
    connectionFailed: string;
    disconnect: string;
    title: string;
    description: string;
    roomCodeLabel: string;
    roomCodePlaceholder: string;
    connecting: string;
    connectButton: string;
    instructions: string;
  };
  sessionHistory: {
    title: string;
    description: string;
    loading: string;
    searchPlaceholder: string;
    filterByRoom: string;
    allRooms: string;
    sortBy: string;
    dateNewest: string;
    duration: string;
    transcriptCount: string;
    completedSessions: string;
    noSessionsFound: string;
    noCompletedSessions: string;
    noMatchingSessions: string;
    table: {
      room: string;
      languages: string;
      started: string;
      duration: string;
      transcripts: string;
      actions: string;
    };
    viewSession: string;
    roomFallback: string;
    languageFrom: string;
    languageTo: string;
    notAvailable: string;
    hours: string;
    minutes: string;
    seconds: string;
  };
  mosqueAdminDashboard: {
    health: string;
    statusTooltip: string;
  };
  impersonation: {
    impersonating: string;
    actionsAsUser: string;
    returnToSuperAdmin: string;
    startedTitle: string;
    startedDescription: string;
    failedTitle: string;
    failedDescription: string;
    endedTitle: string;
    endedDescription: string;
    endFailed: string;
  };
  roomCodeManager: {
    updatedTitle: string;
    enabledDescription: string;
    disabledDescription: string;
    updateFailed: string;
    copiedTitle: string;
    copiedDescription: string;
    codeLabel: string;
  };
  liveMonitor: {
    users: string;
    messages: string;
    transcripts: string;
    status: string;
    setupRequiredTitle: string;
    setupRequiredDescription: string;
    startAudioTitle: string;
    startAudioDescription: string;
    connecting: string;
    startSession: string;
    audioLive: string;
    mic: string;
    endSession: string;
    serverConfigRequired: string;
    serverConfigDescription: string;
    activityTitle: string;
    activityDescription: string;
    waitingForActivity: string;
    startMonitoringPrompt: string;
  };
  quranDisplay: {
    cameraFeed: string;
    waitingForArabic: string;
    demoArabic: string;
    waitingForTranslation: string;
    demoTranslation: string;
  };
  superAdminDashboard: {
    from: string;
    to: string;
    unknownMosque: string;
    noTemplatesDescription: string;
  };
  form: {
    validation: {
      required: string;
      minLength: string;
      maxLength: string;
      selectRequired: string;
      titleRequired: string;
      titleMaxLength: string;
      mosqueNameMin: string;
      mosqueNameMax: string;
      templateNameMin: string;
      maxDelayRange: string;
      punctuationRange: string;
      languageRequired: string;
    };
  };
  technical: {
    livekit: string;
    websocket: string;
    errors: {
      fetchFailed: string;
      createFailed: string;
      updateFailed: string;
      deleteFailed: string;
      connectionError: string;
      authError: string;
      permissionDenied: string;
      notFound: string;
      alreadyExists: string;
      invalidData: string;
      mosqueNotFound: string;
      userNotAuthenticated: string;
      subdomaineExists: string;
      noAuthSession: string;
      livekitRoomFailed: string;
      fetchMosquesFailed: string;
      fetchTemplatesFailed: string;
      fetchUsersFailed: string;
    };
  };
  toast: {
    success: {
      created: string;
      updated: string;
      deleted: string;
      copied: string;
      saved: string;
    };
    error: {
      generic: string;
      network: string;
      validation: string;
      unauthorized: string;
      timeout: string;
    };
    warning: {
      unsavedChanges: string;
      dataLoss: string;
    };
  };
  users: {
    title: string;
    email: string;
    actions: string;
    loginAs: string;
    starting: string;
    loadingUsers: string;
    noUsersFound: string;
    noUsersDescription: string;
    impersonationFailed: string;
    mosqueUsers: string;
  };
  monitoring: {
    status: string;
    active: string;
    inactive: string;
    live: string;
    empty: string;
    pending: string;
    error: string;
    connecting: string;
    connected: string;
    disconnected: string;
    reconnecting: string;
  };
  advanced: {
    title: string;
    show: string;
    hide: string;
    configuration: string;
    template: string;
    custom: string;
    default: string;
    reset: string;
    apply: string;
  };
  settings: {
    profile: string;
    security: string;
    notifications: string;
    system: string;
    publicDisplay: string;
    description: string;
    profileSettings: string;
    profileDescription: string;
    fullName: string;
    emailCannotChange: string;
    profileUpdated: string;
    securitySettings: string;
    securityDescription: string;
    currentPassword: string;
    newPassword: string;
    confirmPassword: string;
    updatePassword: string;
    passwordUpdated: string;
    notificationSettings: string;
    notificationDescription: string;
    emailNotifications: string;
    emailNotificationsDescription: string;
    systemAlerts: string;
    systemAlertsDescription: string;
    systemSettings: string;
    systemDescription: string;
    apiConfiguration: string;
    publicDisplaySettings: string;
    publicDisplayDescription: string;
    inactivityTimeout: string;
    inactivityTimeoutDescription: string;
    seconds: string;
    publicDisplayUpdated: string;
    systemInfo: string;
    version: string;
    environment: string;
    database: string;
    maintenanceMode: string;
    maintenanceModeDescription: string;
    enableMaintenanceMode: string;
    maintenanceModeWarning: string;
    maintenanceMessage: string;
    maintenanceMessagePlaceholder: string;
    systemHealth: string;
    systemHealthDescription: string;
    apiStatus: string;
    databaseStatus: string;
    livekitStatus: string;
    cpuUsage: string;
    memoryUsage: string;
    diskUsage: string;
    runDatabaseMaintenance: string;
    clearCache: string;
  };
  dialogs: {
    confirm: string;
    cancel: string;
    delete: string;
    save: string;
    discard: string;
    areYouSure: string;
    deleteConfirm: string;
    unsavedWarning: string;
    browserWarning: string;
  };
}

export type TranslationKey = keyof TranslationStructure;
export type LanguageCode = 'en' | 'ar' | 'nl';


================================================
FILE: src/lib/translations/utils.ts
================================================
import { TranslationStructure, LanguageCode } from './types';

/**
 * Get a nested translation value from a translation object using dot notation
 * @param obj Translation object
 * @param path Dot-separated path (e.g., "common.loading")
 * @returns Translation string or path if not found
 */
export function getNestedTranslation(obj: TranslationStructure, path: string): string {
  const keys = path.split('.');
  let result: any = obj;
  
  for (const key of keys) {
    if (result && typeof result === 'object' && key in result) {
      result = result[key];
    } else {
      // Return the path if translation not found (development helper)
      if (process.env.NODE_ENV === 'development') {
        }
      return path;
    }
  }
  
  return typeof result === 'string' ? result : path;
}

/**
 * Interpolate variables in translation strings
 * @param template Translation string with placeholders like {name}
 * @param variables Object with replacement values
 * @returns Interpolated string
 */
export function interpolate(template: string, variables: Record<string, string | number>): string {
  return template.replace(/\{(\w+)\}/g, (match, key) => {
    return variables[key]?.toString() || match;
  });
}

/**
 * Check if a language is RTL
 * @param language Language code
 * @returns True if RTL language
 */
export function isRTL(language: LanguageCode): boolean {
  return language === 'ar';
}

/**
 * Get language direction
 * @param language Language code
 * @returns 'rtl' or 'ltr'
 */
export function getDirection(language: LanguageCode): 'rtl' | 'ltr' {
  return isRTL(language) ? 'rtl' : 'ltr';
}

/**
 * Validate translation completeness (development helper)
 * @param baseTranslation Base translation (usually English)
 * @param targetTranslation Target translation to validate
 * @param languageCode Language code being validated
 * @returns Array of missing keys
 */
export function validateTranslationCompleteness(
  baseTranslation: TranslationStructure,
  targetTranslation: Partial<TranslationStructure>,
  languageCode: LanguageCode
): string[] {
  const missingKeys: string[] = [];
  
  function checkNested(base: any, target: any, currentPath: string = '') {
    for (const key in base) {
      const newPath = currentPath ? `${currentPath}.${key}` : key;
      
      if (typeof base[key] === 'object' && base[key] !== null) {
        if (!target[key] || typeof target[key] !== 'object') {
          missingKeys.push(newPath);
        } else {
          checkNested(base[key], target[key], newPath);
        }
      } else {
        if (!target[key]) {
          missingKeys.push(newPath);
        }
      }
    }
  }
  
  checkNested(baseTranslation, targetTranslation);
  
  if (missingKeys.length > 0 && process.env.NODE_ENV === 'development') {
    }
  
  return missingKeys;
}


================================================
FILE: src/pages/Dashboard.tsx
================================================
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { LogOut, Building, Loader2 } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useNavigate, Outlet, useLocation } from 'react-router-dom';
import { Tables } from '@/integrations/supabase/types';
import { useAuth } from '@/hooks/useAuth';
import { useTranslation } from '@/hooks/useTranslation';
import { useLanguage } from '@/contexts/LanguageContext';
import { Sheet, SheetContent } from '@/components/ui/sheet';
import { Card, CardContent } from '@/components/ui/card';
import { StyledH1 } from '@/components/ui/styled-headers';

import MosqueAdminDashboard from '@/features/mosque/components/MosqueAdminDashboard';
import SidebarNav from '@/components/layout/SidebarNav';
import { GlobalHeader } from '@/components/layout/GlobalHeader';
import { getNavItems } from '@/config/navigation';


type UserProfile = Tables<'users'>;

const MosqueIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    viewBox="0 0 361.764 361.764"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <g transform="translate(0, -40)">
      <path
        fill="currentColor"
        d="M317.382,259.764H292.2v-41.668h5.682c6.811,0,12.332-5.521,12.332-12.332c0-6.813-5.521-12.334-12.332-12.334h-4.227 c-5.656-37.826-9.014-74.848-31.598-96.993c-24.167-23.697-55.592-31.428-77.07-50.045c0.601,0.044,1.202,0.078,1.807,0.078 c7.632,0,14.76-3.397,19.555-9.323c1.668-2.062,2.998-4.362,3.953-6.835l0.148-0.385l-0.346,0.224 c-4.035,2.614-8.721,3.996-13.55,3.996c-5.666,0-11.22-1.968-15.637-5.542c-8.395-6.798-11.445-18.139-7.59-28.221L173.474,0 l-0.344,0.224c-2.218,1.44-4.191,3.218-5.863,5.286c-4.226,5.219-6.166,11.771-5.463,18.45c0.703,6.679,3.965,12.684,9.186,16.909 c2.21,1.789,4.703,3.176,7.351,4.125c-21.496,19.641-53.875,27.163-78.638,51.443c-22.586,22.146-25.938,59.167-31.593,96.993 h-4.227c-6.813,0-12.334,5.521-12.334,12.334c0,6.811,5.521,12.332,12.334,12.332h5.68v41.668h-25.18l-18.5,23.111v78.889h309.999 v-78.889L317.382,259.764z M87.943,340.264H63.821v-37.07c0-8.416,12.062-13.93,12.062-13.93s12.06,5.514,12.06,13.93V340.264z M111.26,244.375H94.706v-25.439c0-5.775,8.277-9.561,8.277-9.561s8.276,3.785,8.276,9.561V244.375z M133.656,218.936 c0-5.775,8.277-9.561,8.277-9.561s8.276,3.785,8.276,9.561v25.439h-16.554V218.936z M157.943,340.264h-24.122v-37.07 c0-8.416,12.061-13.93,12.061-13.93s12.061,5.514,12.061,13.93V340.264z M189.157,244.375h-16.552v-25.439 c0-5.775,8.277-9.561,8.277-9.561s8.275,3.785,8.275,9.561V244.375z M227.942,340.264h-24.121v-37.07 c0-8.416,12.061-13.93,12.061-13.93s12.06,5.514,12.06,13.93V340.264z M228.106,244.375h-16.553v-25.439 c0-5.775,8.277-9.561,8.277-9.561s8.275,3.785,8.275,9.561V244.375z M267.055,244.375h-16.553v-25.439 c0-5.775,8.277-9.561,8.277-9.561s8.275,3.785,8.275,9.561V244.375z M297.942,340.264h-24.121v-37.07 c0-8.416,12.06-13.93,12.06-13.93s12.061,5.514,12.061,13.93V340.264z"
      />
    </g>
  </svg>
);

const Dashboard = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();
  const { t } = useTranslation();
  const { isRTL } = useLanguage();
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [mosque, setMosque] = useState<Tables<'Mosque'> | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);


  const fetchUserProfile = async () => {
    if (!user) return;
    
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .maybeSingle();

      if (error) throw error;
      
      if (!data) {
        // User profile doesn't exist - this might be their first login
        setError(t('dashboard.profileNotFound'));
        return;
      }

      setUserProfile(data);
      
      // Fetch mosque data for non-super admins
      if (!data.is_super_admin) {
        const { data: mosqueData, error: mosqueError } = await supabase
          .from('Mosque')
          .select('*')
          .eq('id', data.mosque_id)
          .maybeSingle();
        
        if (mosqueError) {
          } else {
          setMosque(mosqueData);
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : t('auth.unexpectedError'));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (user?.id) {
      fetchUserProfile();
    }
  }, [user?.id]); // Only refetch when user ID changes, not user object

  if (loading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="flex items-center gap-2">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="text-muted-foreground">{t('dashboard.loadingProfile')}</span>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-background">
        <header className="border-b bg-card">
          <div className="container mx-auto px-6 py-4 flex items-center justify-between">
            <div>
              <StyledH1 className="text-foreground">{t('dashboard.title')}</StyledH1>
              <p className="text-muted-foreground">{t('common.error')}</p>
            </div>
            <Button variant="outline" onClick={async () => {
              await supabase.auth.signOut();
              navigate('/auth');
            }}>
              <LogOut className="mr-2 h-4 w-4" />
              {t('common.signOut')}
            </Button>
          </div>
        </header>
        <main className="container mx-auto px-6 py-8">
          <Card>
            <CardContent className="text-center py-8">
              <p className="text-destructive mb-4">{error}</p>
              <Button variant="outline" onClick={fetchUserProfile}>
                {t('common.retry')}
              </Button>
            </CardContent>
          </Card>
        </main>
      </div>
    );
  }

  // Get navigation items from centralized config
  const navItems = getNavItems(userProfile?.is_super_admin || false, t);

  return (
    <div className={`min-h-screen bg-background ${isRTL ? 'rtl' : 'ltr'}`}>
      <div className="flex">
        {/* Desktop Sidebar Navigation */}
        <div className="hidden lg:block">
          <SidebarNav items={navItems} />
        </div>
        
        {/* Mobile Sidebar Navigation */}
        <Sheet open={isMobileMenuOpen} onOpenChange={setIsMobileMenuOpen}>
          <SheetContent side={isRTL ? 'right' : 'left'} className="p-0 w-20">
            <SidebarNav items={navItems} onNavigate={() => setIsMobileMenuOpen(false)} />
          </SheetContent>
        </Sheet>
        
        {/* Main Content Area */}
        <div className="flex-1 min-w-0 bg-background">
          {/* Header */}
          <GlobalHeader
            title={userProfile?.is_super_admin 
              ? t('dashboard.superAdminTitle')
              : `${mosque?.name || t('dashboard.defaultMosqueName')}`
            }
            subtitle={userProfile?.is_super_admin 
              ? t('dashboard.superAdminSubtitle') 
              : t('dashboard.mosqueAdminSubtitle')
            }
            icon={userProfile?.is_super_admin ? <Building className="w-full h-full" /> : <MosqueIcon className="w-full h-full" />}
            onMenuClick={() => setIsMobileMenuOpen(true)}
          />

          {/* Conditional Content */}
          <main className={`px-4 pb-4 sm:px-6 sm:pb-6 lg:pl-24 lg:pr-6 ${
            location.pathname === '/dashboard' || location.pathname === '/dashboard/overview' 
              ? '' 
              : 'lg:pt-[90px]'
          }`}>
            {/* Check if we're at the base dashboard route */}
            {location.pathname === '/dashboard' ? (
              // Show the appropriate dashboard component for base route
              userProfile?.is_super_admin ? (
                // For super admin, redirect to Overview page
                <Outlet context={{ userProfile, mosque }} />
              ) : (
                // For mosque admin, show the legacy dashboard
                userProfile && <MosqueAdminDashboard userProfile={userProfile} />
              )
            ) : (
              // For sub-routes, render the Outlet
              <Outlet context={{ userProfile, mosque }} />
            )}
          </main>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;


================================================
FILE: src/pages/Index.tsx
================================================
import { Button } from '@/components/ui/button';
import { Link } from 'react-router-dom';
import { useTranslation } from '@/hooks/useTranslation';

export default function Index() {
  const { t } = useTranslation();
  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-background">
      <h1 className="text-4xl font-bold mb-4 text-foreground">{t('common.bayanPlatform')}</h1>
      <div className="space-x-4">
        <Link to="/dashboard">
          <Button>{t('common.goToDashboard')}</Button>
        </Link>
      </div>
    </div>
  );
};



================================================
FILE: src/pages/NotFound.tsx
================================================
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    }, [location.pathname]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="text-center">
        <h1 className="text-4xl font-bold mb-4">404</h1>
        <p className="text-xl text-muted-foreground mb-4">Oops! Page not found</p>
        <a href="/" className="text-primary hover:text-primary/80 underline">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;



================================================
FILE: src/pages/PublicSpeechDetail.tsx
================================================
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Separator } from '@/components/ui/separator';
import { 
  ArrowLeft, 
  Clock, 
  MessageSquare, 
  Calendar,
  Download, 
  FileText, 
  Languages,
  Globe,
  Timer,
  RefreshCw,
  Loader2,
  Moon,
  Sun
} from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { Tables } from '@/integrations/supabase/types';
import { format, formatDistanceToNow } from 'date-fns';
import { useTranslation } from '@/hooks/useTranslation';
import { StyledHeader } from '@/components/ui/styled-headers';

type RoomSession = Tables<'room_sessions'>;
type Transcript = Tables<'transcripts'>;
type Room = Tables<'rooms'>;
type Mosque = Tables<'Mosque'>;

interface SessionWithDetails extends RoomSession {
  room: Room;
  mosque: Mosque;
}

const PublicSpeechDetail = () => {
  const { sessionId } = useParams<{ sessionId: string }>();
  const navigate = useNavigate();
  const { toast } = useToast();
  const { t } = useTranslation();
  
  const [session, setSession] = useState<SessionWithDetails | null>(null);
  const [transcripts, setTranscripts] = useState<Transcript[]>([]);
  const [sentences, setSentences] = useState<Array<{
    id: string;
    arabic: string;
    translation: string;
    isComplete: boolean;
    timestamp: string;
  }>>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [exportFormat, setExportFormat] = useState<'transcript' | 'translation' | 'srt' | 'formatted'>('formatted');
  const [totalTranscripts, setTotalTranscripts] = useState(0);
  const [fetchedTranscripts, setFetchedTranscripts] = useState(0);
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    if (!sessionId) {
      navigate('/public/speeches');
      return;
    }
    
    fetchSessionData();
  }, [sessionId]);

  // Check initial theme
  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains('dark'));
  }, []);

  const toggleTheme = () => {
    if (isDarkMode) {
      document.documentElement.classList.remove('dark');
      setIsDarkMode(false);
    } else {
      document.documentElement.classList.add('dark');
      setIsDarkMode(true);
    }
  };

  const fetchAllTranscripts = async (sessionId: string, showProgress: boolean = false): Promise<Transcript[]> => {
    const pageSize = 1000;
    let allTranscripts: Transcript[] = [];
    let from = 0;
    let hasMore = true;
    
    // Get total count
    const { count, error: countError } = await supabase
      .from('transcripts')
      .select('*', { count: 'exact', head: true })
      .eq('session_id', sessionId);
    
    if (countError) {
      console.error('Error getting transcript count:', countError);
      throw countError;
    }
    
    const total = count || 0;
    if (showProgress) {
      setTotalTranscripts(total);
      setFetchedTranscripts(0);
    }
    
    // Fetch all pages
    while (hasMore) {
      const to = from + pageSize - 1;
      
      const { data, error } = await supabase
        .from('transcripts')
        .select('*')
        .eq('session_id', sessionId)
        .order('timestamp', { ascending: true })
        .range(from, to);
      
      if (error) {
        console.error(`Error fetching transcripts range ${from}-${to}:`, error);
        throw error;
      }
      
      if (data && data.length > 0) {
        allTranscripts = [...allTranscripts, ...data];
        if (showProgress) {
          setFetchedTranscripts(allTranscripts.length);
        }
        
        hasMore = data.length === pageSize && allTranscripts.length < total;
        from = to + 1;
      } else {
        hasMore = false;
      }
    }
    
    return allTranscripts;
  };

  const fetchSessionData = async (forceRefresh: boolean = false) => {
    try {
      if (forceRefresh) {
        setRefreshing(true);
      } else {
        setLoading(true);
      }
      
      // Fetch session with room and mosque information
      const { data: sessionData, error: sessionError } = await supabase
        .from('room_sessions')
        .select(`
          *,
          room:rooms (*),
          mosque:Mosque (*)
        `)
        .eq('id', sessionId)
        .single();

      if (sessionError) {
        toast({
          title: "Error",
          description: "Failed to load session data",
          variant: "destructive"
        });
        if (!forceRefresh) {
          navigate('/public/speeches');
        }
        return;
      }

      setSession(sessionData as SessionWithDetails);

      // Fetch ALL transcripts
      try {
        const allTranscripts = await fetchAllTranscripts(sessionId!, forceRefresh);
        setTranscripts(allTranscripts);
        
        // Process transcripts into sentences
        processSentences(allTranscripts);
        
        if (forceRefresh) {
          toast({
            title: "Success",
            description: `Loaded ${allTranscripts.length} transcript entries`,
          });
        }
      } catch (transcriptsError) {
        console.error('Error fetching transcripts:', transcriptsError);
        toast({
          title: "Error",
          description: "Failed to load all session transcripts",
          variant: "destructive"
        });
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "An unexpected error occurred",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };
  
  const handleRefresh = async () => {
    await fetchSessionData(true);
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  };

  const formatDuration = (minutes: number | null) => {
    if (minutes === null || minutes === undefined) return 'N/A';
    
    if (minutes < 1) {
      const seconds = Math.round(minutes * 60);
      return `${seconds} seconds`;
    }
    
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    
    if (hours > 0) {
      return `${hours} hour${hours > 1 ? 's' : ''} ${mins} minute${mins !== 1 ? 's' : ''}`;
    }
    return `${mins} minute${mins !== 1 ? 's' : ''}`;
  };

  const getLanguageDisplayName = (code: string): string => {
    const languageMap: Record<string, string> = {
      'ar': 'Arabic',
      'en': 'English', 
      'nl': 'Dutch',
      'fr': 'French',
      'de': 'German',
      'es': 'Spanish'
    };
    
    return languageMap[code?.toLowerCase()] || code?.toUpperCase() || 'Unknown';
  };

  const isRTLLanguage = (code: string): boolean => {
    const rtlLanguages = ['ar', 'ur', 'fa', 'he'];
    return rtlLanguages.includes(code?.toLowerCase());
  };

  // Process transcripts into sentences
  const processSentences = (transcripts: Transcript[]) => {
    const sentenceGroups = new Map<string, Transcript[]>();
    const orphanTranscripts: Transcript[] = [];
    
    // Group by sentence_id
    transcripts.forEach((transcript) => {
      if (transcript.sentence_id) {
        if (!sentenceGroups.has(transcript.sentence_id)) {
          sentenceGroups.set(transcript.sentence_id, []);
        }
        sentenceGroups.get(transcript.sentence_id)!.push(transcript);
      } else {
        orphanTranscripts.push(transcript);
      }
    });
    
    const processedSentences: Array<{
      id: string;
      arabic: string;
      translation: string;
      isComplete: boolean;
      timestamp: string;
    }> = [];
    
    // Process grouped sentences
    sentenceGroups.forEach((sentenceTranscripts, sentenceId) => {
      sentenceTranscripts.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      
      const completeTranscript = sentenceTranscripts.find(t => t.is_complete === true && t.transcription_segment);
      const translationTranscript = sentenceTranscripts.find(t => t.translation_segment);
      
      let arabicText = '';
      let timestamp = sentenceTranscripts[0].timestamp;
      
      if (completeTranscript) {
        arabicText = completeTranscript.transcription_segment || '';
        timestamp = completeTranscript.timestamp;
      } else {
        arabicText = sentenceTranscripts
          .filter(t => t.transcription_segment)
          .map(t => t.transcription_segment)
          .join(' ')
          .trim();
      }
      
      if (arabicText) {
        processedSentences.push({
          id: sentenceId,
          arabic: arabicText,
          translation: translationTranscript?.translation_segment || '',
          isComplete: completeTranscript?.is_complete || false,
          timestamp: timestamp
        });
      }
    });
    
    // Process orphan transcripts (legacy)
    if (orphanTranscripts.length > 0) {
      orphanTranscripts.forEach((transcript, index) => {
        if (transcript.transcription_segment || transcript.translation_segment) {
          processedSentences.push({
            id: `orphan-${index}`,
            arabic: transcript.transcription_segment || '',
            translation: transcript.translation_segment || '',
            isComplete: false,
            timestamp: transcript.timestamp
          });
        }
      });
    }
    
    // Sort by timestamp
    processedSentences.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
    setSentences(processedSentences);
  };

  const handleExport = () => {
    if (sentences.length === 0) {
      toast({
        title: "No Data",
        description: "No sentences available to export",
        variant: "destructive"
      });
      return;
    }

    let content = '';
    let filename = '';
    let mimeType = 'text/plain';

    const sessionDate = session?.started_at ? format(new Date(session.started_at), 'yyyy-MM-dd') : 'unknown';
    const sessionTitle = session?.public_title || session?.room.Title || 'session';

    switch (exportFormat) {
      case 'transcript':
        content = sentences
          .filter(s => s.arabic)
          .map((s, i) => `${i + 1}. ${s.arabic}`)
          .join('\n\n');
        filename = `transcript_${sessionTitle}_${sessionDate}.txt`;
        break;
        
      case 'translation':
        content = sentences
          .filter(s => s.translation)
          .map((s, i) => `${i + 1}. ${s.translation}`)
          .join('\n\n');
        filename = `translation_${sessionTitle}_${sessionDate}.txt`;
        break;
        
      case 'srt':
        content = sentences
          .filter(s => s.arabic && s.translation)
          .map((s, i) => {
            const startTime = new Date(s.timestamp);
            const endTime = new Date(startTime.getTime() + 5000);
            
            const formatSRTTime = (date: Date) => {
              const hours = String(date.getHours()).padStart(2, '0');
              const minutes = String(date.getMinutes()).padStart(2, '0');
              const seconds = String(date.getSeconds()).padStart(2, '0');
              const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
              return `${hours}:${minutes}:${seconds},${milliseconds}`;
            };

            return `${i + 1}\n${formatSRTTime(startTime)} --> ${formatSRTTime(endTime)}\n${s.arabic}\n${s.translation}\n`;
          })
          .join('\n');
        filename = `subtitles_${sessionTitle}_${sessionDate}.srt`;
        mimeType = 'text/srt';
        break;
        
      case 'formatted':
        const divider = '─'.repeat(80);
        const sessionHeader = [
          divider,
          `SESSION: ${session?.public_title || session?.room.Title}`,
          `MOSQUE: ${session?.mosque.name}`,
          `DATE: ${format(new Date(session.started_at), 'MMMM d, yyyy - h:mm a')}`,
          `DURATION: ${formatDuration(session.duration_minutes)}`,
          `LANGUAGES: ${getLanguageDisplayName(session.room.transcription_language || 'ar')} → ${getLanguageDisplayName(session.room.translation__language || 'en')}`,
          `TOTAL SENTENCES: ${sentences.length}`,
          divider,
          ''
        ].join('\n');
        
        content = sessionHeader + sentences
          .map((s, i) => {
            const sentenceHeader = `[${i + 1}] ${formatTime(s.timestamp)} ${s.isComplete ? '✓' : '○'}`;
            const formattedEntry = [
              sentenceHeader,
              '',
              `${getLanguageDisplayName(session.room.transcription_language || 'ar')}:`,
              s.arabic || '(No transcription)',
              '',
              `${getLanguageDisplayName(session.room.translation__language || 'en')}:`,
              s.translation || '(No translation available)',
              '',
              divider
            ];
            return formattedEntry.join('\n');
          })
          .join('\n\n');
        
        filename = `formatted_transcript_${sessionTitle}_${sessionDate}.txt`;
        break;
    }

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    toast({
      title: "Export Successful",
      description: `Downloaded ${filename}`,
    });
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-background">
        <div className="container mx-auto px-4 py-8">
          <div className="flex items-center justify-center py-16">
            <div className="text-center space-y-4">
              <Loader2 className="h-12 w-12 animate-spin text-primary mx-auto" />
              <p className="text-muted-foreground">{t('publicSpeech.loading')}</p>
              {totalTranscripts > 0 && (
                <p className="text-sm text-muted-foreground">
                  {t('publicSpeech.loadingTranscripts', { fetched: fetchedTranscripts, total: totalTranscripts })}
                </p>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (!session) {
    return (
      <div className="min-h-screen bg-background">
        <div className="container mx-auto px-4 py-8">
          <Card className="max-w-md mx-auto">
            <CardContent className="text-center py-16">
              <MessageSquare className="h-16 w-16 text-muted-foreground/50 mx-auto mb-6" />
              <StyledHeader variant="h3" className="mb-2">{t('publicSpeech.sessionNotFound')}</StyledHeader>
              <p className="text-muted-foreground mb-6">
                {t('publicSpeech.sessionNotFoundDescription')}
              </p>
              <Button onClick={() => navigate('/public/speeches')}>
                <ArrowLeft className="h-4 w-4 mr-2" />
                {t('publicSpeech.backToSpeeches')}
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="container mx-auto px-4 py-8">
        <div className="space-y-6">
          {/* Header */}
          <div className="flex items-center justify-between">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => navigate('/public/speeches')}
              className="text-xs sm:text-sm"
            >
              <ArrowLeft className="h-4 w-4 mr-1 sm:mr-2" />
              <span className="hidden sm:inline">{t('publicSpeech.backToSpeeches')}</span>
              <span className="sm:hidden">{t('publicSpeech.back')}</span>
            </Button>
            
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleRefresh}
                disabled={refreshing}
              >
                {refreshing ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <RefreshCw className="h-4 w-4" />
                )}
              </Button>
              
              <Button
                variant="outline"
                size="icon"
                onClick={toggleTheme}
              >
                {isDarkMode ? (
                  <Sun className="h-4 w-4" />
                ) : (
                  <Moon className="h-4 w-4" />
                )}
              </Button>
            </div>
          </div>

          {/* Compact Session Info & Export Controls */}
          <Card>
            <CardContent className="p-3 sm:p-4">
              {/* Title and Mosque */}
              <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-2 mb-3">
                <div>
                  <StyledHeader variant="h2" className="text-lg sm:text-xl font-semibold">{session.public_title || session.room.Title}</StyledHeader>
                  <p className="text-xs sm:text-sm text-muted-foreground">{session.mosque.name}</p>
                </div>
                <Badge variant="secondary" className="self-start text-xs">
                  {format(new Date(session.started_at), 'MMM dd, yyyy')}
                </Badge>
              </div>

              {/* Stats and Export */}
              <div className="flex flex-col gap-3">
                {/* Compact Stats - Mobile optimized */}
                <div className="grid grid-cols-2 sm:flex sm:flex-wrap gap-2 sm:gap-x-6 sm:gap-y-2 text-xs sm:text-sm">
                  <div className="flex items-center gap-1 sm:gap-2">
                    <Calendar className="h-3 w-3 sm:h-4 sm:w-4 text-muted-foreground" />
                    <span className="font-medium">{format(new Date(session.started_at), 'h:mm a')}</span>
                  </div>
                  
                  <div className="flex items-center gap-1 sm:gap-2">
                    <Clock className="h-3 w-3 sm:h-4 sm:w-4 text-muted-foreground" />
                    <span className="font-medium">{formatDuration(session.duration_minutes)}</span>
                  </div>
                  
                  <div className="flex items-center gap-1 sm:gap-2">
                    <MessageSquare className="h-3 w-3 sm:h-4 sm:w-4 text-muted-foreground" />
                    <span className="font-medium">{session.transcript_count} transcripts</span>
                  </div>
                  
                  <div className="flex items-center gap-1 sm:gap-2 col-span-2 sm:col-span-1">
                    <Languages className="h-3 w-3 sm:h-4 sm:w-4 text-muted-foreground" />
                    <span className="font-medium truncate">
                      {getLanguageDisplayName(session.room.transcription_language || 'ar')} → {getLanguageDisplayName(session.room.translation__language || 'en')}
                    </span>
                  </div>
                </div>

                {/* Export Controls - Mobile optimized */}
                <div className="flex flex-col sm:flex-row gap-2 pt-2 sm:pt-0 border-t sm:border-0">
                  <Select value={exportFormat} onValueChange={(value: any) => setExportFormat(value)}>
                    <SelectTrigger className="w-full sm:w-[160px] h-8 text-xs sm:text-sm">
                      <SelectValue placeholder={t('publicSpeech.exportFormatPlaceholder')} />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="formatted">{t('publicSpeech.exportOptions.formatted')}</SelectItem>
                      <SelectItem value="transcript">{t('publicSpeech.exportOptions.transcript')}</SelectItem>
                      <SelectItem value="translation">{t('publicSpeech.exportOptions.translation')}</SelectItem>
                      <SelectItem value="srt">{t('publicSpeech.exportOptions.srt')}</SelectItem>
                    </SelectContent>
                  </Select>
                  
                  <Button onClick={handleExport} size="sm" className="w-full sm:w-auto h-8 text-xs sm:text-sm">
                    <Download className="h-3 w-3 sm:h-4 sm:w-4 mr-1 sm:mr-2" />
                    {t('common.export')}
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Transcript Display - Fills remaining viewport */}
          <Card className="flex flex-col" style={{ height: 'calc(100vh - 290px)' }}>
            <CardHeader className="shrink-0">
              <StyledHeader variant="h3">{t('publicSpeech.transcriptTitle')}</StyledHeader>
            </CardHeader>
            <CardContent className="flex-1 overflow-hidden p-0">
              <ScrollArea className="h-full px-6">
                <div className="space-y-6">
                  {sentences.length === 0 ? (
                    <div className="text-center py-12 text-muted-foreground">
                      {t('publicSpeech.noTranscriptData')}
                    </div>
                  ) : (
                    sentences.map((sentence, index) => (
                      <div key={sentence.id} className="space-y-3">
                        <div className="flex items-center gap-2 text-sm text-muted-foreground">
                          <Timer className="h-3 w-3" />
                          <span>{formatTime(sentence.timestamp)}</span>
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 md:gap-4">
                          {/* Arabic */}
                          <div className={`${isRTLLanguage(session.room.transcription_language || 'ar') ? 'text-right' : ''}`}>
                            <p className="text-base sm:text-lg leading-relaxed" dir={isRTLLanguage(session.room.transcription_language || 'ar') ? 'rtl' : 'ltr'}>
                              {sentence.arabic || <span className="text-muted-foreground italic">{t('publicSpeech.noTranscription')}</span>}
                            </p>
                          </div>
                          
                          {/* Translation */}
                          <div className={`${isRTLLanguage(session.room.translation__language || 'en') ? 'text-right' : ''} border-t md:border-t-0 pt-3 md:pt-0`}>
                            <p className="text-base sm:text-lg leading-relaxed" dir={isRTLLanguage(session.room.translation__language || 'en') ? 'rtl' : 'ltr'}>
                              {sentence.translation || <span className="text-muted-foreground italic">{t('publicSpeech.noTranslation')}</span>}
                            </p>
                          </div>
                        </div>
                        
                        {index < sentences.length - 1 && <Separator className="mt-6" />}
                      </div>
                    ))
                  )}
                </div>
              </ScrollArea>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default PublicSpeechDetail;


================================================
FILE: src/pages/PublicSpeechList.tsx
================================================
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { CalendarIcon, Eye, Clock, MessageSquare, Search, Filter, Loader2, ArrowRight, Moon, Sun } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { format } from 'date-fns';
import { cn } from '@/lib/utils';
import {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from '@/components/ui/pagination';
import { useTranslation } from '@/hooks/useTranslation';
import { StyledHeader } from '@/components/ui/styled-headers';

type RoomSession = Tables<'room_sessions'> & {
  rooms: {
    Title: string;
    transcription_language: string;
    translation__language: string;
  };
  Mosque: {
    name: string;
  };
};

const PublicSpeechList = () => {
  const [sessions, setSessions] = useState<RoomSession[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState<'date' | 'duration' | 'transcripts'>('date');
  const [currentPage, setCurrentPage] = useState(1);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const itemsPerPage = 20;
  const { t } = useTranslation();

  // Check initial theme
  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains('dark'));
  }, []);

  const toggleTheme = () => {
    if (isDarkMode) {
      document.documentElement.classList.remove('dark');
      setIsDarkMode(false);
    } else {
      document.documentElement.classList.add('dark');
      setIsDarkMode(true);
    }
  };

  const fetchSessions = async () => {
    try {
      setLoading(true);
      
      // Fetch sessions marked as public
      const { data: sessionsData, error: sessionsError } = await supabase
        .from('room_sessions')
        .select(`
          *,
          rooms (
            Title,
            transcription_language,
            translation__language
          ),
          Mosque (
            name
          )
        `)
        .eq('is_public', true)
        .eq('status', 'completed')
        .order('started_at', { ascending: false });

      if (sessionsError) throw sessionsError;

      setSessions(sessionsData || []);
    } catch (err) {
      console.error('Error fetching sessions:', err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchSessions();
  }, []);

  const handleViewSession = (sessionId: string) => {
    window.location.href = `/public/speeches/${sessionId}`;
  };

  const filteredAndSortedSessions = sessions
    .filter(session => {
      const matchesSearch = searchTerm === '' || 
        session.rooms?.Title?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        session.Mosque?.name?.toLowerCase().includes(searchTerm.toLowerCase());
      return matchesSearch;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case 'date':
          return new Date(b.started_at).getTime() - new Date(a.started_at).getTime();
        case 'duration':
          return (b.duration_minutes || 0) - (a.duration_minutes || 0);
        case 'transcripts':
          return b.transcript_count - a.transcript_count;
        default:
          return 0;
      }
    });

  const formatDuration = (minutes: number | null) => {
    if (minutes === null || minutes === undefined) return 'N/A';
    
    if (minutes < 1) {
      const seconds = Math.round(minutes * 60);
      return `${seconds} seconds`;
    }
    
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    
    if (hours > 0) {
      return `${hours}h ${mins}m`;
    }
    return `${mins}m`;
  };

  const getLanguageDisplay = (lang: string) => {
    const languages: Record<string, string> = {
      'ar': 'Arabic',
      'nl': 'Dutch',
      'en': 'English',
      'fr': 'French',
      'de': 'German',
      'es': 'Spanish'
    };
    return languages[lang] || lang;
  };

  const getLanguageFlag = (lang: string) => {
    const flags: Record<string, string> = {
      'ar': '🇸🇦',
      'nl': '🇳🇱',
      'en': '🇬🇧',
      'fr': '🇫🇷',
      'de': '🇩🇪',
      'es': '🇪🇸'
    };
    return flags[lang] || '🌐';
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-background">
        <div className="container mx-auto px-4 py-8">
          <div className="flex items-center justify-center py-16">
            <div className="text-center space-y-4">
              <Loader2 className="h-12 w-12 animate-spin text-primary mx-auto" />
              <p className="text-muted-foreground">{t('publicSpeechList.loadingSpeeches')}</p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  const totalItems = filteredAndSortedSessions.length;
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const paginatedSessions = filteredAndSortedSessions.slice(startIndex, endIndex);
  
  const getPageNumbers = () => {
    const pages = [];
    const maxButtons = 5;
    
    if (totalPages <= maxButtons) {
      for (let i = 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      if (currentPage <= 3) {
        for (let i = 1; i <= 4; i++) {
          pages.push(i);
        }
        pages.push('ellipsis');
        pages.push(totalPages);
      } else if (currentPage >= totalPages - 2) {
        pages.push(1);
        pages.push('ellipsis');
        for (let i = totalPages - 3; i <= totalPages; i++) {
          pages.push(i);
        }
      } else {
        pages.push(1);
        pages.push('ellipsis');
        for (let i = currentPage - 1; i <= currentPage + 1; i++) {
          pages.push(i);
        }
        pages.push('ellipsis');
        pages.push(totalPages);
      }
    }
    
    return pages;
  };

  return (
    <div className="min-h-screen bg-background">
      <div className="container mx-auto px-4 py-8">
        <div className="space-y-8">
          {/* Header */}
          <div className="flex justify-between items-start">
            <div>
              <StyledHeader variant="h1">{t('publicSpeechList.title')}</StyledHeader>
              <p className="text-muted-foreground mt-2">{t('publicSpeechList.description')}</p>
            </div>
            <Button
              variant="outline"
              size="icon"
              onClick={toggleTheme}
              className="ml-4"
            >
              {isDarkMode ? (
                <Sun className="h-5 w-5" />
              ) : (
                <Moon className="h-5 w-5" />
              )}
            </Button>
          </div>

          {/* Filters */}
          <div className="space-y-4">
            <div className="flex flex-col lg:flex-row gap-4">
              <div className="relative flex-1">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder={t('publicSpeechList.searchPlaceholder')}
                  value={searchTerm}
                  onChange={(e) => {
                    setSearchTerm(e.target.value);
                    setCurrentPage(1);
                  }}
                  className="pl-10 h-11"
                />
              </div>

              <Select value={sortBy} onValueChange={(value: any) => {
                setSortBy(value);
                setCurrentPage(1);
              }}>
                <SelectTrigger className="w-full lg:w-[200px] h-11">
                  <SelectValue placeholder={t('publicSpeechList.sortByPlaceholder')} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="date">{t('publicSpeechList.sortOptions.date')}</SelectItem>
                  <SelectItem value="duration">{t('publicSpeechList.sortOptions.duration')}</SelectItem>
                  <SelectItem value="transcripts">{t('publicSpeechList.sortOptions.transcripts')}</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Sessions Grid */}
          {filteredAndSortedSessions.length === 0 ? (
            <Card>
              <CardContent className="text-center py-16">
                <MessageSquare className="h-16 w-16 text-muted-foreground/50 mx-auto mb-6" />
                <StyledHeader variant="h3" className="mb-2">{t('publicSpeechList.noSpeechesFound')}</StyledHeader>
                <p className="text-muted-foreground max-w-md mx-auto">
                  {sessions.length === 0 
                    ? t('publicSpeechList.noSpeechesAvailable')
                    : t('publicSpeechList.noMatch')
                  }
                </p>
              </CardContent>
            </Card>
          ) : (
            <div className="space-y-6">
              <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
                {paginatedSessions.map((session) => (
                  <Card 
                    key={session.id} 
                    className="group hover:shadow-lg hover:border-primary/50 hover:-translate-y-1 transition-all duration-200 cursor-pointer"
                  >
                    <CardHeader className="space-y-3">
                      <div className="flex items-start justify-between">
                        <div className="space-y-1">
                          <StyledHeader variant="h4" className="text-lg font-semibold line-clamp-1">
                            {session.public_title || session.rooms?.Title || `Room ${session.room_id}`}
                          </StyledHeader>
                          <CardDescription className="text-sm">
                            {session.Mosque?.name || 'Unknown Mosque'}
                          </CardDescription>
                        </div>
                        <Badge variant="secondary" className="text-xs">
                          {format(new Date(session.started_at), 'MMM dd')}
                        </Badge>
                      </div>
                      
                      {/* Language Badge */}
                      <div className="flex items-center gap-2">
                        <div className="flex items-center gap-1.5 text-sm">
                          <span className="text-lg">{getLanguageFlag(session.rooms?.transcription_language || 'ar')}</span>
                          <span className="text-muted-foreground">{getLanguageDisplay(session.rooms?.transcription_language || 'ar')}</span>
                        </div>
                        <ArrowRight className="h-3.5 w-3.5 text-muted-foreground" />
                        <div className="flex items-center gap-1.5 text-sm">
                          <span className="text-lg">{getLanguageFlag(session.rooms?.translation__language || 'en')}</span>
                          <span className="text-muted-foreground">{getLanguageDisplay(session.rooms?.translation__language || 'en')}</span>
                        </div>
                      </div>
                    </CardHeader>
                    
                    <CardContent className="space-y-4">
                      {/* Stats Grid */}
                      <div className="grid grid-cols-3 gap-4 py-3">
                        <div className="text-center space-y-1">
                          <div className="flex items-center justify-center text-muted-foreground">
                            <CalendarIcon className="h-4 w-4" />
                          </div>
                          <p className="text-sm font-medium">{format(new Date(session.started_at), 'HH:mm')}</p>
                          <p className="text-xs text-muted-foreground">{t('publicSpeechList.started')}</p>
                        </div>
                        
                        <div className="text-center space-y-1 border-x border-border/30">
                          <div className="flex items-center justify-center text-muted-foreground">
                            <Clock className="h-4 w-4" />
                          </div>
                          <p className="text-sm font-medium">{formatDuration(session.duration_minutes)}</p>
                          <p className="text-xs text-muted-foreground">{t('publicSpeechList.duration')}</p>
                        </div>
                        
                        <div className="text-center space-y-1">
                          <div className="flex items-center justify-center text-muted-foreground">
                            <MessageSquare className="h-4 w-4" />
                          </div>
                          <p className="text-sm font-medium">{session.transcript_count}</p>
                          <p className="text-xs text-muted-foreground">{t('publicSpeechList.transcripts')}</p>
                        </div>
                      </div>
                      
                      {/* View Button */}
                      <Button
                        variant="outline"
                        className="w-full border-border/50 transition-all duration-200 hover:bg-primary hover:text-primary-foreground hover:border-primary hover:shadow-md group-hover:bg-primary group-hover:text-primary-foreground group-hover:border-primary group-hover:shadow-md"
                        onClick={() => handleViewSession(session.id)}
                      >
                        <Eye className="h-4 w-4 mr-2" />
                        {t('publicSpeechList.viewSpeech')}
                      </Button>
                    </CardContent>
                  </Card>
                ))}
              </div>
              
              {/* Pagination */}
              {totalPages > 1 && (
                <Pagination className="mt-8">
                  <PaginationContent>
                    <PaginationItem>
                      <PaginationPrevious 
                        onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                        className={cn(
                          "cursor-pointer",
                          currentPage === 1 && "pointer-events-none opacity-50"
                        )}
                      />
                    </PaginationItem>
                    
                    {getPageNumbers().map((page, index) => (
                      <PaginationItem key={index}>
                        {page === 'ellipsis' ? (
                          <PaginationEllipsis />
                        ) : (
                          <PaginationLink
                            onClick={() => setCurrentPage(page as number)}
                            isActive={currentPage === page}
                            className="cursor-pointer"
                          >
                            {page}
                          </PaginationLink>
                        )}
                      </PaginationItem>
                    ))}
                    
                    <PaginationItem>
                      <PaginationNext 
                        onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                        className={cn(
                          "cursor-pointer",
                          currentPage === totalPages && "pointer-events-none opacity-50"
                        )}
                      />
                    </PaginationItem>
                  </PaginationContent>
                </Pagination>
              )}
              
              {/* Results info */}
              <div className="text-center text-sm text-muted-foreground">
                {t('publicSpeechList.showingResults', { start: startIndex + 1, end: Math.min(endIndex, totalItems), total: totalItems })}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default PublicSpeechList;


================================================
FILE: src/pages/TestLanguageSelector.tsx
================================================
import { useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { LanguageSelector } from '@/components/ui/language-selector';
import { getLanguageByCode } from '@/config/languages';
import { Badge } from '@/components/ui/badge';

export default function TestLanguageSelector() {
  const [transcriptionLang, setTranscriptionLang] = useState<string>('ar');
  const [translationLang, setTranslationLang] = useState<string>('en');
  
  const transcriptionLanguage = getLanguageByCode(transcriptionLang);
  const translationLanguage = getLanguageByCode(translationLang);

  return (
    <div className="container mx-auto p-8 max-w-4xl">
      <h1 className="text-3xl font-bold mb-8">Speechmatics Language Selector Demo</h1>
      
      <div className="grid gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Room Language Configuration</CardTitle>
            <CardDescription>
              Configure the spoken language and translation target for your mosque room
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="grid md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <label className="text-sm font-medium">Spoken Language (Source)</label>
                <LanguageSelector
                  value={transcriptionLang}
                  onChange={setTranscriptionLang}
                  placeholder="Select source language..."
                />
                {transcriptionLanguage && (
                  <div className="text-sm text-muted-foreground mt-2">
                    Selected: <span className="font-medium">{transcriptionLanguage.name}</span>
                    {transcriptionLanguage.rtl && (
                      <Badge variant="outline" className="ml-2">RTL</Badge>
                    )}
                  </div>
                )}
              </div>
              
              <div className="space-y-2">
                <label className="text-sm font-medium">Translation Language (Target)</label>
                <LanguageSelector
                  value={translationLang}
                  onChange={setTranslationLang}
                  placeholder="Select target language..."
                />
                {translationLanguage && (
                  <div className="text-sm text-muted-foreground mt-2">
                    Selected: <span className="font-medium">{translationLanguage.name}</span>
                    {translationLanguage.rtl && (
                      <Badge variant="outline" className="ml-2">RTL</Badge>
                    )}
                  </div>
                )}
              </div>
            </div>
            
            <div className="border-t pt-4">
              <h3 className="font-medium mb-2">Configuration Summary</h3>
              <div className="bg-muted rounded-lg p-4 space-y-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm">Source:</span>
                  {transcriptionLanguage && (
                    <>
                      <span className="text-lg">{transcriptionLanguage.flag}</span>
                      <span className="font-medium">{transcriptionLanguage.name}</span>
                      <code className="text-xs bg-background px-2 py-1 rounded">
                        {transcriptionLanguage.code}
                      </code>
                    </>
                  )}
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-sm">Target:</span>
                  {translationLanguage && (
                    <>
                      <span className="text-lg">{translationLanguage.flag}</span>
                      <span className="font-medium">{translationLanguage.name}</span>
                      <code className="text-xs bg-background px-2 py-1 rounded">
                        {translationLanguage.code}
                      </code>
                    </>
                  )}
                </div>
              </div>
            </div>
            
            <div className="text-sm text-muted-foreground">
              <p>✨ Features:</p>
              <ul className="list-disc list-inside mt-1 space-y-1">
                <li>50+ Speechmatics-supported languages</li>
                <li>Search functionality for quick language lookup</li>
                <li>Common languages section for frequently used options</li>
                <li>Native language names with flags</li>
                <li>RTL language indicators</li>
                <li>Auto-detect option for automatic language identification</li>
              </ul>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}


================================================
FILE: src/pages/dashboard/ConversationMonitor.tsx
================================================
import React, { useState, useEffect, useCallback } from 'react';
import { useSearchParams } from 'react-router-dom';
import { supabase } from '@/integrations/supabase/client';
import { BaseConversationView } from '@/features/conversation/components/BaseConversationView';
import { ConversationRoomSelector } from '@/features/conversation/components/ConversationRoomSelector';
import { ConversationHeader } from '@/features/conversation/components/ConversationHeader';
import { Tables } from '@/integrations/supabase/types';
import { toast } from 'sonner';
import { useAuth } from '@/hooks/useAuth';
import { ConversationThemeContext, ConversationTheme, getConversationColors } from '@/features/conversation/utils/conversationTheme';

type Room = Tables<'rooms'>;
type UserProfile = Tables<'users'>;

export function ConversationMonitor() {
  const [searchParams, setSearchParams] = useSearchParams();
  const roomId = searchParams.get('roomId');
  const primaryRoomId = searchParams.get('primaryRoomId');
  const secondaryRoomId = searchParams.get('secondaryRoomId');
  const role = searchParams.get('role') || 'primary';
  const { user } = useAuth();
  const [room, setRoom] = useState<Room | null>(null);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);
  const [showRoomSelector, setShowRoomSelector] = useState(!roomId);
  const [mosqueName, setMosqueName] = useState<string>('');
  
  // Theme state management
  const [theme, setTheme] = useState<ConversationTheme>(() => {
    // Check localStorage for saved theme preference
    const savedTheme = localStorage.getItem('conversationTheme');
    return (savedTheme === 'dark' || savedTheme === 'light') ? savedTheme : 'light';
  });
  
  const toggleTheme = useCallback(() => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
    localStorage.setItem('conversationTheme', newTheme);
  }, [theme]);
  
  const colors = getConversationColors(theme);

  // Determine the opponent's room ID based on current role
  const opponentRoomId = role === 'primary' ? secondaryRoomId : primaryRoomId;

  useEffect(() => {
    if (user) {
      fetchUserProfile();
    }
  }, [user]);

  useEffect(() => {
    if (roomId && userProfile) {
      fetchRoom();
    }
  }, [roomId, userProfile]);

  const fetchUserProfile = async () => {
    if (!user) return;
    
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .single();

      if (error) throw error;
      setUserProfile(data);
    } catch (error) {
      console.error('Error fetching user profile:', error);
      toast.error('Failed to load user profile');
    }
  };

  const fetchRoom = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('rooms')
        .select('*, Mosque(name)')
        .eq('id', roomId)
        .single();

      if (error) throw error;
      setRoom(data);
      
      // Get mosque name
      if (data.Mosque) {
        setMosqueName(data.Mosque.name);
      }
    } catch (error) {
      console.error('Error fetching room:', error);
      toast.error('Failed to load room');
    } finally {
      setLoading(false);
    }
  };

  const handleRoomSelected = (primaryRoomId: string, secondaryRoomId: string) => {
    // Set the appropriate room ID based on role
    const selectedRoomId = role === 'primary' ? primaryRoomId : secondaryRoomId;
    
    // Update URL with all room IDs for cross-room listening
    setSearchParams({
      roomId: selectedRoomId,
      primaryRoomId: primaryRoomId,
      secondaryRoomId: secondaryRoomId,
      role: role
    });
    
    // Hide selector and let the component reload with the new room ID
    setShowRoomSelector(false);
  };

  const handleLeaveRoom = () => {
    // Clear the room ID from URL and show selector again
    setSearchParams({
      role: role
    });
    setShowRoomSelector(true);
    setRoom(null);
  };

  // Show room selector if no room is selected
  if (showRoomSelector || !roomId) {
    return (
      <ConversationThemeContext.Provider value={{ theme, colors, toggleTheme }}>
        <div className="h-screen flex flex-col overflow-hidden" style={{ backgroundColor: colors.background }}>
          <ConversationHeader 
            roomTitle="Select a Room"
            role={role as 'primary' | 'secondary'}
            mosqueName={mosqueName || undefined}
          />
          <div className="flex-1 overflow-hidden">
            <ConversationRoomSelector
              role={role as 'primary' | 'secondary'}
              onRoomSelected={handleRoomSelected}
            />
          </div>
        </div>
      </ConversationThemeContext.Provider>
    );
  }

  if (loading) {
    return (
      <ConversationThemeContext.Provider value={{ theme, colors, toggleTheme }}>
        <div className="flex items-center justify-center min-h-screen" style={{ backgroundColor: colors.background }}>
          <div className="animate-pulse text-lg" style={{ color: colors.text }}>
            Loading room...
          </div>
        </div>
      </ConversationThemeContext.Provider>
    );
  }

  if (!room) {
    return (
      <ConversationThemeContext.Provider value={{ theme, colors, toggleTheme }}>
        <div className="flex items-center justify-center min-h-screen" style={{ backgroundColor: colors.background }}>
          <div className="text-lg" style={{ color: colors.error }}>
            Room not found
          </div>
        </div>
      </ConversationThemeContext.Provider>
    );
  }

  return (
    <ConversationThemeContext.Provider value={{ theme, colors, toggleTheme }}>
      <div className="h-screen flex flex-col overflow-hidden" style={{ backgroundColor: colors.background }}>
        <ConversationHeader 
          roomTitle={room.Title}
          role={role as 'primary' | 'secondary'}
          mosqueName={mosqueName || undefined}
          transcriptionLanguage={room.transcription_language}
          translationLanguage={room.translation__language}
        />
        <div className="flex-1 overflow-hidden">
          <BaseConversationView 
            room={room} 
            mosque_id={room.mosque_id}
            role={role as 'primary' | 'secondary'}
            opponentRoomId={opponentRoomId ? parseInt(opponentRoomId) : undefined}
          />
        </div>
      </div>
    </ConversationThemeContext.Provider>
  );
}


================================================
FILE: src/pages/dashboard/ConversationPage.tsx
================================================
import React, { useEffect } from 'react';
import { useTranslation } from '@/hooks/useTranslation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { StyledH1, StyledHeader } from '@/components/ui/styled-headers';
import { toast } from 'sonner';
import { ExternalLink, Info, Mic, MicOff } from 'lucide-react';

export function ConversationPage() {
  const { t } = useTranslation();
  
  const openConversationWindows = () => {
    // Try to open both windows simultaneously without room IDs
    const primaryWindow = window.open(
      `/dashboard/conversation/monitor?role=primary`,
      `conversation_primary`,
      'width=960,height=800,left=0,top=0'
    );
    
    const secondaryWindow = window.open(
      `/dashboard/conversation/monitor?role=secondary`,
      `conversation_secondary`,
      'width=960,height=800,left=960,top=0'
    );
    
    // Check results
    if (primaryWindow && secondaryWindow) {
      toast.success('Opened conversation windows. Select rooms in the primary window to begin.');
    } else if (primaryWindow && !secondaryWindow) {
      toast.warning('Only primary window opened. Your browser may be blocking multiple popups. Please allow popups for this site and try again.');
    } else if (!primaryWindow && secondaryWindow) {
      toast.warning('Only secondary window opened. Your browser may be blocking multiple popups.');
    } else {
      toast.error('Could not open windows. Please allow popups for this site in your browser settings and try again.');
    }
  };

  const openPrimaryWindow = () => {
    const primaryWindow = window.open(
      `/dashboard/conversation/monitor?role=primary`,
      `conversation_primary`,
      'width=960,height=800,left=0,top=0'
    );
    
    if (primaryWindow) {
      toast.success('Opened primary conversation window. You can control this from another device.');
    } else {
      toast.error('Could not open primary window. Please allow popups for this site.');
    }
  };

  const openSecondaryWindow = () => {
    const secondaryWindow = window.open(
      `/dashboard/conversation/monitor?role=secondary`,
      `conversation_secondary`,
      'width=960,height=800,left=960,top=0'
    );
    
    if (secondaryWindow) {
      toast.success('Opened secondary conversation window. You can control this from another device.');
    } else {
      toast.error('Could not open secondary window. Please allow popups for this site.');
    }
  };
  
  // Removed auto-open to prevent interference with multi-device usage
  // Users should manually choose which windows to open

  return (
    <div className="space-y-6">
      <div>
        <StyledH1 className="text-foreground">{t('conversation.title')}</StyledH1>
        <p className="text-muted-foreground mt-2">
          {t('conversation.description')}
        </p>
      </div>

      <Card>
        <CardHeader>
          <StyledHeader variant="h2">{t('conversation.controlCenterTitle')}</StyledHeader>
          <CardDescription>
            {t('conversation.controlCenterDescription')}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="bg-muted/50 rounded-lg p-6 space-y-4">
            <div className="flex items-start gap-3">
              <Info className="h-5 w-5 text-muted-foreground mt-0.5" />
              <div className="space-y-2 text-sm text-muted-foreground">
                <p>
                  <strong>{t('conversation.howToUseTitle')}</strong>
                </p>
                <ol className="list-decimal list-inside space-y-1 ml-2">
                  <li>{t('conversation.step1')}</li>
                  <li>{t('conversation.step2')}</li>
                  <li>{t('conversation.step3')}</li>
                  <li>{t('conversation.step4')}</li>
                  <li>{t('conversation.step5')}</li>
                  <li>{t('conversation.step6')}</li>
                </ol>
              </div>
            </div>
          </div>

          <div className="space-y-6">
            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <Button
                variant="outline"
                size="lg"
                onClick={openConversationWindows}
                className="flex items-center gap-2"
              >
                <ExternalLink className="h-4 w-4" />
                {t('conversation.openBothWindows')}
              </Button>
            </div>

            <div className="border-t pt-6">
              <StyledHeader variant="h3" className="mb-2 text-center">{t('conversation.manualControlTitle')}</StyledHeader>
              <p className="text-sm text-muted-foreground text-center mb-4">
                {t('conversation.manualControlDescription')}
              </p>
              <div className="flex flex-col sm:flex-row gap-4 justify-center">
                <Button
                  variant="default"
                  size="lg"
                  onClick={openPrimaryWindow}
                  className="flex items-center gap-2"
                >
                  <Mic className="h-4 w-4" />
                  {t('conversation.openPrimaryOnly')}
                </Button>
                <Button
                  variant="secondary"
                  size="lg"
                  onClick={openSecondaryWindow}
                  className="flex items-center gap-2"
                >
                  <MicOff className="h-4 w-4" />
                  {t('conversation.openSecondaryOnly')}
                </Button>
              </div>
              <p className="text-xs text-center text-muted-foreground mt-4">
                <strong>{t('conversation.tipTitle')}:</strong> {t('conversation.tipDescription')}
              </p>
            </div>
          </div>

          <div className="border-t pt-4">
            <p className="text-xs text-center text-muted-foreground">
              <strong>{t('conversation.noteTitle')}:</strong> {t('conversation.noteDescription')}
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


================================================
FILE: src/pages/dashboard/RemoteControlPage.tsx
================================================
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { StyledH1 } from '@/components/ui/styled-headers';
import { Radio, Wifi, WifiOff, RefreshCw, Square, Mic, MicOff } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useTranslation } from '@/hooks/useTranslation';

interface MonitoringSession {
  sessionId: string;
  roomId: number;
  roomName: string;
  timestamp: number;
  isLive?: boolean;
  isMuted?: boolean;
}

export function RemoteControlPage() {
  const [monitoringSessions, setMonitoringSessions] = useState<MonitoringSession[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const { t } = useTranslation();

  useEffect(() => {
    // Subscribe to broadcast channel for monitoring sessions
    const channel = supabase.channel('live-monitor-status');
    
    // Listen for monitoring updates
    channel
      .on('broadcast', { event: 'monitor-opened' }, (payload) => {
        const session = payload.payload as MonitoringSession;
        setMonitoringSessions(prev => {
          // Remove old session from same room if exists
          const filtered = prev.filter(s => s.roomId !== session.roomId);
          return [...filtered, session];
        });
      })
      .on('broadcast', { event: 'monitor-closed' }, (payload) => {
        const { roomId } = payload.payload;
        setMonitoringSessions(prev => prev.filter(s => s.roomId !== roomId));
      })
      .subscribe((status) => {
        setIsConnected(status === 'SUBSCRIBED');
        
        // When connected, request status from all open monitors
        if (status === 'SUBSCRIBED') {
          const requestChannel = supabase.channel('live-monitor-requests');
          requestChannel.send({
            type: 'broadcast',
            event: 'request-status',
            payload: { timestamp: Date.now() }
          });
        }
      });

    // Cleanup old sessions (older than 90 seconds to account for 30-second broadcast interval)
    const interval = setInterval(() => {
      const now = Date.now();
      setMonitoringSessions(prev => 
        prev.filter(s => now - s.timestamp < 90000)
      );
    }, 10000);

    return () => {
      channel.unsubscribe();
      clearInterval(interval);
    };
  }, []);

  const handleRefresh = async () => {
    setIsRefreshing(true);
    // Request status from all open monitors
    const requestChannel = supabase.channel('live-monitor-requests');
    await requestChannel.send({
      type: 'broadcast',
      event: 'request-status',
      payload: { timestamp: Date.now() }
    });
    // Wait a bit for responses
    setTimeout(() => setIsRefreshing(false), 1000);
  };

  const handleGoLive = async (session: MonitoringSession) => {
    // Send go-live command to specific monitor
    await supabase
      .channel('live-monitor-commands')
      .send({
        type: 'broadcast',
        event: 'go-live',
        payload: {
          sessionId: session.sessionId,
          roomId: session.roomId,
          timestamp: Date.now()
        }
      });
  };

  const handleStop = async (session: MonitoringSession) => {
    // Send stop command to specific monitor
    await supabase
      .channel('live-monitor-commands')
      .send({
        type: 'broadcast',
        event: 'stop-monitoring',
        payload: {
          sessionId: session.sessionId,
          roomId: session.roomId,
          timestamp: Date.now()
        }
      });
  };

  const handleToggleMic = async (session: MonitoringSession) => {
    // Send mic toggle command to specific monitor
    await supabase
      .channel('live-monitor-commands')
      .send({
        type: 'broadcast',
        event: 'toggle-mic',
        payload: {
          sessionId: session.sessionId,
          roomId: session.roomId,
          timestamp: Date.now()
        }
      });
  };

  return (
    <div className="space-y-6">
      <div>
        <StyledH1 className="text-foreground">{t('remoteControl.title')}</StyledH1>
        <p className="text-muted-foreground mt-2">
          {t('remoteControl.description')}
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>{t('remoteControl.activeSessions')}</span>
            <div className="flex items-center gap-4">
              <Button
                onClick={handleRefresh}
                disabled={isRefreshing}
                variant="outline"
                size="sm"
                className="flex items-center gap-2"
              >
                <RefreshCw className={`h-4 w-4 ${isRefreshing ? 'animate-spin' : ''}`} />
                {t('common.refresh')}
              </Button>
              <div className="flex items-center gap-2">
                {isConnected ? (
                  <>
                    <Wifi className="h-4 w-4 text-green-500" />
                    <span className="text-sm text-green-600">{t('remoteControl.connected')}</span>
                  </>
                ) : (
                  <>
                    <WifiOff className="h-4 w-4 text-gray-400" />
                    <span className="text-sm text-gray-500">{t('remoteControl.connecting')}</span>
                  </>
                )}
              </div>
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {monitoringSessions.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              {t('remoteControl.noActiveSessions')}
            </div>
          ) : (
            <div className="space-y-3">
              {monitoringSessions.map((session) => (
                <div
                  key={session.sessionId}
                  className="flex items-center justify-between p-4 border rounded-lg"
                >
                  <div className="flex items-center gap-3">
                    <Radio className="h-5 w-5 text-muted-foreground" />
                    <div>
                      <p className="font-medium">{t('remoteControl.roomIsOpen', { roomName: session.roomName })}</p>
                      <p className="text-sm text-muted-foreground">
                        {t('remoteControl.session')}: {session.sessionId.slice(0, 8)}...
                      </p>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      onClick={() => handleGoLive(session)}
                      className="bg-green-600 hover:bg-green-700"
                    >
                      {t('remoteControl.goLive')}
                    </Button>
                    <Button
                      onClick={() => handleToggleMic(session)}
                      variant="outline"
                      size="icon"
                      title={t('remoteControl.toggleMic')}
                    >
                      <Mic className="h-4 w-4" />
                    </Button>
                    <Button
                      onClick={() => handleStop(session)}
                      variant="destructive"
                      size="default"
                    >
                      <Square className="h-4 w-4 mr-1" />
                      {t('remoteControl.end')}
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}


================================================
FILE: src/utils/constants.ts
================================================
// Default form values
export const DEFAULT_FORM_VALUES = {
  title: '',
  transcription_language: 'ar',
  translation_language: 'nl',
  max_delay: 3.5,
  punctuation_sensitivity: 0.5,
  context_window_size: 12,
  prompt_template_id: undefined,
  speechmatics_domain: 'broadcast',
} as const;

// Language options
export const LANGUAGE_OPTIONS = {
  transcription: ['ar', 'en', 'nl', 'fr', 'es'],
  translation: ['nl', 'en', 'ar', 'fr', 'es'],
} as const;

// Status badge styles
export const STATUS_STYLES = {
  active: {
    badge: 'bg-success/10 text-success hover:bg-success/20',
    dot: 'bg-success',
  },
  empty: {
    badge: 'bg-info/10 text-info hover:bg-info/20',
    dot: 'bg-info',
  },
  pending: {
    badge: 'bg-muted/50 text-muted-foreground hover:bg-muted',
    dot: 'bg-muted-foreground',
  },
} as const;

// Slider configurations
export const SLIDER_CONFIG = {
  maxDelay: {
    min: 1,
    max: 5,
    step: 0.1,
  },
  punctuationSensitivity: {
    min: 0,
    max: 1,
    step: 0.1,
  },
  contextWindowSize: {
    min: 3,
    max: 20,
    step: 1,
  },
} as const;

// Speechmatics domain options
export const SPEECHMATICS_DOMAIN_OPTIONS = [
  { value: 'broadcast', label: 'Sermon/Lecture (Formal Speech)' },
  { value: 'conversational', label: 'Discussion/Q&A (Informal)' },
  { value: 'general', label: 'General/Mixed Content' },
] as const;

// WebSocket URLs
export const WEBSOCKET_URL = 'wss://bpsahvbdlkzemwjdgxmq.functions.supabase.co/functions/v1/websocket-bridge';

// Storage keys
export const STORAGE_KEYS = {
  activeTab: 'mosque-dashboard-active-tab',
  monitoringRoom: 'mosque-dashboard-monitoring-room',
} as const;

// Tab values
export const TABS = {
  management: 'management',
  monitor: 'monitor',
} as const;

// Default values
export const DEFAULTS = {
  maxRoomId: 1000000,
  roomStatus: 'pending',
} as const;


================================================
FILE: src/utils/livekitAdmin.ts
================================================
import { RoomServiceClient } from 'livekit-server-sdk';

// Create a LiveKit room using the admin API
export async function createLiveKitRoom(
  roomName: string,
  apiKey: string,
  apiSecret: string,
  url: string
): Promise<void> {
  try {
    // Extract host from WebSocket URL
    const host = url.replace('wss://', 'https://').replace('ws://', 'http://');
    
    // Create room service client
    const roomService = new RoomServiceClient(host, apiKey, apiSecret);
    
    // Create the room
    await roomService.createRoom({
      name: roomName,
      emptyTimeout: 300, // 5 minutes
      maxParticipants: 50
    });
    
    } catch (error) {
    // If room already exists, that's okay
    if (error instanceof Error && error.message.includes('already exists')) {
      } else {
      throw error;
    }
  }
} 


================================================
FILE: src/utils/roomHelpers.ts
================================================
import { Tables } from '@/integrations/supabase/types';

type Room = Tables<'rooms'>;

/**
 * Sanitizes a title for use in LiveKit room names
 */
export const sanitizeTitle = (title: string): string => {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
};

/**
 * Generates a hierarchical LiveKit room name for multi-tenancy
 */
export const generateLivekitRoomName = (mosqueId: number, title: string): string => {
  const sanitizedTitle = sanitizeTitle(title);
  return `mosque_${mosqueId}_${sanitizedTitle}`;
};

/**
 * Generates a random room ID
 */
export const generateRoomId = (max: number = 1000000): number => {
  return Math.floor(Math.random() * max);
};

/**
 * Gets the status style configuration for a room
 */
export const getStatusStyle = (status: string | null) => {
  switch (status) {
    case 'active':
      return {
        badge: 'bg-red-500/10 text-red-600 hover:bg-red-500/20 animate-pulse-subtle',
        dot: 'bg-red-500 animate-pulse-glow',
      };
    case 'empty':
      return {
        badge: 'bg-info/10 text-info hover:bg-info/20',
        dot: 'bg-info',
      };
    case 'pending':
    default:
      return {
        badge: 'bg-muted/50 text-muted-foreground hover:bg-muted',
        dot: 'bg-muted-foreground',
      };
  }
};

/**
 * Generates a public display URL for a room
 */
export const generatePublicDisplayUrl = (roomId: number | string): string => {
  return `${window.location.origin}/public-display?room=${roomId}`;
};

/**
 * Parses and safely retrieves data from sessionStorage
 */
export const getFromSessionStorage = <T>(key: string, fallback: T): T => {
  if (typeof window === 'undefined') return fallback;
  
  try {
    const stored = sessionStorage.getItem(key);
    return stored ? JSON.parse(stored) : fallback;
  } catch {
    return fallback;
  }
};

/**
 * Safely stores data in sessionStorage
 */
export const saveToSessionStorage = (key: string, value: unknown): void => {
  if (typeof window === 'undefined') return;
  
  try {
    sessionStorage.setItem(key, JSON.stringify(value));
  } catch (error) {
    }
};

/**
 * Formats room configuration display
 */
export const formatRoomConfig = (room: Room) => {
  return {
    languages: `${room.transcription_language?.toUpperCase() || 'AR'} → ${room.translation__language?.toUpperCase() || 'NL'}`,
    delay: `${room.max_delay || 2.0}s`,
    punctuation: room.punctuation_sensitivity || 0.5,
  };
};


================================================
FILE: src/utils/sessionCleanupCoordinator.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';

export type CleanupSource = 'user' | 'browser' | 'timeout' | 'error' | 'visibility' | 'unmount';

interface CleanupOptions {
  sessionId: string;
  roomId: number;
  source: CleanupSource;
  room?: Tables<'rooms'>;
  onComplete?: () => void;
  skipTranscriptWait?: boolean; // Skip waiting for transcripts (e.g., when cleaning up before new session)
}

interface CleanupResult {
  success: boolean;
  source: CleanupSource;
  reason?: string;
  error?: any;
}

// Singleton to prevent multiple cleanup instances
let isCleaningUp = false;
const cleanupQueue = new Map<string, CleanupOptions>();

/**
 * Wait for final transcripts using inactivity polling
 * Waits until no new transcripts are being added
 */
async function waitForFinalTranscripts(sessionId: string): Promise<void> {
  const INITIAL_DELAY_MS = 3000; // Initial wait for processing to catch up
  const POLLING_INTERVAL_MS = 2500; // How often to check for new transcripts
  const MAX_ATTEMPTS = 5; // Stop after max attempts (5 * 2.5s = 12.5s)

  await new Promise(resolve => setTimeout(resolve, INITIAL_DELAY_MS));

  let lastKnownCount = 0;
  for (let i = 0; i < MAX_ATTEMPTS; i++) {
    const { count, error } = await supabase
      .from('transcripts')
      .select('*', { count: 'exact', head: true }) // head:true is efficient, just gets the count
      .eq('session_id', sessionId);

    if (error) {
      console.error('Error fetching transcript count:', error);
      break; // Exit on error
    }

    if (i > 0 && count === lastKnownCount) {
      // The count has been stable for one polling interval, we can consider it done
      console.log(`Transcription count is stable at ${count}. Proceeding to archive.`);
      return; // Success!
    }

    lastKnownCount = count || 0;
    console.log(`Polling attempt ${i + 1}: Found ${count} transcripts. Waiting...`);
    
    if (i < MAX_ATTEMPTS - 1) { // Don't wait on the last iteration
      await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL_MS));
    }
  }

  console.warn('Polling timed out. Archiving with current transcripts.');
}

/**
 * Consolidated session cleanup coordinator
 * Ensures idempotent cleanup regardless of the source
 */
export const cleanupSession = async (options: CleanupOptions): Promise<CleanupResult> => {
  const { sessionId, roomId, source, room, onComplete, skipTranscriptWait = false } = options;
  
  // Prevent duplicate cleanup attempts
  if (isCleaningUp || cleanupQueue.has(sessionId)) {
    return {
      success: false,
      source,
      reason: 'cleanup_in_progress'
    };
  }
  
  // Add to queue
  cleanupQueue.set(sessionId, options);
  isCleaningUp = true;
  
  try {
    // 1. Signal backend cleanup first
    await signalBackendCleanup(sessionId, roomId, source);
    
    // 2. For user-initiated cleanup with skipTranscriptWait, do minimal cleanup
    if (skipTranscriptWait) {
      // Quick cleanup - just update status and clear local state
      const { error: updateError } = await supabase
        .from('room_sessions')
        .update({ 
          status: 'completed',
          ended_at: new Date().toISOString()
        })
        .eq('id', sessionId)
        .eq('room_id', roomId);

      if (updateError) {
        console.error('Failed to update session status:', updateError);
      }

      // Clear local state immediately
      clearLocalState(roomId);
      
      // Call completion callback
      onComplete?.();
      
      // Schedule background transcript count update
      setTimeout(async () => {
        try {
          const { count } = await supabase
            .from('transcripts')
            .select('*', { count: 'exact', head: true })
            .eq('session_id', sessionId);
          
          await supabase
            .from('room_sessions')
            .update({ transcript_count: count || 0 })
            .eq('id', sessionId);
        } catch (err) {
          console.error('Background transcript count update failed:', err);
        }
      }, 5000);
      
      return {
        success: true,
        source,
        reason: 'cleanup_completed_quick'
      };
    }
    
    // 3. Full cleanup path with transcript waiting
    await waitForFinalTranscripts(sessionId);
    
    // 4. Get final transcript count
    const { count } = await supabase
      .from('transcripts')
      .select('*', { count: 'exact', head: true })
      .eq('session_id', sessionId);
    
    // 5. Update session status with accurate transcript count
    const { error: updateError } = await supabase
      .from('room_sessions')
      .update({ 
        status: 'completed',
        ended_at: new Date().toISOString(),
        transcript_count: count || 0
      })
      .eq('id', sessionId)
      .eq('room_id', roomId);

    if (updateError) {
      console.error('Failed to update session status:', updateError);
    }

    // 6. Clear local state
    clearLocalState(roomId);
    
    // 7. Call completion callback
    onComplete?.();
    
    // Return success
    return {
      success: true,
      source,
      reason: 'cleanup_completed'
    };
    
    /*
    // Original RPC calls commented out since the functions don't exist
    const { data: cleanupResult, error: dbError } = await supabase
      .rpc('cleanup_session_idempotent', {
        session_id_param: sessionId,
        cleanup_source: source,
        cleanup_timestamp: new Date().toISOString()
      });
      */
    
  } catch (error) {
    // Even on error, try to clear local state
    clearLocalState(roomId);
    
    return {
      success: false,
      source,
      error,
      reason: 'cleanup_failed'
    };
    
  } finally {
    // Remove from queue
    cleanupQueue.delete(sessionId);
    isCleaningUp = false;
    
    // Process any queued cleanups
    if (cleanupQueue.size > 0) {
      const next = cleanupQueue.values().next().value;
      if (next) {
        setTimeout(() => cleanupSession(next), 100);
      }
    }
  }
};

/**
 * Clear all local state for a room
 */
function clearLocalState(roomId: number) {
  try {
    sessionStorage.removeItem(`monitoring-${roomId}`);
    sessionStorage.removeItem(`session-${roomId}`);
    sessionStorage.removeItem(`transcripts-${roomId}`);
    sessionStorage.removeItem(`hidden-${roomId}`);
    } catch (error) {
    }
}

/**
 * Signal backend to cleanup resources (best effort)
 */
async function signalBackendCleanup(sessionId: string, roomId: number, source: CleanupSource) {
  try {
    // Try multiple methods to reach the backend
    
    // Method 1: Edge function (for page unload scenarios)
    if (navigator.sendBeacon && (source === 'browser' || source === 'unmount')) {
      const data = JSON.stringify({
        session_id: sessionId,
        action: 'end_session',
        reason: `frontend_${source}`
      });
      
      // Use hardcoded Supabase URL since env var might not be available
      const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'https://bpsahvbdlkzemwjdgxmq.supabase.co';
      const sent = navigator.sendBeacon(
        `${supabaseUrl}/functions/v1/cleanup-session`,
        new Blob([data], { type: 'application/json' })
      );
      
      if (sent) {
        return;
      }
    }
    
    // Method 2: Regular HTTP call (for normal scenarios)
    await supabase.functions.invoke('cleanup-session', {
      body: {
        session_id: sessionId,
        action: 'end_session',
        reason: `frontend_${source}`
      }
    });
    
    } catch (error) {
    // This is best effort - don't fail the cleanup if signaling fails
    }
}

/**
 * Emergency cleanup for critical scenarios
 * Uses sendBeacon for reliability during page unload
 */
export const emergencyCleanup = (sessionId: string, roomId: number) => {
  if (!sessionId || !navigator.sendBeacon) return;
  
  // Clear local state immediately
  clearLocalState(roomId);
  
  // Send cleanup signal
  const data = JSON.stringify({
    session_id: sessionId,
    action: 'end_session',
    reason: 'emergency_cleanup'
  });
  
  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'https://bpsahvbdlkzemwjdgxmq.supabase.co';
  navigator.sendBeacon(
    `${supabaseUrl}/functions/v1/cleanup-session`,
    new Blob([data], { type: 'application/json' })
  );
};

/**
 * Check if a session needs cleanup based on various conditions
 */
export const shouldCleanupSession = (room?: Tables<'rooms'>): boolean => {
  // Never cleanup persistent (kiosk) rooms automatically
  if (room?.is_persistent) {
    return false;
  }
  
  // Add other conditions as needed
  return true;
};


================================================
FILE: src/utils/sessionCleanupEnhanced.ts
================================================
import { supabase } from '@/integrations/supabase/client';
import { cleanupSession, CleanupSource } from './sessionCleanupCoordinator';

interface VerificationResult {
  isActive: boolean;
  needsCleanup: boolean;
  sessionData?: any;
}

/**
 * Enhanced session cleanup with verification and retry logic
 */
export class EnhancedSessionCleanup {
  private verificationAttempts = new Map<string, number>();
  private cleanupInProgress = new Set<string>();

  /**
   * Cleanup session with verification and retry
   */
  async cleanupWithVerification(
    sessionId: string,
    roomId: number,
    source: CleanupSource,
    maxRetries: number = 3
  ): Promise<boolean> {
    // Prevent duplicate cleanup attempts
    if (this.cleanupInProgress.has(sessionId)) {
      return false;
    }

    this.cleanupInProgress.add(sessionId);

    try {
      // Step 1: Initial cleanup attempt
      const result = await cleanupSession({
        sessionId,
        roomId,
        source,
        onComplete: () => {
          }
      });

      // Step 2: Verify cleanup after delay
      await new Promise(resolve => setTimeout(resolve, 2000));
      const verification = await this.verifySessionStatus(sessionId);

      if (!verification.needsCleanup) {
        this.verificationAttempts.delete(sessionId);
        return true;
      }

      // Step 3: Retry if needed
      const attempts = this.verificationAttempts.get(sessionId) || 0;
      if (attempts < maxRetries) {
        `);
        this.verificationAttempts.set(sessionId, attempts + 1);
        
        // Force cleanup via RPC
        await this.forceCleanupViaRPC(sessionId, source);
        
        // Recursive retry
        return await this.cleanupWithVerification(sessionId, roomId, source, maxRetries);
      }

      return false;

    } finally {
      this.cleanupInProgress.delete(sessionId);
    }
  }

  /**
   * Verify if session is truly closed
   */
  private async verifySessionStatus(sessionId: string): Promise<VerificationResult> {
    try {
      const { data, error } = await supabase
        .from('room_sessions')
        .select('status, ended_at, cleanup_source')
        .eq('id', sessionId)
        .single();

      if (error) {
        return { isActive: false, needsCleanup: false };
      }

      const isActive = data?.status === 'active';
      const needsCleanup = isActive || !data?.ended_at;

      return {
        isActive,
        needsCleanup,
        sessionData: data
      };
    } catch (error) {
      return { isActive: false, needsCleanup: false };
    }
  }

  /**
   * Force cleanup using RPC function
   */
  private async forceCleanupViaRPC(
    sessionId: string, 
    source: CleanupSource
  ): Promise<void> {
    try {
      const { data, error } = await supabase.rpc('cleanup_session_idempotent', {
        session_id_param: sessionId,
        cleanup_source: `frontend_force_${source}`,
        cleanup_timestamp: new Date().toISOString()
      });

      if (error) {
        } else {
        }
    } catch (error) {
      }
  }

  /**
   * Batch cleanup for multiple sessions
   */
  async cleanupMultipleSessions(
    sessions: Array<{ sessionId: string; roomId: number }>,
    source: CleanupSource
  ): Promise<void> {
    // Process in parallel with concurrency limit
    const concurrencyLimit = 3;
    const results = [];
    
    for (let i = 0; i < sessions.length; i += concurrencyLimit) {
      const batch = sessions.slice(i, i + concurrencyLimit);
      const batchPromises = batch.map(({ sessionId, roomId }) =>
        this.cleanupWithVerification(sessionId, roomId, source)
      );
      
      const batchResults = await Promise.allSettled(batchPromises);
      results.push(...batchResults);
    }

    const successful = results.filter(r => r.status === 'fulfilled' && r.value).length;
    }

  /**
   * Monitor and cleanup ghost sessions periodically
   */
  async monitorGhostSessions(roomId?: number): Promise<void> {
    try {
      // Query for potential ghost sessions
      let query = supabase
        .from('ghost_session_monitor')
        .select('*')
        .neq('health_status', 'OK');

      if (roomId) {
        query = query.eq('room_id', roomId);
      }

      const { data: ghostSessions, error } = await query;

      if (error) {
        return;
      }

      if (ghostSessions && ghostSessions.length > 0) {
        // Cleanup critical sessions
        const criticalSessions = ghostSessions
          .filter(s => s.health_status.includes('CRITICAL'))
          .map(s => ({ sessionId: s.session_id, roomId: s.room_id }));

        if (criticalSessions.length > 0) {
          await this.cleanupMultipleSessions(criticalSessions, 'timeout');
        }
      }
    } catch (error) {
      }
  }
}

// Export singleton instance
export const enhancedCleanup = new EnhancedSessionCleanup();

// Hook for React components
export function useEnhancedSessionCleanup() {
  const cleanup = async (
    sessionId: string,
    roomId: number,
    source: CleanupSource = 'user'
  ) => {
    return await enhancedCleanup.cleanupWithVerification(sessionId, roomId, source);
  };

  const monitorGhostSessions = async (roomId?: number) => {
    return await enhancedCleanup.monitorGhostSessions(roomId);
  };

  return {
    cleanup,
    monitorGhostSessions
  };
}


================================================
FILE: src/utils/textAnimator.ts
================================================
export const splitIntoChunks = (text: string, maxCharsPerLine: number = 80): string[] => {
  if (!text) return [];
  
  const words = text.split(' ');
  const chunks: string[] = [];
  let currentChunk = '';
  
  for (const word of words) {
    if ((currentChunk + ' ' + word).length <= maxCharsPerLine) {
      currentChunk = currentChunk ? currentChunk + ' ' + word : word;
    } else {
      if (currentChunk) {
        chunks.push(currentChunk);
      }
      currentChunk = word;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  
  return chunks;
};

export const calculateReadingDelay = (text: string, wordsPerMinute: number = 150): number => {
  const words = text.split(' ').length;
  const minutes = words / wordsPerMinute;
  return minutes * 60 * 1000; // Convert to milliseconds
};


================================================
FILE: supabase/config.toml
================================================
project_id = "bpsahvbdlkzemwjdgxmq"

[functions.admin-create-user]
verify_jwt = true

[functions.generate-livekit-token]
verify_jwt = true

[functions.websocket-bridge]
verify_jwt = false

[functions.impersonate-user]
verify_jwt = true


================================================
FILE: supabase/functions/admin-create-user/index.ts
================================================
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    console.log('Admin create user function called')
    
    // Initialize Supabase admin client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')
    const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
    
    if (!supabaseUrl || !serviceRoleKey) {
      console.error('Missing environment variables')
      return new Response(
        JSON.stringify({ error: 'Server configuration error' }),
        { 
          status: 500, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }
    
    const supabaseAdmin = createClient(supabaseUrl, serviceRoleKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    })

    // Parse request body first
    let body
    try {
      body = await req.json()
    } catch (e) {
      console.error('Failed to parse request body:', e)
      return new Response(
        JSON.stringify({ error: 'Invalid request body' }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    const { email, password, full_name, mosque_id, role = 'User' } = body
    
    console.log('Request to create user:', { email, full_name, mosque_id, role })

    // Validate required fields
    if (!email || !password || !full_name || !mosque_id) {
      console.error('Missing required fields')
      return new Response(
        JSON.stringify({ 
          error: 'Missing required fields',
          details: {
            email: !email ? 'Email is required' : null,
            password: !password ? 'Password is required' : null,
            full_name: !full_name ? 'Full name is required' : null,
            mosque_id: !mosque_id ? 'Mosque ID is required' : null
          }
        }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    // Get the authorization header
    const authHeader = req.headers.get('Authorization')
    
    if (!authHeader) {
      console.error('No authorization header')
      return new Response(
        JSON.stringify({ error: 'Authorization required' }),
        { 
          status: 401, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    // Extract the JWT token
    const token = authHeader.replace('Bearer ', '')
    
    // Get the user from the token
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token)
    
    if (authError || !user) {
      console.error('Auth error:', authError)
      return new Response(
        JSON.stringify({ error: 'Invalid token' }),
        { 
          status: 401, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    console.log('Authenticated user ID:', user.id)

    // Check if the user is a super admin
    const { data: currentUserData, error: userError } = await supabaseAdmin
      .from('users')
      .select('is_super_admin, Role, mosque_id')
      .eq('id', user.id)
      .single()

    if (userError || !currentUserData) {
      console.error('User profile error:', userError)
      return new Response(
        JSON.stringify({ error: 'User profile not found' }),
        { 
          status: 403, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    console.log('Current user data:', currentUserData)

    // Check authorization
    const isAuthorized = currentUserData.is_super_admin === true || 
      (currentUserData.Role === 'Admin' && currentUserData.mosque_id === mosque_id)

    if (!isAuthorized) {
      console.error('Not authorized. Super admin:', currentUserData.is_super_admin, 'Role:', currentUserData.Role)
      return new Response(
        JSON.stringify({ error: 'Only super admins or mosque admins can create users' }),
        { 
          status: 403, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    // Verify mosque exists
    const { data: mosque, error: mosqueError } = await supabaseAdmin
      .from('Mosque')
      .select('id, name')
      .eq('id', mosque_id)
      .single()

    if (mosqueError || !mosque) {
      console.error('Mosque error:', mosqueError)
      return new Response(
        JSON.stringify({ error: 'Mosque not found' }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    console.log('Creating auth user...')

    // Create the auth user
    const { data: newUser, error: createError } = await supabaseAdmin.auth.admin.createUser({
      email: email,
      password: password,
      email_confirm: true,
      user_metadata: {
        full_name: full_name,
        mosque_id: mosque_id,
        role: role
      }
    })

    if (createError) {
      console.error('Create user error:', createError)
      return new Response(
        JSON.stringify({ 
          error: createError.message || 'Failed to create user',
          code: createError.code
        }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      )
    }

    console.log('Auth user created:', newUser.user.id)

    // The trigger should create the profile, but let's ensure it exists
    // Wait briefly for trigger
    await new Promise(resolve => setTimeout(resolve, 1000))

    // Upsert the user profile to ensure it has the correct data
    const { error: profileError } = await supabaseAdmin
      .from('users')
      .upsert({
        id: newUser.user.id,
        email: email,
        full_name: full_name,
        mosque_id: mosque_id,
        Role: role,
        is_active: true,
        is_super_admin: false
      }, {
        onConflict: 'id'
      })

    if (profileError) {
      console.warn('Profile upsert warning:', profileError)
      // Don't fail - the trigger may have already created it
    }

    console.log('User creation complete')

    return new Response(
      JSON.stringify({
        success: true,
        message: 'User created successfully',
        user: {
          id: newUser.user.id,
          email: email,
          full_name: full_name,
          mosque_id: mosque_id,
          mosque_name: mosque.name,
          role: role
        }
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )

  } catch (error) {
    console.error('Unexpected error:', error)
    return new Response(
      JSON.stringify({ 
        error: 'Internal server error',
        message: error.message
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})


================================================
FILE: supabase/functions/cleanup-session/index.ts
================================================
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Credentials': 'true'
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )

    const { sessionId, roomId, source, room, skipTranscriptWait } = await req.json()

    // Your cleanup logic here
    console.log(`Cleaning up session ${sessionId} for room ${roomId}`)

    // Update session status
    const { error: updateError } = await supabaseClient
      .from('room_sessions')
      .update({ 
        status: 'archived',
        ended_at: new Date().toISOString()
      })
      .eq('id', sessionId)

    if (updateError) {
      throw updateError
    }

    return new Response(
      JSON.stringify({ success: true, message: 'Session cleaned up successfully' }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200
      }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400
      }
    )
  }
})


================================================
FILE: supabase/functions/monthly-billing/index.ts
================================================
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Create Supabase client with service role key for admin operations
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )

    // Check if this is being called on the first few days of the month
    const now = new Date()
    const dayOfMonth = now.getDate()
    
    // Only run billing between 1st and 5th of each month
    // This gives a grace period for any late sessions from the previous month
    if (dayOfMonth > 5) {
      return new Response(
        JSON.stringify({
          success: false,
          message: `Billing only runs between 1st-5th of the month. Current day: ${dayOfMonth}`
        }),
        { 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200 
        }
      )
    }

    // Call the database function to check and run monthly billing
    const { data, error } = await supabaseClient.rpc('check_and_run_monthly_billing')

    if (error) {
      console.error('Error running monthly billing:', error)
      throw error
    }

    console.log('Monthly billing result:', data)

    // Send email notifications to super admins about billing completion
    if (data?.success && data?.message === 'Monthly billing snapshot created') {
      // Get super admin emails
      const { data: superAdmins } = await supabaseClient
        .from('users')
        .select('email')
        .eq('is_super_admin', true)
        .not('email', 'is', null)

      // Log notification (in production, send actual emails)
      console.log('Would notify super admins:', superAdmins?.map(a => a.email))
      
      // You can integrate with an email service here
      // Example: SendGrid, Resend, etc.
    }

    return new Response(
      JSON.stringify(data),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200
      }
    )
  } catch (error) {
    console.error('Edge function error:', error)
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error.message 
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400
      }
    )
  }
})


================================================
FILE: supabase/migrations/20241201_create_billing_packages.sql
================================================
-- Drop existing tables if they exist (for development - remove in production)
-- DROP TABLE IF EXISTS public.usage_alerts CASCADE;
-- DROP TABLE IF EXISTS public.billing_history CASCADE;
-- DROP TABLE IF EXISTS public.mosque_subscriptions CASCADE;
-- DROP TABLE IF EXISTS public.billing_packages CASCADE;

-- Create billing packages table
CREATE TABLE IF NOT EXISTS public.billing_packages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  monthly_price DECIMAL(10,2),
  included_hours INTEGER,
  overage_rate DECIMAL(10,2),
  features JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT true,
  is_custom BOOLEAN DEFAULT false,
  color VARCHAR(50),
  max_rooms INTEGER,
  max_users INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create mosque subscriptions table
CREATE TABLE IF NOT EXISTS public.mosque_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mosque_id INTEGER REFERENCES "Mosque"(id) ON DELETE CASCADE,
  package_id UUID REFERENCES billing_packages(id),
  custom_price DECIMAL(10,2),
  custom_hours INTEGER,
  custom_overage_rate DECIMAL(10,2),
  billing_cycle VARCHAR(20) DEFAULT 'monthly',
  status VARCHAR(20) DEFAULT 'active',
  trial_ends_at TIMESTAMPTZ,
  current_period_start TIMESTAMPTZ DEFAULT NOW(),
  current_period_end TIMESTAMPTZ,
  next_billing_date TIMESTAMPTZ,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),
  UNIQUE(mosque_id)
);

-- Create billing history table
CREATE TABLE IF NOT EXISTS public.billing_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mosque_id INTEGER REFERENCES "Mosque"(id),
  subscription_id UUID REFERENCES mosque_subscriptions(id),
  period_start TIMESTAMPTZ NOT NULL,
  period_end TIMESTAMPTZ NOT NULL,
  package_name VARCHAR(100),
  included_hours INTEGER,
  used_hours DECIMAL(10,2),
  overage_hours DECIMAL(10,2),
  base_price DECIMAL(10,2),
  overage_cost DECIMAL(10,2),
  total_cost DECIMAL(10,2),
  invoice_number VARCHAR(50),
  payment_status VARCHAR(20) DEFAULT 'pending',
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create usage alerts table
CREATE TABLE IF NOT EXISTS public.usage_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mosque_id INTEGER REFERENCES "Mosque"(id),
  alert_type VARCHAR(50),
  threshold_percentage INTEGER,
  hours_used DECIMAL(10,2),
  hours_limit INTEGER,
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  acknowledged BOOLEAN DEFAULT false,
  acknowledged_by UUID REFERENCES auth.users(id),
  acknowledged_at TIMESTAMPTZ
);

-- Insert default packages (only if they don't exist)
INSERT INTO public.billing_packages (name, slug, monthly_price, included_hours, overage_rate, color, features) 
VALUES
  ('Starter', 'starter', 49, 8, 7, 'bg-blue-500', '{"description": "Perfect for small mosques", "support": "email"}'),
  ('Professional', 'professional', 99, 20, 5, 'bg-purple-500', '{"description": "For growing communities", "support": "priority"}'),
  ('Enterprise', 'enterprise', NULL, NULL, 0, 'bg-gradient-to-r from-purple-500 to-blue-500', '{"description": "Custom solution for large organizations", "support": "dedicated"}')
ON CONFLICT (slug) DO NOTHING;

-- Create indexes
CREATE INDEX idx_mosque_subscriptions_mosque_id ON public.mosque_subscriptions(mosque_id);
CREATE INDEX idx_mosque_subscriptions_status ON public.mosque_subscriptions(status);
CREATE INDEX idx_billing_history_mosque_id ON public.billing_history(mosque_id);
CREATE INDEX idx_billing_history_period ON public.billing_history(period_start, period_end);
CREATE INDEX idx_usage_alerts_mosque_id ON public.usage_alerts(mosque_id);

-- RLS Policies
ALTER TABLE public.billing_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mosque_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.billing_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.usage_alerts ENABLE ROW LEVEL SECURITY;

-- Billing packages: Everyone can read, only super admins can modify
CREATE POLICY "Anyone can view packages" ON public.billing_packages
  FOR SELECT USING (true);

CREATE POLICY "Super admins can manage packages" ON public.billing_packages
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = auth.uid() 
      AND users.is_super_admin = true
    )
  );

-- Mosque subscriptions: Super admins full access, mosque admins read their own
CREATE POLICY "Super admins can manage all subscriptions" ON public.mosque_subscriptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = auth.uid() 
      AND users.is_super_admin = true
    )
  );

CREATE POLICY "Mosque admins can view their subscription" ON public.mosque_subscriptions
  FOR SELECT USING (
    mosque_id IN (
      SELECT mosque_id FROM public.users 
      WHERE users.id = auth.uid()
    )
  );

-- Billing history: Similar to subscriptions
CREATE POLICY "Super admins can manage all billing history" ON public.billing_history
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = auth.uid() 
      AND users.is_super_admin = true
    )
  );

CREATE POLICY "Mosque admins can view their billing history" ON public.billing_history
  FOR SELECT USING (
    mosque_id IN (
      SELECT mosque_id FROM public.users 
      WHERE users.id = auth.uid()
    )
  );

-- Usage alerts: Similar pattern
CREATE POLICY "Super admins can manage all alerts" ON public.usage_alerts
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = auth.uid() 
      AND users.is_super_admin = true
    )
  );

CREATE POLICY "Mosque admins can view and acknowledge their alerts" ON public.usage_alerts
  FOR SELECT USING (
    mosque_id IN (
      SELECT mosque_id FROM public.users 
      WHERE users.id = auth.uid()
    )
  );

CREATE POLICY "Mosque admins can acknowledge their alerts" ON public.usage_alerts
  FOR UPDATE USING (
    mosque_id IN (
      SELECT mosque_id FROM public.users 
      WHERE users.id = auth.uid()
    )
  ) WITH CHECK (
    mosque_id IN (
      SELECT mosque_id FROM public.users 
      WHERE users.id = auth.uid()
    )
  );

-- Function to get mosque's current package
CREATE OR REPLACE FUNCTION get_mosque_package(p_mosque_id INTEGER)
RETURNS TABLE (
  package_id UUID,
  package_name VARCHAR,
  monthly_price DECIMAL,
  included_hours INTEGER,
  overage_rate DECIMAL,
  custom_price DECIMAL,
  custom_hours INTEGER,
  custom_overage_rate DECIMAL,
  effective_price DECIMAL,
  effective_hours INTEGER,
  effective_overage_rate DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ms.package_id,
    bp.name as package_name,
    bp.monthly_price,
    bp.included_hours,
    bp.overage_rate,
    ms.custom_price,
    ms.custom_hours,
    ms.custom_overage_rate,
    COALESCE(ms.custom_price, bp.monthly_price) as effective_price,
    COALESCE(ms.custom_hours, bp.included_hours) as effective_hours,
    COALESCE(ms.custom_overage_rate, bp.overage_rate) as effective_overage_rate
  FROM mosque_subscriptions ms
  JOIN billing_packages bp ON ms.package_id = bp.id
  WHERE ms.mosque_id = p_mosque_id
  AND ms.status = 'active'
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate billing for a period
CREATE OR REPLACE FUNCTION calculate_mosque_billing(
  p_mosque_id INTEGER,
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ
)
RETURNS TABLE (
  total_hours DECIMAL,
  included_hours INTEGER,
  overage_hours DECIMAL,
  base_cost DECIMAL,
  overage_cost DECIMAL,
  total_cost DECIMAL
) AS $$
DECLARE
  v_total_minutes INTEGER;
  v_package RECORD;
BEGIN
  -- Get mosque's package
  SELECT * INTO v_package FROM get_mosque_package(p_mosque_id);
  
  -- Calculate total usage
  SELECT COALESCE(SUM(
    EXTRACT(EPOCH FROM (ended_at - started_at)) / 60
  ), 0) INTO v_total_minutes
  FROM room_sessions rs
  JOIN rooms r ON rs.room_id = r.id
  WHERE r.mosque_id = p_mosque_id
  AND rs.started_at >= p_start_date
  AND rs.started_at <= p_end_date
  AND rs.ended_at IS NOT NULL;
  
  RETURN QUERY
  SELECT 
    v_total_minutes / 60.0 as total_hours,
    v_package.effective_hours as included_hours,
    GREATEST(0, (v_total_minutes / 60.0) - v_package.effective_hours) as overage_hours,
    v_package.effective_price as base_cost,
    GREATEST(0, (v_total_minutes / 60.0) - v_package.effective_hours) * v_package.effective_overage_rate as overage_cost,
    v_package.effective_price + (GREATEST(0, (v_total_minutes / 60.0) - v_package.effective_hours) * v_package.effective_overage_rate) as total_cost;
END;
$$ LANGUAGE plpgsql;


================================================
FILE: supabase/migrations/20241201_package_with_slug_reference.sql
================================================
-- Alternative: Reference packages by slug instead of UUID

-- Create billing packages table with slug as primary key
CREATE TABLE IF NOT EXISTS public.billing_packages (
  slug VARCHAR(50) PRIMARY KEY, -- Use slug as the ID!
  name VARCHAR(100) NOT NULL,
  monthly_price DECIMAL(10,2),
  included_hours INTEGER,
  overage_rate DECIMAL(10,2),
  features JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT true,
  color VARCHAR(50),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add package_slug to Mosque table
ALTER TABLE "Mosque" 
ADD COLUMN IF NOT EXISTS package_slug VARCHAR(50) REFERENCES billing_packages(slug) DEFAULT 'professional';

-- Insert default packages
INSERT INTO public.billing_packages (slug, name, monthly_price, included_hours, overage_rate, color, features) 
VALUES
  ('starter', 'Starter', 49, 8, 7, 'bg-blue-500', '{"description": "Perfect for small mosques", "support": "email"}'),
  ('professional', 'Professional', 99, 20, 5, 'bg-purple-500', '{"description": "For growing communities", "support": "priority"}'),
  ('enterprise', 'Enterprise', NULL, NULL, 0, 'bg-gradient-to-r from-purple-500 to-blue-500', '{"description": "Custom solution for large organizations", "support": "dedicated"}')
ON CONFLICT (slug) DO NOTHING;

-- Set default package for all existing mosques
UPDATE "Mosque" 
SET package_slug = 'professional'
WHERE package_slug IS NULL;


================================================
FILE: supabase/migrations/20241201_simple_package_column.sql
================================================
-- Simplest approach: Just add package_name column to Mosque table

-- Add package_name column to Mosque table (just a simple string)
ALTER TABLE "Mosque" 
ADD COLUMN IF NOT EXISTS package_name VARCHAR(50) DEFAULT 'professional';

-- Set all existing mosques to 'professional' package
UPDATE "Mosque" 
SET package_name = 'professional'
WHERE package_name IS NULL;

-- Add a check constraint to ensure valid package names
ALTER TABLE "Mosque"
ADD CONSTRAINT valid_package_name CHECK (
  package_name IN ('starter', 'professional', 'enterprise')
);


================================================
FILE: supabase/migrations/20241201_simplified_billing.sql
================================================
-- Simplified Billing System Migration
-- Only creates necessary tables and adds package_id to Mosque table

-- 1. Create billing packages table (for storing tiers)
CREATE TABLE IF NOT EXISTS public.billing_packages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  monthly_price DECIMAL(10,2),
  included_hours INTEGER,
  overage_rate DECIMAL(10,2),
  features JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT true,
  color VARCHAR(50),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Add package_id to existing Mosque table
ALTER TABLE "Mosque" 
ADD COLUMN IF NOT EXISTS package_id UUID REFERENCES billing_packages(id);

-- 3. Create billing history table (for monthly records)
CREATE TABLE IF NOT EXISTS public.billing_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mosque_id INTEGER REFERENCES "Mosque"(id),
  period_start TIMESTAMPTZ NOT NULL,
  period_end TIMESTAMPTZ NOT NULL,
  package_name VARCHAR(100),
  included_hours INTEGER,
  used_hours DECIMAL(10,2),
  overage_hours DECIMAL(10,2),
  base_price DECIMAL(10,2),
  overage_cost DECIMAL(10,2),
  total_cost DECIMAL(10,2),
  invoice_number VARCHAR(50),
  payment_status VARCHAR(20) DEFAULT 'pending',
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default packages
INSERT INTO public.billing_packages (name, slug, monthly_price, included_hours, overage_rate, color, features) 
VALUES
  ('Starter', 'starter', 49, 8, 7, 'bg-blue-500', '{"description": "Perfect for small mosques", "support": "email"}'),
  ('Professional', 'professional', 99, 20, 5, 'bg-purple-500', '{"description": "For growing communities", "support": "priority"}'),
  ('Enterprise', 'enterprise', NULL, NULL, 0, 'bg-gradient-to-r from-purple-500 to-blue-500', '{"description": "Custom solution for large organizations", "support": "dedicated"}')
ON CONFLICT (slug) DO NOTHING;

-- Set default package for all existing mosques (Professional)
UPDATE "Mosque" 
SET package_id = (SELECT id FROM billing_packages WHERE slug = 'professional')
WHERE package_id IS NULL;

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_mosque_package_id ON "Mosque"(package_id);
CREATE INDEX IF NOT EXISTS idx_billing_history_mosque_id ON billing_history(mosque_id);
CREATE INDEX IF NOT EXISTS idx_billing_history_period ON billing_history(period_start, period_end);

-- RLS Policies (with IF NOT EXISTS checks)
ALTER TABLE public.billing_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.billing_history ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist and recreate
DROP POLICY IF EXISTS "Anyone can view packages" ON public.billing_packages;
DROP POLICY IF EXISTS "Super admins can manage packages" ON public.billing_packages;
DROP POLICY IF EXISTS "Super admins can manage all billing history" ON public.billing_history;
DROP POLICY IF EXISTS "Mosque admins can view their billing history" ON public.billing_history;

-- Everyone can view packages (needed so users can see available pricing tiers)
CREATE POLICY "Anyone can view packages" ON public.billing_packages
  FOR SELECT USING (true);

-- Only super admins can modify packages
CREATE POLICY "Super admins can manage packages" ON public.billing_packages
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = auth.uid() 
      AND users.is_super_admin = true
    )
  );

-- Billing history policies
CREATE POLICY "Super admins can manage all billing history" ON public.billing_history
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = auth.uid() 
      AND users.is_super_admin = true
    )
  );

CREATE POLICY "Mosque admins can view their billing history" ON public.billing_history
  FOR SELECT USING (
    mosque_id IN (
      SELECT mosque_id FROM public.users 
      WHERE users.id = auth.uid()
    )
  );


================================================
FILE: supabase/migrations/20241202_add_monthly_billing_snapshot.sql
================================================
-- Create function to generate monthly billing snapshot
CREATE OR REPLACE FUNCTION generate_monthly_billing_snapshot()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_mosque RECORD;
  v_package RECORD;
  v_total_minutes NUMERIC;
  v_total_hours NUMERIC;
  v_period_start TIMESTAMPTZ;
  v_period_end TIMESTAMPTZ;
  v_overage_hours NUMERIC;
  v_overage_cost NUMERIC;
  v_total_cost NUMERIC;
  v_transcript_count INTEGER;
  v_sentence_count INTEGER;
BEGIN
  -- Set period to previous month
  v_period_start := date_trunc('month', CURRENT_DATE - INTERVAL '1 month');
  v_period_end := date_trunc('month', CURRENT_DATE) - INTERVAL '1 second';

  -- Loop through all mosques
  FOR v_mosque IN 
    SELECT DISTINCT m.id, m.name, m.package_slug
    FROM "Mosque" m
    WHERE m.deleted_at IS NULL
  LOOP
    -- Get package details
    SELECT * INTO v_package 
    FROM billing_packages 
    WHERE slug = COALESCE(v_mosque.package_slug, 'professional');

    -- Calculate total usage for the mosque in the period
    SELECT 
      COALESCE(SUM(
        EXTRACT(EPOCH FROM (
          COALESCE(ended_at, v_period_end) - started_at
        )) / 60
      ), 0),
      COALESCE(SUM(transcript_count), 0),
      COALESCE(SUM(sentence_count), 0)
    INTO v_total_minutes, v_transcript_count, v_sentence_count
    FROM room_sessions rs
    JOIN rooms r ON rs.room_id = r.id
    WHERE r.mosque_id = v_mosque.id
    AND rs.started_at >= v_period_start
    AND rs.started_at <= v_period_end
    AND rs.started_at IS NOT NULL;

    -- Convert to hours
    v_total_hours := v_total_minutes / 60.0;

    -- Calculate overage
    IF v_package.included_hours IS NOT NULL THEN
      v_overage_hours := GREATEST(0, v_total_hours - v_package.included_hours);
      v_overage_cost := v_overage_hours * COALESCE(v_package.overage_rate, 0);
    ELSE
      v_overage_hours := 0;
      v_overage_cost := 0;
    END IF;

    -- Calculate total cost
    v_total_cost := COALESCE(v_package.monthly_price, 0) + v_overage_cost;

    -- Check if billing record already exists for this period
    IF NOT EXISTS (
      SELECT 1 FROM billing_history 
      WHERE mosque_id = v_mosque.id 
      AND period_start = v_period_start
      AND period_end = v_period_end
    ) THEN
      -- Insert billing history record
      INSERT INTO billing_history (
        mosque_id,
        period_start,
        period_end,
        package_name,
        included_hours,
        used_hours,
        overage_hours,
        base_price,
        overage_cost,
        total_cost,
        invoice_number,
        payment_status,
        metadata,
        created_at
      ) VALUES (
        v_mosque.id,
        v_period_start,
        v_period_end,
        v_package.name,
        v_package.included_hours,
        v_total_hours,
        v_overage_hours,
        COALESCE(v_package.monthly_price, 0),
        v_overage_cost,
        v_total_cost,
        'INV-' || v_mosque.id || '-' || to_char(v_period_start, 'YYYYMM'),
        'pending',
        jsonb_build_object(
          'package_slug', v_package.slug,
          'transcript_count', v_transcript_count,
          'sentence_count', v_sentence_count,
          'session_count', (
            SELECT COUNT(*) 
            FROM room_sessions rs
            JOIN rooms r ON rs.room_id = r.id
            WHERE r.mosque_id = v_mosque.id
            AND rs.started_at >= v_period_start
            AND rs.started_at <= v_period_end
          )
        ),
        NOW()
      );

      -- Log the creation
      RAISE NOTICE 'Created billing record for mosque % for period % to %', 
        v_mosque.name, v_period_start, v_period_end;
    END IF;
  END LOOP;
END;
$$;

-- Add metadata column to billing_history if it doesn't exist
ALTER TABLE billing_history 
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

-- Create function to check and run monthly billing
-- This can be called by a cron job or edge function
CREATE OR REPLACE FUNCTION check_and_run_monthly_billing()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_last_run TIMESTAMPTZ;
  v_current_month_start TIMESTAMPTZ;
  v_result jsonb;
BEGIN
  -- Get the start of current month
  v_current_month_start := date_trunc('month', CURRENT_DATE);

  -- Check when billing was last run for the previous month
  SELECT MAX(created_at) INTO v_last_run
  FROM billing_history
  WHERE period_start = date_trunc('month', CURRENT_DATE - INTERVAL '1 month');

  -- If no billing records exist for last month, or if we're past the 1st of the month
  IF v_last_run IS NULL OR v_last_run < v_current_month_start THEN
    -- Run the billing snapshot
    PERFORM generate_monthly_billing_snapshot();
    
    v_result := jsonb_build_object(
      'success', true,
      'message', 'Monthly billing snapshot created',
      'run_date', NOW()
    );
  ELSE
    v_result := jsonb_build_object(
      'success', true,
      'message', 'Monthly billing already processed',
      'last_run', v_last_run
    );
  END IF;

  RETURN v_result;
END;
$$;

-- Create an index for faster billing history queries
CREATE INDEX IF NOT EXISTS idx_billing_history_period_mosque 
ON billing_history(mosque_id, period_start, period_end);

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION generate_monthly_billing_snapshot() TO service_role;
GRANT EXECUTE ON FUNCTION check_and_run_monthly_billing() TO service_role;

-- Comment the functions
COMMENT ON FUNCTION generate_monthly_billing_snapshot() IS 
'Generates monthly billing records for all mosques based on their usage in the previous month';

COMMENT ON FUNCTION check_and_run_monthly_billing() IS 
'Checks if monthly billing needs to be run and executes it if needed. Safe to call multiple times.';


================================================
FILE: supabase/migrations/20241202_simple_monthly_billing_save.sql
================================================
-- Simple function to save previous month's billing data
CREATE OR REPLACE FUNCTION save_previous_month_billing()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_mosque RECORD;
  v_package RECORD;
  v_total_minutes NUMERIC;
  v_total_hours NUMERIC;
  v_period_start TIMESTAMPTZ;
  v_period_end TIMESTAMPTZ;
  v_transcript_count INTEGER;
  v_sentence_count INTEGER;
  v_session_count INTEGER;
BEGIN
  -- Calculate previous month period
  v_period_start := date_trunc('month', CURRENT_DATE - INTERVAL '1 month');
  v_period_end := date_trunc('month', CURRENT_DATE) - INTERVAL '1 second';

  -- Loop through all mosques
  FOR v_mosque IN 
    SELECT id, name, package_slug FROM "Mosque"
  LOOP
    -- Skip if already saved for this period
    IF EXISTS (
      SELECT 1 FROM billing_history 
      WHERE mosque_id = v_mosque.id 
      AND period_start = v_period_start
    ) THEN
      CONTINUE;
    END IF;

    -- Get package details
    SELECT * INTO v_package 
    FROM billing_packages 
    WHERE slug = COALESCE(v_mosque.package_slug, 'professional');

    -- Calculate usage for the previous month
    SELECT 
      COALESCE(SUM(EXTRACT(EPOCH FROM (ended_at - started_at)) / 60), 0),
      COALESCE(SUM(transcript_count), 0),
      COALESCE(SUM(sentence_count), 0),
      COUNT(*)
    INTO v_total_minutes, v_transcript_count, v_sentence_count, v_session_count
    FROM room_sessions rs
    JOIN rooms r ON rs.room_id = r.id
    WHERE r.mosque_id = v_mosque.id
    AND rs.started_at >= v_period_start
    AND rs.started_at <= v_period_end
    AND rs.ended_at IS NOT NULL;

    -- Convert to hours
    v_total_hours := v_total_minutes / 60.0;

    -- Save to billing history
    INSERT INTO billing_history (
      mosque_id,
      period_start,
      period_end,
      package_name,
      included_hours,
      used_hours,
      overage_hours,
      base_price,
      overage_cost,
      total_cost,
      transcript_count,
      sentence_count,
      session_count,
      created_at
    ) VALUES (
      v_mosque.id,
      v_period_start,
      v_period_end,
      v_package.name,
      v_package.included_hours,
      v_total_hours,
      GREATEST(0, v_total_hours - COALESCE(v_package.included_hours, 0)),
      COALESCE(v_package.monthly_price, 0),
      GREATEST(0, v_total_hours - COALESCE(v_package.included_hours, 0)) * COALESCE(v_package.overage_rate, 0),
      COALESCE(v_package.monthly_price, 0) + (GREATEST(0, v_total_hours - COALESCE(v_package.included_hours, 0)) * COALESCE(v_package.overage_rate, 0)),
      v_transcript_count,
      v_sentence_count,
      v_session_count,
      NOW()
    );
  END LOOP;
END;
$$;

-- Add missing columns to billing_history if they don't exist
ALTER TABLE billing_history 
ADD COLUMN IF NOT EXISTS transcript_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS sentence_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS session_count INTEGER DEFAULT 0;

-- Create a simple cron job to run on the 1st of each month at midnight
-- This needs pg_cron extension enabled in Supabase
SELECT cron.schedule(
  'save-monthly-billing',
  '0 0 1 * *', -- Midnight on the 1st of every month
  $$SELECT save_previous_month_billing();$$
);

-- To manually test/run for the current month:
-- SELECT save_previous_month_billing();


================================================
FILE: supabase/migrations/20250114_add_unique_constraint_active_sessions.sql
================================================
-- Add unique constraint to prevent multiple active sessions per room
-- This ensures data integrity at the database level

-- First, clean up any existing duplicate active sessions
WITH ranked_sessions AS (
  SELECT 
    id,
    room_id,
    ROW_NUMBER() OVER (PARTITION BY room_id ORDER BY started_at DESC) as rn
  FROM public.room_sessions
  WHERE status = 'active'
)
UPDATE public.room_sessions
SET 
  status = 'completed',
  ended_at = CURRENT_TIMESTAMP
WHERE id IN (
  SELECT id 
  FROM ranked_sessions 
  WHERE rn > 1
);

-- Create unique index that allows only one active session per room
CREATE UNIQUE INDEX IF NOT EXISTS idx_room_sessions_active_unique 
ON public.room_sessions (room_id) 
WHERE status = 'active';

-- Add comment explaining the constraint
COMMENT ON INDEX idx_room_sessions_active_unique IS 'Ensures only one active session can exist per room at any time';

-- Also add a check to ensure ended_at is set when status is not active
ALTER TABLE public.room_sessions 
ADD CONSTRAINT check_ended_at_for_completed_sessions 
CHECK (
  (status = 'active' AND ended_at IS NULL) OR 
  (status != 'active' AND ended_at IS NOT NULL)
);


================================================
FILE: supabase/migrations/20250114_create_cleanup_room_sessions_function.sql
================================================
-- Create cleanup_room_sessions function to properly handle room cleanup
CREATE OR REPLACE FUNCTION public.cleanup_room_sessions(room_id_param INTEGER)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Start a transaction
  BEGIN
    -- First, end all active sessions for this room
    UPDATE public.room_sessions
    SET 
      status = 'completed',
      ended_at = CURRENT_TIMESTAMP,
      logging_enabled = false,
      duration_minutes = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - started_at)) / 60
    WHERE room_id = room_id_param 
      AND status = 'active';

    -- Then update the room status to empty
    UPDATE public.rooms
    SET 
      status = 'empty',
      updated_at = CURRENT_TIMESTAMP
    WHERE id = room_id_param;

    -- Log the cleanup action
    RAISE NOTICE 'Cleaned up room % - ended active sessions and set status to empty', room_id_param;

  EXCEPTION
    WHEN OTHERS THEN
      -- If any error occurs, log it and re-raise
      RAISE NOTICE 'Error cleaning up room %: %', room_id_param, SQLERRM;
      RAISE;
  END;
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION public.cleanup_room_sessions(INTEGER) TO authenticated;

-- Add comment
COMMENT ON FUNCTION public.cleanup_room_sessions(INTEGER) IS 'Safely cleanup all active sessions for a room and set room status to empty';


================================================
FILE: supabase/migrations/20250116_fix_cleanup_parameter_mismatch.sql
================================================
-- Fix cleanup_session_idempotent to accept both parameter naming conventions
-- This fixes the parameter mismatch between backend (p_session_id) and the function (session_id_param)

-- First add the missing last_heartbeat column if it doesn't exist
ALTER TABLE room_sessions 
ADD COLUMN IF NOT EXISTS last_heartbeat TIMESTAMPTZ DEFAULT NOW();

-- Add index for heartbeat queries
CREATE INDEX IF NOT EXISTS idx_room_sessions_heartbeat 
ON room_sessions(last_heartbeat) 
WHERE status = 'active';

-- Drop the old function first (cascade to drop dependencies)
DROP FUNCTION IF EXISTS public.cleanup_session_idempotent CASCADE;

-- Create improved version that accepts both parameter styles
CREATE OR REPLACE FUNCTION public.cleanup_session_idempotent(
  -- Accept both naming conventions for maximum compatibility
  session_id_param UUID DEFAULT NULL,
  p_session_id UUID DEFAULT NULL,
  cleanup_source TEXT DEFAULT NULL,
  p_source TEXT DEFAULT NULL,
  cleanup_timestamp TIMESTAMPTZ DEFAULT NULL,
  p_cleanup_timestamp TIMESTAMPTZ DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  v_session_id UUID;
  v_source TEXT;
  v_timestamp TIMESTAMPTZ;
  session_record room_sessions%ROWTYPE;
  lock_key BIGINT;
  v_active_count INTEGER;
  result JSONB;
BEGIN
  -- Normalize parameters - accept both naming conventions
  v_session_id := COALESCE(session_id_param, p_session_id);
  v_source := COALESCE(cleanup_source, p_source, 'unknown');
  v_timestamp := COALESCE(cleanup_timestamp, p_cleanup_timestamp, NOW());
  
  -- Validate we have a session ID
  IF v_session_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'no_session_id',
      'error', 'No session ID provided'
    );
  END IF;
  
  -- Generate a unique lock key based on session ID
  lock_key := ('x' || substr(md5(v_session_id::text), 1, 16))::bit(64)::bigint;
  
  -- Try to acquire advisory lock (non-blocking)
  IF NOT pg_try_advisory_xact_lock(lock_key) THEN
    -- Another process is already handling this session
    RAISE NOTICE 'Session % cleanup already in progress', v_session_id;
    
    -- Return current state without modifications
    SELECT to_jsonb(rs.*) INTO result
    FROM room_sessions rs
    WHERE rs.id = v_session_id;
    
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'cleanup_in_progress',
      'session', result
    );
  END IF;
  
  -- Fetch current session state
  SELECT * INTO session_record
  FROM room_sessions
  WHERE id = v_session_id;
  
  IF NOT FOUND THEN
    RAISE NOTICE 'Session % not found', v_session_id;
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'session_not_found',
      'session', NULL
    );
  END IF;
  
  -- Check if already completed
  IF session_record.status = 'completed' THEN
    RAISE NOTICE 'Session % already completed at %', v_session_id, session_record.ended_at;
    
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_completed',
      'session', to_jsonb(session_record)
    );
  END IF;
  
  -- Perform the cleanup
  UPDATE room_sessions
  SET 
    status = 'completed',
    ended_at = COALESCE(ended_at, v_timestamp),
    cleanup_source = COALESCE(room_sessions.cleanup_source, v_source),
    cleanup_initiated_at = COALESCE(cleanup_initiated_at, v_timestamp),
    cleanup_attempts = COALESCE(cleanup_attempts, 0) + 1,
    updated_at = v_timestamp
  WHERE 
    id = v_session_id 
    AND status = 'active'
  RETURNING * INTO session_record;
  
  -- If no rows updated, session might have been completed by another process
  IF session_record.id IS NULL THEN
    -- Fetch the current state
    SELECT * INTO session_record
    FROM room_sessions
    WHERE id = v_session_id;
    
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_completed_race',
      'session', to_jsonb(session_record)
    );
  END IF;
  
  -- Update room status if no other active sessions
  IF session_record.room_id IS NOT NULL THEN
    -- Count remaining active sessions for this room
    SELECT COUNT(*) INTO v_active_count
    FROM room_sessions
    WHERE room_id = session_record.room_id
    AND status = 'active'
    AND id != v_session_id;
    
    -- If no other active sessions, update room status
    IF v_active_count = 0 THEN
      UPDATE rooms
      SET 
        status = 'empty',
        updated_at = v_timestamp
      WHERE 
        id = session_record.room_id
        AND status != 'empty';
      
      RAISE NOTICE 'Room % set to empty status', session_record.room_id;
    END IF;
  END IF;
  
  -- Log the cleanup event if system_logs table exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'system_logs') THEN
    INSERT INTO system_logs (
      event_type,
      event_data,
      created_at
    ) VALUES (
      'session_cleanup',
      jsonb_build_object(
        'session_id', v_session_id,
        'cleanup_source', v_source,
        'room_id', session_record.room_id,
        'mosque_id', session_record.mosque_id,
        'transcript_count', session_record.transcript_count
      ),
      v_timestamp
    );
  END IF;
  
  RAISE NOTICE 'Session % cleaned up successfully by %', v_session_id, v_source;
  
  RETURN jsonb_build_object(
    'success', true,
    'reason', 'cleanup_completed',
    'session', to_jsonb(session_record)
  );
  
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail
    RAISE WARNING 'Error in cleanup_session_idempotent: %', SQLERRM;
    
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'error',
      'error', SQLERRM,
      'session', to_jsonb(session_record)
    );
END;
$$;

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO anon;

-- Add helpful comment
COMMENT ON FUNCTION cleanup_session_idempotent IS 
'Idempotent session cleanup function that accepts both parameter naming conventions.
Supports both original names (session_id_param, cleanup_source) and backend names (p_session_id, p_source).
Returns consistent results regardless of concurrent calls.

Usage examples:
- Original: SELECT cleanup_session_idempotent(session_id_param := ''uuid'', cleanup_source := ''user'')
- Backend: SELECT cleanup_session_idempotent(p_session_id := ''uuid'', p_source := ''agent_disconnect'')
- Mixed: Both parameter styles work';

-- Create auto-cleanup function for reconnections
CREATE OR REPLACE FUNCTION public.auto_cleanup_active_sessions_on_reconnect()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  v_existing_session room_sessions%ROWTYPE;
BEGIN
  -- Only run on INSERT of new active sessions
  IF NEW.status = 'active' THEN
    -- Find any existing active sessions for the same room
    FOR v_existing_session IN 
      SELECT * FROM room_sessions
      WHERE room_id = NEW.room_id
      AND status = 'active'
      AND id != NEW.id
    LOOP
      -- Clean up the existing session
      RAISE NOTICE 'Auto-cleaning ghost session % for room %', v_existing_session.id, NEW.room_id;
      
      UPDATE room_sessions
      SET 
        status = 'completed',
        ended_at = COALESCE(ended_at, NOW()),
        cleanup_source = 'auto_reconnect_cleanup',
        cleanup_initiated_at = NOW(),
        updated_at = NOW()
      WHERE id = v_existing_session.id;
    END LOOP;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Create trigger for auto-cleanup on reconnection
DROP TRIGGER IF EXISTS auto_cleanup_on_reconnect ON room_sessions;
CREATE TRIGGER auto_cleanup_on_reconnect
  AFTER INSERT ON room_sessions
  FOR EACH ROW
  EXECUTE FUNCTION auto_cleanup_active_sessions_on_reconnect();

-- Create function to clean up sessions with no heartbeat
CREATE OR REPLACE FUNCTION public.cleanup_stale_sessions()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  v_count INTEGER := 0;
  v_session room_sessions%ROWTYPE;
  v_timeout_minutes INTEGER := 5; -- Sessions without heartbeat for 5 minutes are considered stale
BEGIN
  -- Find and clean up stale sessions
  FOR v_session IN
    SELECT * FROM room_sessions
    WHERE status = 'active'
    AND (
      last_heartbeat IS NULL AND created_at < NOW() - INTERVAL '5 minutes'
      OR 
      last_heartbeat < NOW() - INTERVAL '5 minutes'
    )
  LOOP
    -- Use our improved cleanup function
    PERFORM cleanup_session_idempotent(
      p_session_id := v_session.id,
      p_source := 'heartbeat_timeout'
    );
    v_count := v_count + 1;
    
    RAISE NOTICE 'Cleaned up stale session % (last heartbeat: %)', 
      v_session.id, 
      COALESCE(v_session.last_heartbeat::text, 'never');
  END LOOP;
  
  RETURN v_count;
END;
$$;

-- Grant execute permission for the cleanup function
GRANT EXECUTE ON FUNCTION cleanup_stale_sessions TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_stale_sessions TO service_role;

-- Add comment
COMMENT ON FUNCTION cleanup_stale_sessions IS 
'Cleans up sessions that have not sent a heartbeat in the last 5 minutes.
Can be called periodically via cron job or manually.
Returns the number of sessions cleaned up.';

-- Create an index to improve cleanup performance
CREATE INDEX IF NOT EXISTS idx_room_sessions_active_heartbeat 
ON room_sessions(status, last_heartbeat) 
WHERE status = 'active';

-- Fix any existing ghost sessions immediately
DO $$
DECLARE
  v_cleaned INTEGER;
BEGIN
  -- Clean up any stale sessions right now
  v_cleaned := cleanup_stale_sessions();
  IF v_cleaned > 0 THEN
    RAISE NOTICE 'Cleaned up % stale sessions during migration', v_cleaned;
  END IF;
  
  -- Also clean up any duplicate active sessions per room
  WITH ranked_sessions AS (
    SELECT 
      id,
      room_id,
      ROW_NUMBER() OVER (PARTITION BY room_id ORDER BY created_at DESC) as rn
    FROM room_sessions
    WHERE status = 'active'
  )
  UPDATE room_sessions
  SET 
    status = 'completed',
    ended_at = NOW(),
    cleanup_source = 'migration_duplicate_cleanup',
    updated_at = NOW()
  WHERE id IN (
    SELECT id FROM ranked_sessions WHERE rn > 1
  );
END $$;


================================================
FILE: supabase/migrations/20250116_fix_cleanup_parameter_mismatch_simple.sql
================================================
-- Fix cleanup_session_idempotent to accept both parameter naming conventions
-- This fixes the parameter mismatch between backend (p_session_id) and the function (session_id_param)
-- Backend sends: p_session_id, p_source
-- Function expects: session_id_param, cleanup_source

-- Drop the old function first (cascade to drop dependencies)
DROP FUNCTION IF EXISTS public.cleanup_session_idempotent CASCADE;

-- Create improved version that accepts both parameter styles
CREATE OR REPLACE FUNCTION public.cleanup_session_idempotent(
  -- Accept both naming conventions for maximum compatibility
  session_id_param UUID DEFAULT NULL,
  p_session_id UUID DEFAULT NULL,
  cleanup_source TEXT DEFAULT NULL,
  p_source TEXT DEFAULT NULL,
  cleanup_timestamp TIMESTAMPTZ DEFAULT NULL,
  p_cleanup_timestamp TIMESTAMPTZ DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  v_session_id UUID;
  v_source TEXT;
  v_timestamp TIMESTAMPTZ;
  session_record room_sessions%ROWTYPE;
  lock_key BIGINT;
  v_active_count INTEGER;
  result JSONB;
BEGIN
  -- Normalize parameters - accept both naming conventions
  v_session_id := COALESCE(session_id_param, p_session_id);
  v_source := COALESCE(cleanup_source, p_source, 'unknown');
  v_timestamp := COALESCE(cleanup_timestamp, p_cleanup_timestamp, NOW());
  
  -- Validate we have a session ID
  IF v_session_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'no_session_id',
      'error', 'No session ID provided'
    );
  END IF;
  
  -- Generate a unique lock key based on session ID
  lock_key := ('x' || substr(md5(v_session_id::text), 1, 16))::bit(64)::bigint;
  
  -- Try to acquire advisory lock (non-blocking)
  IF NOT pg_try_advisory_xact_lock(lock_key) THEN
    -- Another process is already handling this session
    RAISE NOTICE 'Session % cleanup already in progress', v_session_id;
    
    -- Return current state without modifications
    SELECT to_jsonb(rs.*) INTO result
    FROM room_sessions rs
    WHERE rs.id = v_session_id;
    
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'cleanup_in_progress',
      'session', result
    );
  END IF;
  
  -- Fetch current session state
  SELECT * INTO session_record
  FROM room_sessions
  WHERE id = v_session_id;
  
  IF NOT FOUND THEN
    RAISE NOTICE 'Session % not found', v_session_id;
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'session_not_found',
      'session', NULL
    );
  END IF;
  
  -- Check if already completed
  IF session_record.status = 'completed' THEN
    RAISE NOTICE 'Session % already completed at %', v_session_id, session_record.ended_at;
    
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_completed',
      'session', to_jsonb(session_record)
    );
  END IF;
  
  -- Perform the cleanup
  UPDATE room_sessions
  SET 
    status = 'completed',
    ended_at = COALESCE(ended_at, v_timestamp),
    cleanup_source = COALESCE(room_sessions.cleanup_source, v_source),
    cleanup_initiated_at = COALESCE(cleanup_initiated_at, v_timestamp),
    cleanup_attempts = COALESCE(cleanup_attempts, 0) + 1,
    updated_at = v_timestamp
  WHERE 
    id = v_session_id 
    AND status = 'active'
  RETURNING * INTO session_record;
  
  -- If no rows updated, session might have been completed by another process
  IF session_record.id IS NULL THEN
    -- Fetch the current state
    SELECT * INTO session_record
    FROM room_sessions
    WHERE id = v_session_id;
    
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_completed_race',
      'session', to_jsonb(session_record)
    );
  END IF;
  
  -- Update room status if no other active sessions
  IF session_record.room_id IS NOT NULL THEN
    -- Count remaining active sessions for this room
    SELECT COUNT(*) INTO v_active_count
    FROM room_sessions
    WHERE room_id = session_record.room_id
    AND status = 'active'
    AND id != v_session_id;
    
    -- If no other active sessions, update room status
    IF v_active_count = 0 THEN
      UPDATE rooms
      SET 
        status = 'empty',
        updated_at = v_timestamp
      WHERE 
        id = session_record.room_id
        AND status != 'empty';
      
      RAISE NOTICE 'Room % set to empty status', session_record.room_id;
    END IF;
  END IF;
  
  -- Log the cleanup event if system_logs table exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'system_logs') THEN
    INSERT INTO system_logs (
      event_type,
      event_data,
      created_at
    ) VALUES (
      'session_cleanup',
      jsonb_build_object(
        'session_id', v_session_id,
        'cleanup_source', v_source,
        'room_id', session_record.room_id,
        'mosque_id', session_record.mosque_id,
        'transcript_count', session_record.transcript_count
      ),
      v_timestamp
    );
  END IF;
  
  RAISE NOTICE 'Session % cleaned up successfully by %', v_session_id, v_source;
  
  RETURN jsonb_build_object(
    'success', true,
    'reason', 'cleanup_completed',
    'session', to_jsonb(session_record)
  );
  
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail
    RAISE WARNING 'Error in cleanup_session_idempotent: %', SQLERRM;
    
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'error',
      'error', SQLERRM,
      'session', to_jsonb(session_record)
    );
END;
$$;

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO anon;

-- Add helpful comment
COMMENT ON FUNCTION cleanup_session_idempotent IS 
'Idempotent session cleanup function that accepts both parameter naming conventions.
Supports both original names (session_id_param, cleanup_source) and backend names (p_session_id, p_source).
Returns consistent results regardless of concurrent calls.

Usage examples:
- Original: SELECT cleanup_session_idempotent(session_id_param := ''uuid'', cleanup_source := ''user'')
- Backend: SELECT cleanup_session_idempotent(p_session_id := ''uuid'', p_source := ''agent_disconnect'')
- Mixed: Both parameter styles work';


================================================
FILE: supabase/migrations/20250117180000_fix_prompt_template_structure.sql
================================================
-- Fix the get_room_prompt_template function to return the structure expected by the backend
-- The backend expects: prompt_template, template_variables (as JSON), and name

-- Drop the existing function
DROP FUNCTION IF EXISTS public.get_room_prompt_template(BIGINT);

-- Create the new function that matches backend expectations
CREATE OR REPLACE FUNCTION public.get_room_prompt_template(room_id BIGINT)
RETURNS TABLE(
    prompt_template TEXT,
    template_variables JSONB,
    name TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        -- Get the prompt template or use a default one
        COALESCE(
            pt.prompt_template,
            'You are an expert simultaneous interpreter. Your task is to translate from {source_lang} to {target_lang}. Provide a direct and accurate translation of the user''s input. Be concise and use natural-sounding language. Do not add any additional commentary, explanations, or introductory phrases.'
        ) as prompt_template,
        -- Get template variables or construct them from room data
        COALESCE(
            pt.template_variables,
            jsonb_build_object(
                'source_lang', r.transcription_language,
                'target_lang', r.translation__language,
                'dialect', COALESCE(r.transcription_language, 'Arabic'),
                'context_instructions', 'Maintain cultural sensitivity and preserve key religious terms where appropriate.',
                'style', 'formal',
                'preserve_terms', ARRAY['Allah', 'Salah', 'Zakat', 'Hajj', 'Ummah', 'Sunnah'],
                'audience', 'general congregation',
                'tone', 'reverent'
            )
        ) as template_variables,
        -- Get the template name or provide a default
        COALESCE(
            pt.name,
            'Default Translation Template'
        ) as name
    FROM rooms r
    LEFT JOIN prompt_templates pt ON r.prompt_template_id = pt.id AND pt.is_active = true
    WHERE r.id = room_id;
    
    -- If no room found, return NULL
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            NULL::TEXT as prompt_template,
            NULL::JSONB as template_variables,
            NULL::TEXT as name;
    END IF;
END;
$$;

-- Grant appropriate permissions
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO anon;

-- Add a comment to document the function
COMMENT ON FUNCTION public.get_room_prompt_template(BIGINT) IS 
'Returns the prompt template, template variables, and name for a given room. Used by the transcription backend to build translation prompts with proper variable substitution.';

-- Create a test to verify the function works
DO $$
DECLARE
    test_result RECORD;
BEGIN
    -- Test with a sample room ID (you can adjust this)
    SELECT * INTO test_result FROM get_room_prompt_template(1);
    
    -- Verify the structure
    IF test_result IS NOT NULL THEN
        RAISE NOTICE 'Function test passed. Structure includes:';
        RAISE NOTICE 'prompt_template: %', test_result.prompt_template IS NOT NULL;
        RAISE NOTICE 'template_variables: %', test_result.template_variables IS NOT NULL;
        RAISE NOTICE 'name: %', test_result.name IS NOT NULL;
    END IF;
END $$;


================================================
FILE: supabase/migrations/20250117_dashboard_improvements.sql
================================================
-- Add missing fields to users table
ALTER TABLE public.users
ADD COLUMN IF NOT EXISTS full_name TEXT,
ADD COLUMN IF NOT EXISTS email TEXT,
ADD COLUMN IF NOT EXISTS "Role" TEXT DEFAULT 'User',
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS avatar_url TEXT,
ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();

-- Add missing fields to Mosque table
ALTER TABLE public."Mosque"
ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_mosque_id ON public.users(mosque_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_role ON public.users("Role");
CREATE INDEX IF NOT EXISTS idx_mosque_subdomain ON public."Mosque"("Subdomain");

-- Create a function to sync user data from auth.users
CREATE OR REPLACE FUNCTION public.sync_user_data()
RETURNS TRIGGER AS $$
BEGIN
  -- Update email from auth.users if it exists
  UPDATE public.users
  SET 
    email = auth.users.email,
    updated_at = NOW()
  FROM auth.users
  WHERE public.users.id = auth.users.id
  AND public.users.id = NEW.id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to sync email on user insert/update
DROP TRIGGER IF EXISTS sync_user_data_trigger ON public.users;
CREATE TRIGGER sync_user_data_trigger
AFTER INSERT OR UPDATE ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.sync_user_data();

-- Update existing users with email from auth.users
UPDATE public.users u
SET 
  email = au.email,
  created_at = COALESCE(u.created_at, au.created_at),
  updated_at = NOW()
FROM auth.users au
WHERE u.id = au.id;

-- Add RLS policies for the new fields
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."Mosque" ENABLE ROW LEVEL SECURITY;

-- Policy for users to read their own data
CREATE POLICY "Users can view own profile" ON public.users
  FOR SELECT USING (auth.uid() = id);

-- Policy for admins to view all users in their mosque
CREATE POLICY "Admins can view mosque users" ON public.users
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.users admin
      WHERE admin.id = auth.uid()
      AND admin."Role" = 'Admin'
      AND admin.mosque_id = users.mosque_id
    )
  );

-- Policy for super admins to view all users
CREATE POLICY "Super admins can view all users" ON public.users
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.users su
      WHERE su.id = auth.uid()
      AND su.is_super_admin = true
    )
  );

-- Policy for super admins to update users
CREATE POLICY "Super admins can update users" ON public.users
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.users su
      WHERE su.id = auth.uid()
      AND su.is_super_admin = true
    )
  );

-- Policy for super admins to delete users
CREATE POLICY "Super admins can delete users" ON public.users
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM public.users su
      WHERE su.id = auth.uid()
      AND su.is_super_admin = true
    )
  );

-- Mosque policies
CREATE POLICY "Anyone can view mosques" ON public."Mosque"
  FOR SELECT USING (true);

CREATE POLICY "Super admins can manage mosques" ON public."Mosque"
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE users.id = auth.uid()
      AND users.is_super_admin = true
    )
  );

-- Add comment for documentation
COMMENT ON COLUMN public.users."Role" IS 'User role: User, Admin, or Super Admin (use is_super_admin flag for super admins)';
COMMENT ON COLUMN public.users.full_name IS 'User full name for display purposes';
COMMENT ON COLUMN public.users.email IS 'Synced from auth.users.email';
COMMENT ON COLUMN public.users.is_active IS 'Whether the user account is active';
COMMENT ON COLUMN public."Mosque".is_active IS 'Whether the mosque is active';


================================================
FILE: supabase/migrations/20250117_fix_get_room_prompt_template.sql
================================================
-- Fix the get_room_prompt_template function to match what the backend expects
-- The backend is looking for a simpler function that returns prompt-related data

-- First, let's drop the existing function
DROP FUNCTION IF EXISTS get_room_prompt_template(INTEGER);

-- Create the new function with the expected signature
CREATE OR REPLACE FUNCTION public.get_room_prompt_template(room_id BIGINT)
RETURNS TABLE(
    prompt_template TEXT,
    source_language TEXT,
    target_language TEXT,
    context_instructions TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        -- Get the prompt template or use a default one
        COALESCE(
            pt.prompt_template,
            'You are an expert simultaneous interpreter. Your task is to translate from Arabic to {target_lang}. Provide a direct and accurate translation of the user''s input. Be concise and use natural-sounding language. Do not add any additional commentary, explanations, or introductory phrases.'
        ) as prompt_template,
        r.transcription_language as source_language,
        r.translation__language as target_language,
        -- Get context instructions from template variables or provide default
        COALESCE(
            pt.template_variables->>'context_instructions',
            'Maintain cultural sensitivity and preserve key religious terms where appropriate.'
        ) as context_instructions
    FROM rooms r
    LEFT JOIN prompt_templates pt ON r.prompt_template_id = pt.id AND pt.is_active = true
    WHERE r.id = room_id;
    
    -- If no room found, return NULL
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            NULL::TEXT as prompt_template,
            NULL::TEXT as source_language,
            NULL::TEXT as target_language,
            NULL::TEXT as context_instructions;
    END IF;
END;
$$;

-- Grant appropriate permissions
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO anon;

-- Add a comment to document the function
COMMENT ON FUNCTION public.get_room_prompt_template(BIGINT) IS 
'Returns the prompt template and language configuration for a given room. Used by the transcription backend to customize translation prompts.';


================================================
FILE: supabase/migrations/20250117_populate_existing_users.sql
================================================
-- Populate existing users with default values and sync data from auth.users
-- This migration should run after 20250117_dashboard_improvements.sql

-- Update existing users with email from auth.users
UPDATE public.users u
SET 
  email = COALESCE(u.email, au.email),
  full_name = COALESCE(u.full_name, au.raw_user_meta_data->>'full_name', au.email),
  created_at = COALESCE(u.created_at, au.created_at),
  updated_at = NOW()
FROM auth.users au
WHERE u.id = au.id
AND (u.email IS NULL OR u.full_name IS NULL);

-- Set default Role for users without one
UPDATE public.users
SET "Role" = 'User'
WHERE "Role" IS NULL;

-- Set default is_active status
UPDATE public.users
SET is_active = true
WHERE is_active IS NULL;

-- Update super admins to have Admin role (they use is_super_admin flag)
UPDATE public.users
SET "Role" = 'Admin'
WHERE is_super_admin = true;

-- Set created_at for users that don't have it
UPDATE public.users
SET created_at = NOW()
WHERE created_at IS NULL;

-- Set updated_at for all users
UPDATE public.users
SET updated_at = NOW()
WHERE updated_at IS NULL;

-- Update Mosque records with default timestamps
UPDATE public."Mosque"
SET 
  created_at = COALESCE(created_at, NOW()),
  updated_at = COALESCE(updated_at, NOW()),
  is_active = COALESCE(is_active, true);

-- Create a trigger to auto-update the updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply the trigger to users table
DROP TRIGGER IF EXISTS set_users_updated_at ON public.users;
CREATE TRIGGER set_users_updated_at
BEFORE UPDATE ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Apply the trigger to Mosque table
DROP TRIGGER IF EXISTS set_mosque_updated_at ON public."Mosque";
CREATE TRIGGER set_mosque_updated_at
BEFORE UPDATE ON public."Mosque"
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Add some helpful comments
COMMENT ON FUNCTION public.handle_updated_at() IS 'Updates the updated_at timestamp on row update';
COMMENT ON TRIGGER set_users_updated_at ON public.users IS 'Auto-updates the updated_at timestamp when user record is modified';
COMMENT ON TRIGGER set_mosque_updated_at ON public."Mosque" IS 'Auto-updates the updated_at timestamp when mosque record is modified';


================================================
FILE: supabase/migrations/20250117_stale_session_cleanup.sql
================================================
-- Stale Session Cleanup using existing columns
-- Uses updated_at which gets updated by the transcript trigger

-- Function to cleanup stale sessions (no transcripts for 25+ minutes)
CREATE OR REPLACE FUNCTION cleanup_stale_sessions_by_transcript_activity()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_session RECORD;
  v_count INTEGER := 0;
BEGIN
  -- Find active sessions with no recent transcript activity
  -- updated_at gets updated by the transcript trigger when new transcripts arrive
  FOR v_session IN 
    SELECT 
      id, 
      room_id,
      updated_at,
      transcript_count,
      started_at
    FROM room_sessions
    WHERE status = 'active'
      AND updated_at < NOW() - INTERVAL '25 minutes'  -- No updates (including transcripts) for 25 minutes
      AND started_at < NOW() - INTERVAL '25 minutes'  -- Session has been running for at least 25 minutes
  LOOP
    -- Log the cleanup
    RAISE NOTICE 'Cleaning up stale session % (room_id: %, last_updated: %, transcript_count: %)', 
      v_session.id, 
      v_session.room_id,
      v_session.updated_at,
      v_session.transcript_count;
    
    -- Mark session as ended
    UPDATE room_sessions
    SET 
      status = 'ended',
      ended_at = NOW(),
      updated_at = NOW(),
      cleanup_reason = 'stale_no_transcripts'
    WHERE id = v_session.id;
    
    -- Update room status if this was the active session
    UPDATE rooms
    SET status = 'inactive'
    WHERE id = v_session.room_id
      AND status = 'active';
    
    v_count := v_count + 1;
  END LOOP;
  
  IF v_count > 0 THEN
    RAISE NOTICE 'Cleaned up % stale sessions', v_count;
  END IF;
  
  RETURN v_count;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION cleanup_stale_sessions_by_transcript_activity TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_stale_sessions_by_transcript_activity TO postgres;

-- Create Supabase Cron job to run every 5 minutes
-- This uses pg_cron extension which must be enabled in Supabase
SELECT cron.schedule(
  'cleanup-stale-sessions',           -- Job name
  '*/5 * * * *',                      -- Every 5 minutes
  $$SELECT cleanup_stale_sessions_by_transcript_activity();$$
);

-- To verify the job was created:
-- SELECT * FROM cron.job WHERE jobname = 'cleanup-stale-sessions';

-- To manually test the function:
-- SELECT cleanup_stale_sessions_by_transcript_activity();

-- To unschedule if needed:
-- SELECT cron.unschedule('cleanup-stale-sessions');


================================================
FILE: supabase/migrations/20250123_idempotent_session_cleanup.sql
================================================
-- Add cleanup tracking columns to room_sessions
ALTER TABLE room_sessions 
ADD COLUMN IF NOT EXISTS cleanup_source TEXT,
ADD COLUMN IF NOT EXISTS cleanup_initiated_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS cleanup_attempts INTEGER DEFAULT 0;

-- Create idempotent cleanup function with advisory locking
CREATE OR REPLACE FUNCTION cleanup_session_idempotent(
  session_id_param UUID,
  cleanup_source TEXT DEFAULT 'unknown',
  cleanup_timestamp TIMESTAMPTZ DEFAULT NOW()
) RETURNS JSONB AS $$
DECLARE
  result JSONB;
  session_record room_sessions%ROWTYPE;
  lock_key BIGINT;
BEGIN
  -- Generate a unique lock key based on session ID
  lock_key := ('x' || substr(md5(session_id_param::text), 1, 16))::bit(64)::bigint;
  
  -- Try to acquire advisory lock (non-blocking)
  IF NOT pg_try_advisory_xact_lock(lock_key) THEN
    -- Another process is already handling this session
    RAISE NOTICE 'Session % cleanup already in progress', session_id_param;
    
    -- Return current state without modifications
    SELECT to_jsonb(rs.*) INTO result
    FROM room_sessions rs
    WHERE rs.id = session_id_param;
    
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'cleanup_in_progress',
      'session', result
    );
  END IF;
  
  -- Fetch current session state
  SELECT * INTO session_record
  FROM room_sessions
  WHERE id = session_id_param;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'session_not_found',
      'session', NULL
    );
  END IF;
  
  -- Check if already completed
  IF session_record.status = 'completed' THEN
    RAISE NOTICE 'Session % already completed at %', session_id_param, session_record.ended_at;
    
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_completed',
      'session', to_jsonb(session_record)
    );
  END IF;
  
  -- Perform the cleanup
  UPDATE room_sessions
  SET 
    status = 'completed',
    ended_at = COALESCE(ended_at, cleanup_timestamp),
    cleanup_source = COALESCE(room_sessions.cleanup_source, cleanup_session_idempotent.cleanup_source),
    cleanup_initiated_at = COALESCE(cleanup_initiated_at, cleanup_timestamp),
    cleanup_attempts = cleanup_attempts + 1,
    updated_at = cleanup_timestamp
  WHERE 
    id = session_id_param 
    AND status = 'active'
  RETURNING * INTO session_record;
  
  -- Update room status if no other active sessions
  IF session_record.id IS NOT NULL THEN
    PERFORM update_room_status_after_session_end(session_record.room_id);
  END IF;
  
  -- Log the cleanup event
  INSERT INTO system_logs (
    event_type,
    event_data,
    created_at
  ) VALUES (
    'session_cleanup',
    jsonb_build_object(
      'session_id', session_id_param,
      'cleanup_source', cleanup_source,
      'room_id', session_record.room_id,
      'mosque_id', session_record.mosque_id,
      'transcript_count', session_record.transcript_count
    ),
    cleanup_timestamp
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'reason', 'cleanup_completed',
    'session', to_jsonb(session_record)
  );
  
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail
    RAISE WARNING 'Error in cleanup_session_idempotent: %', SQLERRM;
    
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'error',
      'error', SQLERRM,
      'session', to_jsonb(session_record)
    );
END;
$$ LANGUAGE plpgsql;

-- Helper function to update room status
CREATE OR REPLACE FUNCTION update_room_status_after_session_end(
  room_id_param INTEGER
) RETURNS VOID AS $$
BEGIN
  -- Check if any other active sessions exist
  IF NOT EXISTS (
    SELECT 1 
    FROM room_sessions 
    WHERE room_id = room_id_param 
    AND status = 'active'
  ) THEN
    -- No active sessions, set room to empty
    UPDATE rooms
    SET 
      status = 'empty',
      updated_at = NOW()
    WHERE 
      id = room_id_param
      AND status != 'empty';
      
    RAISE NOTICE 'Room % set to empty status', room_id_param;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Create system_logs table if it doesn't exist
CREATE TABLE IF NOT EXISTS system_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type TEXT NOT NULL,
  event_data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for performance
CREATE INDEX IF NOT EXISTS idx_system_logs_event_type_created 
ON system_logs(event_type, created_at DESC);

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_session_idempotent TO service_role;
GRANT EXECUTE ON FUNCTION update_room_status_after_session_end TO authenticated;
GRANT EXECUTE ON FUNCTION update_room_status_after_session_end TO service_role;

-- Add comment for documentation
COMMENT ON FUNCTION cleanup_session_idempotent IS 
'Idempotent session cleanup function that prevents race conditions using advisory locks. 
Returns consistent results regardless of concurrent calls.
Usage: SELECT cleanup_session_idempotent(session_id, source, timestamp);';


================================================
FILE: supabase/migrations/20250127_add_context_window_size.sql
================================================
-- Add context_window_size column to rooms table
ALTER TABLE rooms 
ADD COLUMN context_window_size integer DEFAULT 6 CHECK (context_window_size >= 3 AND context_window_size <= 20);

-- Add comment for documentation
COMMENT ON COLUMN rooms.context_window_size IS 'Number of sentence pairs to maintain in the translation context window (3-20)';

-- Update existing rooms to have the default value explicitly set
UPDATE rooms SET context_window_size = 6 WHERE context_window_size IS NULL;


================================================
FILE: supabase/migrations/20250128_add_sentence_context_to_transcripts.sql
================================================
-- Add sentence context columns to transcripts table for better session replay quality
-- This allows session history to match the quality of live monitoring

-- Add sentence_id column to track which segments belong to the same sentence
ALTER TABLE transcripts 
ADD COLUMN IF NOT EXISTS sentence_id UUID;

-- Add is_complete flag to identify authoritative complete sentences
ALTER TABLE transcripts 
ADD COLUMN IF NOT EXISTS is_complete BOOLEAN DEFAULT false;

-- Add is_fragment flag to identify partial sentence segments
ALTER TABLE transcripts 
ADD COLUMN IF NOT EXISTS is_fragment BOOLEAN DEFAULT true;

-- Add index on sentence_id for efficient grouping during replay
CREATE INDEX IF NOT EXISTS idx_transcripts_sentence_id 
ON transcripts(sentence_id) 
WHERE sentence_id IS NOT NULL;

-- Add index on session_id and sentence_id for efficient querying
CREATE INDEX IF NOT EXISTS idx_transcripts_session_sentence 
ON transcripts(session_id, sentence_id) 
WHERE sentence_id IS NOT NULL;

-- Add comment explaining the columns
COMMENT ON COLUMN transcripts.sentence_id IS 'UUID linking transcript segments that belong to the same sentence';
COMMENT ON COLUMN transcripts.is_complete IS 'True when this segment contains the final, authoritative version of a complete sentence';
COMMENT ON COLUMN transcripts.is_fragment IS 'True when this segment is a partial fragment of a sentence being built';


================================================
FILE: supabase/migrations/20250128_add_speechmatics_domain.sql
================================================
-- Add speechmatics_domain column to rooms table for domain-specific transcription models
ALTER TABLE public.rooms 
ADD COLUMN IF NOT EXISTS speechmatics_domain VARCHAR(50) DEFAULT 'broadcast';

-- Add comment for documentation
COMMENT ON COLUMN public.rooms.speechmatics_domain IS 'Speechmatics domain model for optimized transcription (broadcast, conversational, general)';


================================================
FILE: supabase/migrations/20250128_drop_problematic_functions.sql
================================================
-- DROP PROBLEMATIC FUNCTIONS BLOCKING GO-LIVE
-- These functions have CTE reference bugs that cause "relation 'cleaned' does not exist" errors

-- Drop the problematic ghost session functions
DROP FUNCTION IF EXISTS ensure_room_session_atomic CASCADE;
DROP FUNCTION IF EXISTS cleanup_ghost_sessions CASCADE;
DROP FUNCTION IF EXISTS recover_or_cleanup_session CASCADE;

-- Drop any other functions that might depend on these
DROP FUNCTION IF EXISTS monitor_session_health CASCADE;
DROP FUNCTION IF EXISTS force_cleanup_stale_sessions CASCADE;

-- Recreate a simple working version of recover_or_cleanup_session that the frontend expects
CREATE OR REPLACE FUNCTION recover_or_cleanup_session(
    room_id_param INTEGER,
    user_id_param UUID DEFAULT NULL
) RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
    v_session_id UUID;
    v_existing_session RECORD;
BEGIN
    -- Clean up any stale sessions for this room
    UPDATE room_sessions
    SET status = 'completed',
        ended_at = CURRENT_TIMESTAMP,
        cleanup_source = 'recover_function',
        updated_at = CURRENT_TIMESTAMP
    WHERE room_id = room_id_param
      AND status = 'active'
      AND (
          last_active < CURRENT_TIMESTAMP - INTERVAL '15 minutes'
          OR started_at < CURRENT_TIMESTAMP - INTERVAL '2 hours'
      );
    
    -- Check for existing active session
    SELECT * INTO v_existing_session
    FROM room_sessions
    WHERE room_id = room_id_param
      AND status = 'active'
      AND last_active > CURRENT_TIMESTAMP - INTERVAL '15 minutes'
    ORDER BY started_at DESC
    LIMIT 1;
    
    -- If we have a valid session, return it
    IF v_existing_session.id IS NOT NULL THEN
        -- Update last_active to keep it fresh
        UPDATE room_sessions
        SET last_active = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = v_existing_session.id;
        
        RETURN v_existing_session.id;
    END IF;
    
    -- No valid session found, create a new one
    v_session_id := gen_random_uuid();
    
    -- Get mosque_id from the room and create session
    INSERT INTO room_sessions (
        id,
        room_id,
        mosque_id,
        status,
        started_at,
        last_active,
        source,
        updated_at
    )
    SELECT 
        v_session_id,
        room_id_param,
        r.mosque_id,
        'active',
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        'frontend_recovery',
        CURRENT_TIMESTAMP
    FROM rooms r
    WHERE r.id = room_id_param;
    
    -- Update room status
    UPDATE rooms
    SET status = 'broadcasting',
        updated_at = CURRENT_TIMESTAMP
    WHERE id = room_id_param
      AND status = 'empty';
    
    RETURN v_session_id;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log error but don't fail
        RAISE WARNING 'Error in recover_or_cleanup_session: %', SQLERRM;
        
        -- Try to return any existing session even if there was an error
        SELECT id INTO v_session_id
        FROM room_sessions
        WHERE room_id = room_id_param
          AND status = 'active'
        ORDER BY started_at DESC
        LIMIT 1;
        
        RETURN v_session_id;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION recover_or_cleanup_session TO authenticated;
GRANT EXECUTE ON FUNCTION recover_or_cleanup_session TO service_role;

-- Add helpful comment
COMMENT ON FUNCTION recover_or_cleanup_session IS 
'Simple working version that recovers an existing session or creates a new one after cleaning up stale sessions. 
Used by the frontend go-live button to ensure clean session state.';


================================================
FILE: supabase/migrations/20250128_enhance_mosque_creation.sql
================================================
-- Enhanced mosque creation with comprehensive fields and admin user setup
-- This migration adds missing fields to Mosque table and creates functions for atomic mosque+admin creation

-- Add missing fields to Mosque table
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS description TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS contact_email TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS contact_phone TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS address TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS city TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS country TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS postal_code TEXT;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS timezone TEXT DEFAULT 'UTC';
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS primary_language TEXT DEFAULT 'ar';
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS translation_languages TEXT[] DEFAULT ARRAY['en', 'nl'];
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS enable_public_display BOOLEAN DEFAULT true;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS default_max_delay NUMERIC(3,1) DEFAULT 2.0;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS default_punctuation_sensitivity NUMERIC(3,2) DEFAULT 0.50;
ALTER TABLE public."Mosque" ADD COLUMN IF NOT EXISTS default_context_window_size INTEGER DEFAULT 3;

-- Create a sequence for mosque IDs if not exists
CREATE SEQUENCE IF NOT EXISTS mosque_id_seq START WITH 1000;

-- Function to create mosque with admin user atomically
CREATE OR REPLACE FUNCTION public.create_mosque_with_admin(
  p_mosque_name TEXT,
  p_subdomain TEXT,
  p_description TEXT DEFAULT NULL,
  p_contact_email TEXT DEFAULT NULL,
  p_contact_phone TEXT DEFAULT NULL,
  p_address TEXT DEFAULT NULL,
  p_city TEXT DEFAULT NULL,
  p_country TEXT DEFAULT NULL,
  p_postal_code TEXT DEFAULT NULL,
  p_timezone TEXT DEFAULT 'UTC',
  p_primary_language TEXT DEFAULT 'ar',
  p_translation_languages TEXT[] DEFAULT ARRAY['en', 'nl'],
  p_enable_public_display BOOLEAN DEFAULT true,
  p_admin_email TEXT DEFAULT NULL,
  p_admin_name TEXT DEFAULT NULL,
  p_admin_password TEXT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_mosque_id INTEGER;
  v_user_id UUID;
  v_mosque RECORD;
  v_user RECORD;
  v_generated_password TEXT;
BEGIN
  -- Validate required fields
  IF p_mosque_name IS NULL OR LENGTH(TRIM(p_mosque_name)) < 2 THEN
    RAISE EXCEPTION 'Mosque name must be at least 2 characters';
  END IF;
  
  IF p_subdomain IS NULL OR LENGTH(TRIM(p_subdomain)) < 2 THEN
    RAISE EXCEPTION 'Subdomain must be at least 2 characters';
  END IF;

  -- Check if subdomain already exists
  IF EXISTS (SELECT 1 FROM public."Mosque" WHERE "Subdomain" = p_subdomain) THEN
    RAISE EXCEPTION 'A mosque with subdomain "%" already exists', p_subdomain;
  END IF;

  -- Generate mosque ID from sequence
  v_mosque_id := nextval('mosque_id_seq')::INTEGER;

  -- Insert mosque
  INSERT INTO public."Mosque" (
    id,
    name,
    "Subdomain",
    description,
    contact_email,
    contact_phone,
    address,
    city,
    country,
    postal_code,
    timezone,
    primary_language,
    translation_languages,
    enable_public_display,
    default_max_delay,
    default_punctuation_sensitivity,
    default_context_window_size,
    created_at,
    updated_at,
    is_active
  ) VALUES (
    v_mosque_id,
    p_mosque_name,
    p_subdomain,
    p_description,
    COALESCE(p_contact_email, p_admin_email),
    p_contact_phone,
    p_address,
    p_city,
    p_country,
    p_postal_code,
    p_timezone,
    p_primary_language,
    p_translation_languages,
    p_enable_public_display,
    p_default_max_delay,
    p_default_punctuation_sensitivity,
    p_default_context_window_size,
    NOW(),
    NOW(),
    true
  )
  RETURNING * INTO v_mosque;

  -- Create admin user if email provided
  IF p_admin_email IS NOT NULL THEN
    -- Generate password if not provided
    IF p_admin_password IS NULL THEN
      v_generated_password := encode(gen_random_bytes(12), 'base64');
    ELSE
      v_generated_password := p_admin_password;
    END IF;

    -- Create auth user
    v_user_id := gen_random_uuid();
    
    -- Insert into auth.users (this would normally be done via Supabase Auth API)
    -- For now, we'll just create the user profile
    INSERT INTO public.users (
      id,
      email,
      full_name,
      mosque_id,
      "Role",
      is_super_admin,
      is_active,
      created_at,
      updated_at
    ) VALUES (
      v_user_id,
      p_admin_email,
      COALESCE(p_admin_name, p_mosque_name || ' Admin'),
      v_mosque_id,
      'Admin',
      false,
      true,
      NOW(),
      NOW()
    )
    RETURNING * INTO v_user;

    -- Create default prompt templates for the mosque
    INSERT INTO public.prompt_templates (
      mosque_id,
      name,
      description,
      template,
      is_active,
      created_at,
      updated_at
    ) VALUES
    (
      v_mosque_id,
      'Khutbah Translation',
      'Default template for Friday sermon translations',
      'You are a professional translator specializing in Islamic sermons. Translate the following Arabic khutbah to {target_language}, maintaining the religious context and meaning while making it accessible to the local community.',
      true,
      NOW(),
      NOW()
    ),
    (
      v_mosque_id,
      'General Announcement',
      'Template for general mosque announcements',
      'Translate the following mosque announcement from Arabic to {target_language}. Keep the translation clear, concise, and culturally appropriate for the local Muslim community.',
      true,
      NOW(),
      NOW()
    );
  END IF;

  -- Return created mosque and user info
  RETURN json_build_object(
    'mosque', row_to_json(v_mosque),
    'admin', CASE 
      WHEN v_user.id IS NOT NULL THEN 
        json_build_object(
          'id', v_user.id,
          'email', v_user.email,
          'full_name', v_user.full_name,
          'temporary_password', CASE 
            WHEN p_admin_password IS NULL THEN v_generated_password 
            ELSE NULL 
          END
        )
      ELSE NULL
    END,
    'success', true
  );

EXCEPTION
  WHEN OTHERS THEN
    -- Rollback will happen automatically
    RAISE;
END;
$$;

-- Grant execute permission to authenticated users (super admins)
GRANT EXECUTE ON FUNCTION public.create_mosque_with_admin TO authenticated;

-- Add RLS policy for super admins to execute this function
CREATE POLICY "Super admins can create mosques" ON public."Mosque"
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE id = auth.uid()
      AND is_super_admin = true
    )
  );

-- Add helpful comments
COMMENT ON FUNCTION public.create_mosque_with_admin IS 'Creates a mosque with an optional admin user in a single atomic transaction';
COMMENT ON COLUMN public."Mosque".description IS 'Mosque description for public display';
COMMENT ON COLUMN public."Mosque".contact_email IS 'Primary contact email for the mosque';
COMMENT ON COLUMN public."Mosque".timezone IS 'Timezone for prayer times and scheduling';
COMMENT ON COLUMN public."Mosque".primary_language IS 'Primary language spoken at the mosque';
COMMENT ON COLUMN public."Mosque".translation_languages IS 'Languages available for translation';
COMMENT ON COLUMN public."Mosque".default_max_delay IS 'Default max delay for new rooms';
COMMENT ON COLUMN public."Mosque".default_punctuation_sensitivity IS 'Default punctuation sensitivity for new rooms';
COMMENT ON COLUMN public."Mosque".default_context_window_size IS 'Default context window size for translations';


================================================
FILE: supabase/migrations/20250128_fix_ghost_sessions_comprehensive.sql
================================================
-- Comprehensive Ghost Session Fix Migration
-- This migration implements atomic session management, automatic cleanup, and monitoring
-- Author: SuperClaude Architect
-- Date: 2025-01-28

-- Step 1: Add missing columns for better session tracking
ALTER TABLE room_sessions 
ADD COLUMN IF NOT EXISTS source TEXT DEFAULT 'unknown',
ADD COLUMN IF NOT EXISTS last_heartbeat_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS heartbeat_miss_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS auto_cleanup_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS recovery_attempts INTEGER DEFAULT 0;

-- Add index for performance on cleanup queries
CREATE INDEX IF NOT EXISTS idx_room_sessions_active_heartbeat 
ON room_sessions(status, last_active, last_heartbeat_at) 
WHERE status = 'active';

-- Step 2: Create atomic session creation function with built-in cleanup
CREATE OR REPLACE FUNCTION ensure_room_session_atomic(
    p_room_id INTEGER,
    p_mosque_id INTEGER,
    p_source TEXT DEFAULT 'agent'
) RETURNS JSONB 
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
    v_session_id UUID;
    v_existing_count INTEGER;
    v_cleaned_count INTEGER := 0;
BEGIN
    -- Acquire exclusive lock on room to prevent races
    PERFORM pg_advisory_xact_lock(p_room_id);
    
    -- First, clean up any stale sessions for this room
    WITH cleaned AS (
        UPDATE room_sessions
        SET status = 'completed',
            ended_at = CURRENT_TIMESTAMP,
            cleanup_source = 'stale_on_connect',
            updated_at = CURRENT_TIMESTAMP
        WHERE room_id = p_room_id
          AND status = 'active'
          AND (last_active < CURRENT_TIMESTAMP - INTERVAL '10 minutes'
               OR started_at < CURRENT_TIMESTAMP - INTERVAL '2 hours'
               OR last_heartbeat_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes')
        RETURNING id
    )
    SELECT COUNT(*) INTO v_cleaned_count FROM cleaned;
    
    IF v_cleaned_count > 0 THEN
        RAISE NOTICE 'Cleaned % stale sessions for room %', v_cleaned_count, p_room_id;
    END IF;
    
    -- Check for existing active session with recent activity
    SELECT id INTO v_session_id
    FROM room_sessions
    WHERE room_id = p_room_id
      AND status = 'active'
      AND last_active > CURRENT_TIMESTAMP - INTERVAL '10 minutes'
      AND (last_heartbeat_at IS NULL OR last_heartbeat_at > CURRENT_TIMESTAMP - INTERVAL '5 minutes')
    ORDER BY started_at DESC
    LIMIT 1;
    
    -- Create new session if none exists
    IF v_session_id IS NULL THEN
        v_session_id := gen_random_uuid();
        
        INSERT INTO room_sessions (
            id, room_id, mosque_id, status, 
            started_at, last_active, last_heartbeat_at,
            source, auto_cleanup_at
        ) VALUES (
            v_session_id, p_room_id, p_mosque_id, 'active',
            CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
            p_source, CURRENT_TIMESTAMP + INTERVAL '3 hours'
        );
        
        -- Update room status to broadcasting
        UPDATE rooms 
        SET status = 'broadcasting', updated_at = CURRENT_TIMESTAMP
        WHERE id = p_room_id AND status = 'empty';
        
        RAISE NOTICE 'Created new session % for room %', v_session_id, p_room_id;
    ELSE
        -- Update existing session's heartbeat
        UPDATE room_sessions
        SET last_heartbeat_at = CURRENT_TIMESTAMP,
            heartbeat_miss_count = 0,
            last_active = CURRENT_TIMESTAMP
        WHERE id = v_session_id;
        
        RAISE NOTICE 'Reusing existing session % for room %', v_session_id, p_room_id;
    END IF;
    
    RETURN jsonb_build_object(
        'session_id', v_session_id,
        'created', (v_session_id IS NOT NULL),
        'cleaned_sessions', v_cleaned_count
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'Error in ensure_room_session_atomic: %', SQLERRM;
        RETURN jsonb_build_object(
            'error', SQLERRM,
            'session_id', NULL
        );
END;
$$ LANGUAGE plpgsql;

-- Step 3: Enhanced heartbeat function with miss counting
CREATE OR REPLACE FUNCTION update_session_heartbeat_enhanced(
    p_session_id UUID
) RETURNS JSONB
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
    v_result JSONB;
    v_miss_count INTEGER;
    v_room_id INTEGER;
BEGIN
    -- Update heartbeat and reset miss count
    UPDATE room_sessions
    SET last_heartbeat_at = CURRENT_TIMESTAMP,
        last_active = CURRENT_TIMESTAMP,
        heartbeat_miss_count = 0,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_session_id
      AND status = 'active'
    RETURNING room_id INTO v_room_id;
    
    IF v_room_id IS NULL THEN
        -- Session not found or not active
        RETURN jsonb_build_object(
            'success', false,
            'reason', 'session_not_active'
        );
    END IF;
    
    -- Check if room needs status update
    UPDATE rooms 
    SET status = 'broadcasting', updated_at = CURRENT_TIMESTAMP
    WHERE id = v_room_id AND status != 'broadcasting';
    
    RETURN jsonb_build_object(
        'success', true,
        'session_id', p_session_id,
        'timestamp', CURRENT_TIMESTAMP
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql;

-- Step 4: Comprehensive cleanup function that handles all edge cases
CREATE OR REPLACE FUNCTION cleanup_ghost_sessions()
RETURNS TABLE(
    cleaned_count INTEGER,
    room_id INTEGER,
    session_id UUID,
    cleanup_reason TEXT
)
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
    RETURN QUERY
    WITH sessions_to_clean AS (
        SELECT 
            rs.id,
            rs.room_id,
            CASE 
                WHEN rs.last_active < CURRENT_TIMESTAMP - INTERVAL '15 minutes' THEN 'inactive_15min'
                WHEN rs.last_heartbeat_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes' THEN 'missed_heartbeats'
                WHEN rs.started_at < CURRENT_TIMESTAMP - INTERVAL '3 hours' THEN 'session_too_old'
                WHEN rs.auto_cleanup_at < CURRENT_TIMESTAMP THEN 'auto_cleanup_time'
                WHEN r.status = 'empty' THEN 'room_marked_empty'
                WHEN rs.heartbeat_miss_count > 5 THEN 'excessive_heartbeat_misses'
                ELSE 'unknown'
            END as reason
        FROM room_sessions rs
        LEFT JOIN rooms r ON rs.room_id = r.id
        WHERE rs.status = 'active'
          AND (
              -- No activity for 15 minutes
              rs.last_active < CURRENT_TIMESTAMP - INTERVAL '15 minutes'
              -- No heartbeat for 5 minutes
              OR rs.last_heartbeat_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes'
              -- Session older than 3 hours
              OR rs.started_at < CURRENT_TIMESTAMP - INTERVAL '3 hours'
              -- Auto cleanup time reached
              OR rs.auto_cleanup_at < CURRENT_TIMESTAMP
              -- Room is marked as empty but session is active
              OR r.status = 'empty'
              -- Too many missed heartbeats
              OR rs.heartbeat_miss_count > 5
          )
    ),
    cleaned AS (
        UPDATE room_sessions rs
        SET status = 'completed',
            ended_at = CURRENT_TIMESTAMP,
            cleanup_source = stc.reason,
            updated_at = CURRENT_TIMESTAMP
        FROM sessions_to_clean stc
        WHERE rs.id = stc.id
        RETURNING rs.id, rs.room_id, stc.reason
    )
    SELECT 
        COUNT(*)::INTEGER as cleaned_count,
        c.room_id,
        c.id as session_id,
        c.reason as cleanup_reason
    FROM cleaned c
    GROUP BY c.room_id, c.id, c.reason;
    
    -- Update room statuses for cleaned sessions
    UPDATE rooms r
    SET status = 'empty',
        updated_at = CURRENT_TIMESTAMP
    FROM (
        SELECT DISTINCT room_id 
        FROM cleaned
    ) c
    WHERE r.id = c.room_id
      AND NOT EXISTS (
          SELECT 1 FROM room_sessions rs
          WHERE rs.room_id = r.id
            AND rs.status = 'active'
      );
END;
$$ LANGUAGE plpgsql;

-- Step 5: Function to increment heartbeat miss count (for monitoring)
CREATE OR REPLACE FUNCTION increment_heartbeat_miss_count(
    p_room_id INTEGER
) RETURNS INTEGER
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
    v_updated_count INTEGER;
BEGIN
    WITH updated AS (
        UPDATE room_sessions
        SET heartbeat_miss_count = heartbeat_miss_count + 1,
            recovery_attempts = CASE 
                WHEN heartbeat_miss_count >= 3 THEN recovery_attempts + 1
                ELSE recovery_attempts
            END,
            updated_at = CURRENT_TIMESTAMP
        WHERE room_id = p_room_id
          AND status = 'active'
          AND last_heartbeat_at < CURRENT_TIMESTAMP - INTERVAL '1 minute'
        RETURNING id
    )
    SELECT COUNT(*) INTO v_updated_count FROM updated;
    
    RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

-- Step 6: Create a monitoring view for ghost sessions
CREATE OR REPLACE VIEW ghost_session_monitor AS
SELECT 
    r.name as room_name,
    r.status as room_status,
    rs.id as session_id,
    rs.status as session_status,
    rs.started_at,
    rs.last_active,
    rs.last_heartbeat_at,
    EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - rs.last_active))/60 as minutes_inactive,
    EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - COALESCE(rs.last_heartbeat_at, rs.last_active)))/60 as minutes_since_heartbeat,
    rs.heartbeat_miss_count,
    rs.cleanup_attempts,
    rs.recovery_attempts,
    rs.cleanup_source,
    rs.source as creation_source,
    CASE 
        WHEN rs.last_active < CURRENT_TIMESTAMP - INTERVAL '15 minutes' THEN 'CRITICAL: No activity 15+ min'
        WHEN rs.last_heartbeat_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes' THEN 'WARNING: No heartbeat 5+ min'
        WHEN rs.heartbeat_miss_count > 3 THEN 'WARNING: Multiple missed heartbeats'
        WHEN r.status = 'empty' AND rs.status = 'active' THEN 'ERROR: Room empty but session active'
        ELSE 'OK'
    END as health_status
FROM room_sessions rs
JOIN rooms r ON rs.room_id = r.id
WHERE rs.status = 'active'
ORDER BY rs.last_active ASC;

-- Step 7: Grant necessary permissions
GRANT EXECUTE ON FUNCTION ensure_room_session_atomic TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION update_session_heartbeat_enhanced TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION cleanup_ghost_sessions TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION increment_heartbeat_miss_count TO authenticated, service_role;
GRANT SELECT ON ghost_session_monitor TO authenticated, service_role;

-- Step 8: Create automated cleanup trigger for edge cases
CREATE OR REPLACE FUNCTION auto_cleanup_on_room_empty()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
    -- When room status changes to empty, cleanup any active sessions
    IF NEW.status = 'empty' AND OLD.status != 'empty' THEN
        UPDATE room_sessions
        SET status = 'completed',
            ended_at = CURRENT_TIMESTAMP,
            cleanup_source = 'room_status_empty',
            updated_at = CURRENT_TIMESTAMP
        WHERE room_id = NEW.id
          AND status = 'active';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger if it doesn't exist
DROP TRIGGER IF EXISTS trigger_auto_cleanup_on_room_empty ON rooms;
CREATE TRIGGER trigger_auto_cleanup_on_room_empty
    AFTER UPDATE OF status ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION auto_cleanup_on_room_empty();

-- Step 9: Add helpful comments
COMMENT ON FUNCTION ensure_room_session_atomic IS 
'Atomically ensures a room has exactly one active session. Cleans up stale sessions and prevents race conditions.';

COMMENT ON FUNCTION cleanup_ghost_sessions IS 
'Comprehensive cleanup function that identifies and closes ghost sessions based on multiple criteria.';

COMMENT ON VIEW ghost_session_monitor IS 
'Real-time monitoring view for identifying potential ghost sessions and their health status.';

-- Step 10: Run initial cleanup
SELECT * FROM cleanup_ghost_sessions();


================================================
FILE: supabase/migrations/20250128_fix_missing_recover_function.sql
================================================
-- Fix for missing recover_or_cleanup_session function
-- This function is called by the frontend go-live button

CREATE OR REPLACE FUNCTION recover_or_cleanup_session(
    room_id_param INTEGER,
    user_id_param UUID DEFAULT NULL
) RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
    v_session_id UUID;
    v_existing_session RECORD;
    v_cleaned_count INTEGER := 0;
BEGIN
    -- First, clean up any stale sessions for this room
    UPDATE room_sessions
    SET status = 'completed',
        ended_at = CURRENT_TIMESTAMP,
        cleanup_source = 'recover_function',
        updated_at = CURRENT_TIMESTAMP
    WHERE room_id = room_id_param
      AND status = 'active'
      AND (
          last_active < CURRENT_TIMESTAMP - INTERVAL '15 minutes'
          OR started_at < CURRENT_TIMESTAMP - INTERVAL '2 hours'
      );
    
    GET DIAGNOSTICS v_cleaned_count = ROW_COUNT;
    
    IF v_cleaned_count > 0 THEN
        RAISE NOTICE 'Cleaned % stale sessions for room %', v_cleaned_count, room_id_param;
    END IF;
    
    -- Check for existing active session
    SELECT * INTO v_existing_session
    FROM room_sessions
    WHERE room_id = room_id_param
      AND status = 'active'
      AND last_active > CURRENT_TIMESTAMP - INTERVAL '15 minutes'
    ORDER BY started_at DESC
    LIMIT 1;
    
    -- If we have a valid session, return it
    IF v_existing_session.id IS NOT NULL THEN
        -- Update last_active to keep it fresh
        UPDATE room_sessions
        SET last_active = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = v_existing_session.id;
        
        RETURN v_existing_session.id;
    END IF;
    
    -- No valid session found, create a new one
    v_session_id := gen_random_uuid();
    
    -- Get mosque_id from the room
    INSERT INTO room_sessions (
        id,
        room_id,
        mosque_id,
        status,
        started_at,
        last_active,
        source,
        updated_at
    )
    SELECT 
        v_session_id,
        room_id_param,
        r.mosque_id,
        'active',
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        'frontend_recovery',
        CURRENT_TIMESTAMP
    FROM rooms r
    WHERE r.id = room_id_param;
    
    -- Update room status
    UPDATE rooms
    SET status = 'broadcasting',
        updated_at = CURRENT_TIMESTAMP
    WHERE id = room_id_param
      AND status = 'empty';
    
    RETURN v_session_id;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log error but don't fail
        RAISE WARNING 'Error in recover_or_cleanup_session: %', SQLERRM;
        
        -- Try to return any existing session even if there was an error
        SELECT id INTO v_session_id
        FROM room_sessions
        WHERE room_id = room_id_param
          AND status = 'active'
        ORDER BY started_at DESC
        LIMIT 1;
        
        RETURN v_session_id;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION recover_or_cleanup_session TO authenticated;
GRANT EXECUTE ON FUNCTION recover_or_cleanup_session TO service_role;

-- Add helpful comment
COMMENT ON FUNCTION recover_or_cleanup_session IS 
'Recovers an existing session or creates a new one after cleaning up stale sessions. 
Used by the frontend go-live button to ensure clean session state.';

-- Also ensure the new atomic function is properly integrated
-- Update the existing ensure_room_session_atomic to handle frontend calls better
CREATE OR REPLACE FUNCTION ensure_room_session_atomic(
    p_room_id INTEGER,
    p_mosque_id INTEGER,
    p_source TEXT DEFAULT 'agent'
) RETURNS JSONB 
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
    v_session_id UUID;
    v_existing_count INTEGER;
    v_cleaned_count INTEGER := 0;
BEGIN
    -- Acquire exclusive lock on room to prevent races
    PERFORM pg_advisory_xact_lock(p_room_id);
    
    -- First, clean up any stale sessions for this room
    UPDATE room_sessions
    SET status = 'completed',
        ended_at = CURRENT_TIMESTAMP,
        cleanup_source = 'stale_on_connect',
        updated_at = CURRENT_TIMESTAMP
    WHERE room_id = p_room_id
      AND status = 'active'
      AND (last_active < CURRENT_TIMESTAMP - INTERVAL '10 minutes'
           OR started_at < CURRENT_TIMESTAMP - INTERVAL '2 hours'
           OR (last_heartbeat_at IS NOT NULL AND last_heartbeat_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes'));
    
    GET DIAGNOSTICS v_cleaned_count = ROW_COUNT;
    
    IF v_cleaned_count > 0 THEN
        RAISE NOTICE 'Cleaned % stale sessions for room %', v_cleaned_count, p_room_id;
    END IF;
    
    -- Check for existing active session with recent activity
    SELECT id INTO v_session_id
    FROM room_sessions
    WHERE room_id = p_room_id
      AND status = 'active'
      AND last_active > CURRENT_TIMESTAMP - INTERVAL '10 minutes'
      AND (last_heartbeat_at IS NULL OR last_heartbeat_at > CURRENT_TIMESTAMP - INTERVAL '5 minutes')
    ORDER BY started_at DESC
    LIMIT 1;
    
    -- Create new session if none exists
    IF v_session_id IS NULL THEN
        v_session_id := gen_random_uuid();
        
        INSERT INTO room_sessions (
            id, room_id, mosque_id, status, 
            started_at, last_active, last_heartbeat_at,
            source, auto_cleanup_at
        ) VALUES (
            v_session_id, p_room_id, p_mosque_id, 'active',
            CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
            p_source, CURRENT_TIMESTAMP + INTERVAL '3 hours'
        );
        
        -- Update room status to broadcasting
        UPDATE rooms 
        SET status = 'broadcasting', updated_at = CURRENT_TIMESTAMP
        WHERE id = p_room_id AND status = 'empty';
        
        RAISE NOTICE 'Created new session % for room %', v_session_id, p_room_id;
    ELSE
        -- Update existing session's heartbeat
        UPDATE room_sessions
        SET last_heartbeat_at = CURRENT_TIMESTAMP,
            heartbeat_miss_count = 0,
            last_active = CURRENT_TIMESTAMP
        WHERE id = v_session_id;
        
        RAISE NOTICE 'Reusing existing session % for room %', v_session_id, p_room_id;
    END IF;
    
    RETURN jsonb_build_object(
        'session_id', v_session_id,
        'created', (v_session_id IS NOT NULL),
        'cleaned_sessions', v_cleaned_count
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'Error in ensure_room_session_atomic: %', SQLERRM;
        RETURN jsonb_build_object(
            'error', SQLERRM,
            'session_id', NULL
        );
END;
$$ LANGUAGE plpgsql;


================================================
FILE: supabase/migrations/20250128_fix_mosque_creation_auth.sql
================================================
-- Fix the mosque creation function to accept the auth user ID
-- This allows us to properly link the auth user with the profile

-- Drop the existing function first
DROP FUNCTION IF EXISTS public.create_mosque_with_admin;

-- Recreate with auth user ID parameter
CREATE OR REPLACE FUNCTION public.create_mosque_with_admin(
  p_mosque_name TEXT,
  p_subdomain TEXT,
  p_description TEXT DEFAULT NULL,
  p_contact_email TEXT DEFAULT NULL,
  p_contact_phone TEXT DEFAULT NULL,
  p_address TEXT DEFAULT NULL,
  p_city TEXT DEFAULT NULL,
  p_country TEXT DEFAULT NULL,
  p_postal_code TEXT DEFAULT NULL,
  p_timezone TEXT DEFAULT 'UTC',
  p_primary_language TEXT DEFAULT 'ar',
  p_translation_languages TEXT[] DEFAULT ARRAY['en', 'nl'],
  p_enable_public_display BOOLEAN DEFAULT true,
  p_admin_email TEXT DEFAULT NULL,
  p_admin_name TEXT DEFAULT NULL,
  p_admin_password TEXT DEFAULT NULL,
  p_admin_auth_id UUID DEFAULT NULL  -- New parameter for auth user ID
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_mosque_id INTEGER;
  v_user_id UUID;
  v_mosque RECORD;
  v_user RECORD;
  v_generated_password TEXT;
BEGIN
  -- Validate required fields
  IF p_mosque_name IS NULL OR LENGTH(TRIM(p_mosque_name)) < 2 THEN
    RAISE EXCEPTION 'Mosque name must be at least 2 characters';
  END IF;
  
  IF p_subdomain IS NULL OR LENGTH(TRIM(p_subdomain)) < 2 THEN
    RAISE EXCEPTION 'Subdomain must be at least 2 characters';
  END IF;

  -- Check if subdomain already exists
  IF EXISTS (SELECT 1 FROM public."Mosque" WHERE "Subdomain" = p_subdomain) THEN
    RAISE EXCEPTION 'A mosque with subdomain "%" already exists', p_subdomain;
  END IF;

  -- Generate mosque ID from sequence
  v_mosque_id := nextval('mosque_id_seq')::INTEGER;

  -- Insert mosque
  INSERT INTO public."Mosque" (
    id,
    name,
    "Subdomain",
    description,
    contact_email,
    contact_phone,
    address,
    city,
    country,
    postal_code,
    timezone,
    primary_language,
    translation_languages,
    enable_public_display,
    default_max_delay,
    default_punctuation_sensitivity,
    default_context_window_size,
    created_at,
    updated_at,
    is_active
  ) VALUES (
    v_mosque_id,
    p_mosque_name,
    p_subdomain,
    p_description,
    COALESCE(p_contact_email, p_admin_email),
    p_contact_phone,
    p_address,
    p_city,
    p_country,
    p_postal_code,
    p_timezone,
    p_primary_language,
    p_translation_languages,
    p_enable_public_display,
    2.0,  -- default_max_delay
    0.5,  -- default_punctuation_sensitivity
    3,    -- default_context_window_size
    NOW(),
    NOW(),
    true
  )
  RETURNING * INTO v_mosque;

  -- Create admin user if email provided
  IF p_admin_email IS NOT NULL THEN
    -- Use provided auth ID or generate one
    v_user_id := COALESCE(p_admin_auth_id, gen_random_uuid());
    
    -- Insert into public.users
    INSERT INTO public.users (
      id,
      email,
      full_name,
      mosque_id,
      "Role",
      is_super_admin,
      is_active,
      created_at,
      updated_at
    ) VALUES (
      v_user_id,
      p_admin_email,
      COALESCE(p_admin_name, p_mosque_name || ' Admin'),
      v_mosque_id,
      'Admin',
      false,
      true,
      NOW(),
      NOW()
    )
    RETURNING * INTO v_user;

    -- Create default prompt templates for the mosque
    INSERT INTO public.prompt_templates (
      mosque_id,
      name,
      description,
      template,
      is_active,
      created_at,
      updated_at
    ) VALUES
    (
      v_mosque_id,
      'Khutbah Translation',
      'Default template for Friday sermon translations',
      'You are a professional translator specializing in Islamic sermons. Translate the following Arabic khutbah to {target_language}, maintaining the religious context and meaning while making it accessible to the local community.',
      true,
      NOW(),
      NOW()
    ),
    (
      v_mosque_id,
      'General Announcement',
      'Template for general mosque announcements',
      'Translate the following mosque announcement from Arabic to {target_language}. Keep the translation clear, concise, and culturally appropriate for the local Muslim community.',
      true,
      NOW(),
      NOW()
    );
  END IF;

  -- Return created mosque and user info
  RETURN json_build_object(
    'mosque', row_to_json(v_mosque),
    'admin', CASE 
      WHEN v_user.id IS NOT NULL THEN 
        json_build_object(
          'id', v_user.id,
          'email', v_user.email,
          'full_name', v_user.full_name
        )
      ELSE NULL
    END,
    'success', true
  );

EXCEPTION
  WHEN OTHERS THEN
    -- Rollback will happen automatically
    RAISE;
END;
$$;

-- Grant execute permission to authenticated users (super admins)
GRANT EXECUTE ON FUNCTION public.create_mosque_with_admin TO authenticated;


================================================
FILE: supabase/migrations/20250708125950-9e497f88-90a2-46df-8fcf-cfb602ac1cc3.sql
================================================
-- Enable realtime for the Mosque table
ALTER TABLE public.Mosque REPLICA IDENTITY FULL;

-- Add the Mosque table to the realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE public.Mosque;


================================================
FILE: supabase/migrations/20250708130005-a14acede-103a-41f8-9915-f84a88babc68.sql
================================================
-- Enable realtime for the Mosque table (correct case)
ALTER TABLE public."Mosque" REPLICA IDENTITY FULL;

-- Add the Mosque table to the realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE public."Mosque";


================================================
FILE: supabase/migrations/20250708131447-ce0d4a7b-fa8b-494d-a6db-6c62c72e953d.sql
================================================
-- Enable RLS on Mosque table (ensuring it's active)
ALTER TABLE public."Mosque" ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow authenticated users to SELECT all mosques
CREATE POLICY "Authenticated users can view mosques" 
ON public."Mosque" 
FOR SELECT 
TO authenticated 
USING (true);

-- Policy 2: Allow authenticated users to INSERT new mosques  
CREATE POLICY "Authenticated users can create mosques"
ON public."Mosque" 
FOR INSERT 
TO authenticated 
WITH CHECK (true);

-- Policy 3: Allow authenticated users to UPDATE mosques
CREATE POLICY "Authenticated users can update mosques"
ON public."Mosque" 
FOR UPDATE 
TO authenticated 
USING (true);

-- Policy 4: Allow authenticated users to DELETE mosques
CREATE POLICY "Authenticated users can delete mosques"
ON public."Mosque" 
FOR DELETE 
TO authenticated 
USING (true);


================================================
FILE: supabase/migrations/20250708134608-b3615715-3506-4afb-93ea-1c1ba90e6328.sql
================================================
-- Create function to automatically create user profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, mosque_id, is_super_admin)
  VALUES (
    NEW.id,
    1, -- Default to mosque_id 1, can be changed later by super admin
    false -- Default to false, super admin can promote users
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to run the function when a new user signs up
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Also insert your current user if not already exists
INSERT INTO public.users (id, mosque_id, is_super_admin)
VALUES ('54569266-6e11-4c5c-b6a8-f9cb00a4705f', 1, true)
ON CONFLICT (id) DO NOTHING;


================================================
FILE: supabase/migrations/20250708134922-409329d5-49bc-4f0c-810d-82cbc902bdc9.sql
================================================
-- Create RLS policies for the users table

-- Allow users to read their own profile
CREATE POLICY "Users can view their own profile" 
ON public.users 
FOR SELECT 
USING (auth.uid() = id);

-- Allow super admins to view all user profiles
CREATE POLICY "Super admins can view all user profiles" 
ON public.users 
FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);

-- Allow super admins to insert new user profiles
CREATE POLICY "Super admins can insert user profiles" 
ON public.users 
FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);

-- Allow super admins to update user profiles
CREATE POLICY "Super admins can update user profiles" 
ON public.users 
FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);

-- Allow super admins to delete user profiles
CREATE POLICY "Super admins can delete user profiles" 
ON public.users 
FOR DELETE 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);


================================================
FILE: supabase/migrations/20250708135316-391410a6-033f-4cbb-8165-c3b440dc42c1.sql
================================================
-- Fix infinite recursion in RLS policies by using security definer function

-- Drop the existing problematic policies
DROP POLICY IF EXISTS "Super admins can view all user profiles" ON public.users;
DROP POLICY IF EXISTS "Super admins can insert user profiles" ON public.users;
DROP POLICY IF EXISTS "Super admins can update user profiles" ON public.users;
DROP POLICY IF EXISTS "Super admins can delete user profiles" ON public.users;

-- Create a security definer function to safely check if current user is super admin
CREATE OR REPLACE FUNCTION public.is_current_user_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- Recreate the super admin policies using the security definer function
CREATE POLICY "Super admins can view all user profiles" 
ON public.users 
FOR SELECT 
USING (public.is_current_user_super_admin());

CREATE POLICY "Super admins can insert user profiles" 
ON public.users 
FOR INSERT 
WITH CHECK (public.is_current_user_super_admin());

CREATE POLICY "Super admins can update user profiles" 
ON public.users 
FOR UPDATE 
USING (public.is_current_user_super_admin());

CREATE POLICY "Super admins can delete user profiles" 
ON public.users 
FOR DELETE 
USING (public.is_current_user_super_admin());


================================================
FILE: supabase/migrations/20250708152919-9be4e1ee-de59-463c-9b8c-768ffaf424be.sql
================================================
-- Update one room to active status for testing
UPDATE rooms 
SET 
  status = 'active',
  Livekit_room_name = 'room_' || id::text,
  transcription_language = 'ar',
  translation__language = 'nl',
  max_delay = 2.0,
  punctuation_sensitivity = 0.5
WHERE id = 870218;


================================================
FILE: supabase/migrations/20250708152930-fece161e-d1ee-4cee-9646-e4371e9659ed.sql
================================================
-- Update one room to active status for testing
UPDATE rooms 
SET 
  status = 'active',
  "Livekit_room_name" = 'room_' || id::text,
  transcription_language = 'ar',
  translation__language = 'nl',
  max_delay = 2.0,
  punctuation_sensitivity = 0.5
WHERE id = 870218;


================================================
FILE: supabase/migrations/20250708181803-d97e37a7-261d-4a97-ab20-d6fbc7029393.sql
================================================
-- Create transcripts table for storing session transcripts
CREATE TABLE public.transcripts (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id INTEGER NOT NULL REFERENCES public.rooms(id) ON DELETE CASCADE,
  session_id UUID NOT NULL,
  transcription_segment TEXT,
  translation_segment TEXT,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create room_sessions table for tracking recording sessions
CREATE TABLE public.room_sessions (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id INTEGER NOT NULL REFERENCES public.rooms(id) ON DELETE CASCADE,
  mosque_id INTEGER NOT NULL REFERENCES public.Mosque(id) ON DELETE CASCADE,
  started_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  ended_at TIMESTAMP WITH TIME ZONE,
  transcript_count INTEGER NOT NULL DEFAULT 0,
  duration_minutes INTEGER,
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed', 'stopped')),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.transcripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_sessions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for transcripts
CREATE POLICY "Users can view transcripts for their mosque's rooms" 
ON public.transcripts 
FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.rooms 
    INNER JOIN public.users ON rooms.mosque_id = users.mosque_id 
    WHERE rooms.id = transcripts.room_id AND users.id = auth.uid()
  )
);

CREATE POLICY "Users can create transcripts for their mosque's rooms" 
ON public.transcripts 
FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.rooms 
    INNER JOIN public.users ON rooms.mosque_id = users.mosque_id 
    WHERE rooms.id = transcripts.room_id AND users.id = auth.uid()
  )
);

-- RLS Policies for room_sessions
CREATE POLICY "Users can view sessions for their mosque's rooms" 
ON public.room_sessions 
FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE users.mosque_id = room_sessions.mosque_id AND users.id = auth.uid()
  )
);

CREATE POLICY "Users can create sessions for their mosque's rooms" 
ON public.room_sessions 
FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE users.mosque_id = room_sessions.mosque_id AND users.id = auth.uid()
  )
);

CREATE POLICY "Users can update sessions for their mosque's rooms" 
ON public.room_sessions 
FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE users.mosque_id = room_sessions.mosque_id AND users.id = auth.uid()
  )
);

-- Create indexes for efficient querying
CREATE INDEX idx_transcripts_room_id ON public.transcripts(room_id);
CREATE INDEX idx_transcripts_session_id ON public.transcripts(session_id);
CREATE INDEX idx_transcripts_timestamp ON public.transcripts(timestamp);
CREATE INDEX idx_room_sessions_room_id ON public.room_sessions(room_id);
CREATE INDEX idx_room_sessions_mosque_id ON public.room_sessions(mosque_id);
CREATE INDEX idx_room_sessions_started_at ON public.room_sessions(started_at);

-- Create function to update timestamps
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for automatic timestamp updates
CREATE TRIGGER update_room_sessions_updated_at
BEFORE UPDATE ON public.room_sessions
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();


================================================
FILE: supabase/migrations/20250708181824-7eb671f8-2a55-4902-ae29-ab74a8b5c8f8.sql
================================================
-- Create transcripts table for storing session transcripts
CREATE TABLE public.transcripts (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id INTEGER NOT NULL REFERENCES public.rooms(id) ON DELETE CASCADE,
  session_id UUID NOT NULL,
  transcription_segment TEXT,
  translation_segment TEXT,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create room_sessions table for tracking recording sessions
CREATE TABLE public.room_sessions (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id INTEGER NOT NULL REFERENCES public.rooms(id) ON DELETE CASCADE,
  mosque_id INTEGER NOT NULL REFERENCES public."Mosque"(id) ON DELETE CASCADE,
  started_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  ended_at TIMESTAMP WITH TIME ZONE,
  transcript_count INTEGER NOT NULL DEFAULT 0,
  duration_minutes INTEGER,
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed', 'stopped')),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.transcripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_sessions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for transcripts
CREATE POLICY "Users can view transcripts for their mosque's rooms" 
ON public.transcripts 
FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.rooms 
    INNER JOIN public.users ON rooms.mosque_id = users.mosque_id 
    WHERE rooms.id = transcripts.room_id AND users.id = auth.uid()
  )
);

CREATE POLICY "Users can create transcripts for their mosque's rooms" 
ON public.transcripts 
FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.rooms 
    INNER JOIN public.users ON rooms.mosque_id = users.mosque_id 
    WHERE rooms.id = transcripts.room_id AND users.id = auth.uid()
  )
);

-- RLS Policies for room_sessions
CREATE POLICY "Users can view sessions for their mosque's rooms" 
ON public.room_sessions 
FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE users.mosque_id = room_sessions.mosque_id AND users.id = auth.uid()
  )
);

CREATE POLICY "Users can create sessions for their mosque's rooms" 
ON public.room_sessions 
FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE users.mosque_id = room_sessions.mosque_id AND users.id = auth.uid()
  )
);

CREATE POLICY "Users can update sessions for their mosque's rooms" 
ON public.room_sessions 
FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE users.mosque_id = room_sessions.mosque_id AND users.id = auth.uid()
  )
);

-- Create indexes for efficient querying
CREATE INDEX idx_transcripts_room_id ON public.transcripts(room_id);
CREATE INDEX idx_transcripts_session_id ON public.transcripts(session_id);
CREATE INDEX idx_transcripts_timestamp ON public.transcripts(timestamp);
CREATE INDEX idx_room_sessions_room_id ON public.room_sessions(room_id);
CREATE INDEX idx_room_sessions_mosque_id ON public.room_sessions(mosque_id);
CREATE INDEX idx_room_sessions_started_at ON public.room_sessions(started_at);

-- Create function to update timestamps (only if it doesn't exist)
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for automatic timestamp updates
CREATE TRIGGER update_room_sessions_updated_at
BEFORE UPDATE ON public.room_sessions
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();


================================================
FILE: supabase/migrations/20250708185851-6625a012-2382-4a52-bf16-60a891fa7caa.sql
================================================
-- Add logging_enabled column to room_sessions table
ALTER TABLE public.room_sessions 
ADD COLUMN logging_enabled boolean NOT NULL DEFAULT false;

-- Create index for faster lookups of active logging sessions
CREATE INDEX idx_room_sessions_logging_enabled 
ON public.room_sessions(room_id, logging_enabled) 
WHERE logging_enabled = true;


================================================
FILE: supabase/migrations/20250708221001-7d05fc81-515b-41a2-ab0e-3c3836222bc0.sql
================================================

-- Create impersonation sessions table to track super admin impersonations
CREATE TABLE public.impersonation_sessions (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  super_admin_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  target_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now() + INTERVAL '2 hours',
  ended_at TIMESTAMP WITH TIME ZONE NULL,
  is_active BOOLEAN NOT NULL DEFAULT true
);

-- Enable RLS
ALTER TABLE public.impersonation_sessions ENABLE ROW LEVEL SECURITY;

-- Create policies for impersonation sessions
CREATE POLICY "Super admins can create impersonation sessions"
ON public.impersonation_sessions
FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);

CREATE POLICY "Super admins can view their impersonation sessions"
ON public.impersonation_sessions
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);

CREATE POLICY "Super admins can update their impersonation sessions"
ON public.impersonation_sessions
FOR UPDATE
USING (
  EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  )
);

-- Create index for faster lookups
CREATE INDEX idx_impersonation_sessions_active 
ON public.impersonation_sessions(super_admin_id, is_active) 
WHERE is_active = true;

-- Create function to clean up expired sessions
CREATE OR REPLACE FUNCTION public.cleanup_expired_impersonation_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.impersonation_sessions 
  SET is_active = false, ended_at = now()
  WHERE expires_at < now() AND is_active = true;
END;
$$;

-- Create function to get users for a mosque (for super admin to see who they can impersonate)
CREATE OR REPLACE FUNCTION public.get_mosque_users(mosque_id_param INTEGER)
RETURNS TABLE(
  user_id UUID,
  email TEXT,
  mosque_name TEXT,
  is_super_admin BOOLEAN
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only allow super admins to call this function
  IF NOT public.is_current_user_super_admin() THEN
    RAISE EXCEPTION 'Access denied: Super admin privileges required';
  END IF;

  RETURN QUERY
  SELECT 
    u.id as user_id,
    au.email,
    m.name as mosque_name,
    u.is_super_admin
  FROM public.users u
  JOIN auth.users au ON u.id = au.id
  JOIN public.Mosque m ON u.mosque_id = m.id
  WHERE u.mosque_id = mosque_id_param
  ORDER BY au.email;
END;
$$;



================================================
FILE: supabase/migrations/20250708230934-71965874-767d-4725-bc60-922460594589.sql
================================================
-- Add token-based access columns to rooms table
ALTER TABLE public.rooms 
ADD COLUMN access_token UUID DEFAULT gen_random_uuid() UNIQUE,
ADD COLUMN token_enabled BOOLEAN DEFAULT false,
ADD COLUMN token_expires_at TIMESTAMP WITH TIME ZONE NULL;

-- Create index for faster token lookups
CREATE INDEX idx_rooms_access_token ON public.rooms(access_token) WHERE token_enabled = true;

-- Create function to generate new access token for a room
CREATE OR REPLACE FUNCTION public.generate_room_token(room_id_param INTEGER)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_token UUID;
BEGIN
  -- Check if user has access to this room (same mosque)
  IF NOT EXISTS (
    SELECT 1 FROM public.rooms r
    JOIN public.users u ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: You can only generate tokens for rooms in your mosque';
  END IF;

  -- Generate new token
  new_token := gen_random_uuid();
  
  -- Update room with new token
  UPDATE public.rooms 
  SET access_token = new_token, token_enabled = true
  WHERE id = room_id_param;
  
  RETURN new_token;
END;
$$;

-- Create function to get room info by token (for public access)
CREATE OR REPLACE FUNCTION public.get_room_by_token(token_param UUID)
RETURNS TABLE(
  room_id INTEGER,
  room_title TEXT,
  mosque_id INTEGER,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id::INTEGER as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.access_token = token_param 
    AND r.token_enabled = true
    AND (r.token_expires_at IS NULL OR r.token_expires_at > now());
END;
$$;

-- Create RLS policy for public token access
CREATE POLICY "Public access via valid tokens"
ON public.rooms
FOR SELECT
USING (
  access_token IS NOT NULL 
  AND token_enabled = true 
  AND (token_expires_at IS NULL OR token_expires_at > now())
);


================================================
FILE: supabase/migrations/20250708232117-9d12b530-45f3-4b69-a433-889a53b3b0a7.sql
================================================
-- Remove complex token system and replace with simple public access
ALTER TABLE public.rooms 
DROP COLUMN access_token,
DROP COLUMN token_enabled,
DROP COLUMN token_expires_at;

-- Add simple public access flag
ALTER TABLE public.rooms 
ADD COLUMN public_access_enabled BOOLEAN DEFAULT false;

-- Drop the token-based index
DROP INDEX IF EXISTS idx_rooms_access_token;

-- Create index for public access lookups
CREATE INDEX idx_rooms_public_access ON public.rooms(id) WHERE public_access_enabled = true;

-- Update the room access function to use room ID instead of token
CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code INTEGER)
RETURNS TABLE(
  room_id INTEGER,
  room_title TEXT,
  mosque_id INTEGER,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id::INTEGER as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$$;

-- Update the room token generation function to toggle public access
CREATE OR REPLACE FUNCTION public.toggle_room_public_access(room_id_param INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_status BOOLEAN;
BEGIN
  -- Check if user has access to this room (same mosque)
  IF NOT EXISTS (
    SELECT 1 FROM public.rooms r
    JOIN public.users u ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: You can only manage public access for rooms in your mosque';
  END IF;

  -- Toggle public access
  UPDATE public.rooms 
  SET public_access_enabled = NOT public_access_enabled
  WHERE id = room_id_param
  RETURNING public_access_enabled INTO new_status;
  
  RETURN new_status;
END;
$$;

-- Update RLS policy for public access to use the new simple system
DROP POLICY IF EXISTS "Public access via valid tokens" ON public.rooms;

CREATE POLICY "Public access via room code"
ON public.rooms
FOR SELECT
USING (public_access_enabled = true);


================================================
FILE: supabase/migrations/20250708232134-ffbb9436-e93c-4568-ab5a-b57961f87c7b.sql
================================================
-- First drop the dependent policy
DROP POLICY IF EXISTS "Public access via valid tokens" ON public.rooms;

-- Remove complex token system and replace with simple public access
ALTER TABLE public.rooms 
DROP COLUMN access_token,
DROP COLUMN token_enabled,
DROP COLUMN token_expires_at;

-- Add simple public access flag
ALTER TABLE public.rooms 
ADD COLUMN public_access_enabled BOOLEAN DEFAULT false;

-- Drop the token-based index
DROP INDEX IF EXISTS idx_rooms_access_token;

-- Create index for public access lookups
CREATE INDEX idx_rooms_public_access ON public.rooms(id) WHERE public_access_enabled = true;

-- Update the room access function to use room ID instead of token
CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code INTEGER)
RETURNS TABLE(
  room_id INTEGER,
  room_title TEXT,
  mosque_id INTEGER,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id::INTEGER as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$$;

-- Update the room token generation function to toggle public access
CREATE OR REPLACE FUNCTION public.toggle_room_public_access(room_id_param INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_status BOOLEAN;
BEGIN
  -- Check if user has access to this room (same mosque)
  IF NOT EXISTS (
    SELECT 1 FROM public.rooms r
    JOIN public.users u ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: You can only manage public access for rooms in your mosque';
  END IF;

  -- Toggle public access
  UPDATE public.rooms 
  SET public_access_enabled = NOT public_access_enabled
  WHERE id = room_id_param
  RETURNING public_access_enabled INTO new_status;
  
  RETURN new_status;
END;
$$;

-- Create new RLS policy for public access using the simple system
CREATE POLICY "Public access via room code"
ON public.rooms
FOR SELECT
USING (public_access_enabled = true);


================================================
FILE: supabase/migrations/20250708232823-38e72a73-8ea5-4c73-a782-ac14bb3cf7cb.sql
================================================
-- Fix the get_room_by_code function to match actual database column types
CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code INTEGER)
RETURNS TABLE(
  room_id NUMERIC,
  room_title TEXT,
  mosque_id NUMERIC,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$$;


================================================
FILE: supabase/migrations/20250708232840-db9a4d28-31f1-4155-bbb0-6b71a6c105c5.sql
================================================
-- Drop the existing function first
DROP FUNCTION IF EXISTS public.get_room_by_code(INTEGER);

-- Recreate the function with correct return types to match database schema
CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code INTEGER)
RETURNS TABLE(
  room_id NUMERIC,
  room_title TEXT,
  mosque_id NUMERIC,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$$;


================================================
FILE: supabase/migrations/20250709201903-3091bbce-3135-4e9d-90ae-0c488532b14f.sql
================================================
-- Add webhook URL configuration for room sessions
ALTER TABLE public.room_sessions 
ADD COLUMN webhook_url TEXT DEFAULT 'http://localhost:8767/webhook';

-- Create function to notify webhook when session changes
CREATE OR REPLACE FUNCTION notify_session_webhook()
RETURNS TRIGGER AS $$
DECLARE
  webhook_url TEXT;
  payload JSONB;
  http_request_id BIGINT;
BEGIN
  -- Get webhook URL (could be configurable per mosque in future)
  webhook_url := COALESCE(NEW.webhook_url, 'http://localhost:8767/webhook');
  
  -- Prepare payload based on operation
  IF TG_OP = 'INSERT' THEN
    payload := jsonb_build_object(
      'type', 'INSERT',
      'table', 'room_sessions',
      'record', to_jsonb(NEW),
      'webhook_type', 'session_started'
    );
  ELSIF TG_OP = 'UPDATE' THEN
    -- Check if session is ending
    IF OLD.status != 'completed' AND NEW.status = 'completed' THEN
      payload := jsonb_build_object(
        'type', 'UPDATE',
        'table', 'room_sessions',
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD),
        'webhook_type', 'session_ended'
      );
    ELSE
      payload := jsonb_build_object(
        'type', 'UPDATE',
        'table', 'room_sessions',
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD),
        'webhook_type', 'session_updated'
      );
    END IF;
  END IF;

  -- Send webhook notification using pg_net (if available)
  -- Note: This requires pg_net extension to be enabled
  BEGIN
    SELECT net.http_post(
      url := webhook_url,
      headers := '{"Content-Type": "application/json"}'::JSONB,
      body := payload
    ) INTO http_request_id;
    
    -- Log the webhook attempt
    INSERT INTO public.webhook_logs (
      table_name, 
      operation, 
      payload, 
      webhook_url, 
      request_id,
      created_at
    ) VALUES (
      'room_sessions', 
      TG_OP, 
      payload, 
      webhook_url, 
      http_request_id,
      NOW()
    );
  EXCEPTION WHEN OTHERS THEN
    -- Log webhook failure but don't fail the main operation
    INSERT INTO public.webhook_logs (
      table_name, 
      operation, 
      payload, 
      webhook_url, 
      error_message,
      created_at
    ) VALUES (
      'room_sessions', 
      TG_OP, 
      payload, 
      webhook_url, 
      SQLERRM,
      NOW()
    );
  END;

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create webhook logs table for debugging
CREATE TABLE IF NOT EXISTS public.webhook_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  operation TEXT NOT NULL,
  payload JSONB NOT NULL,
  webhook_url TEXT NOT NULL,
  request_id BIGINT,
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create trigger for room_sessions
DROP TRIGGER IF EXISTS room_sessions_webhook_trigger ON public.room_sessions;
CREATE TRIGGER room_sessions_webhook_trigger
  AFTER INSERT OR UPDATE ON public.room_sessions
  FOR EACH ROW
  EXECUTE FUNCTION notify_session_webhook();

-- Enable row level security for webhook_logs
ALTER TABLE public.webhook_logs ENABLE ROW LEVEL SECURITY;

-- Allow users to view webhook logs for their mosque's sessions
CREATE POLICY "Users can view webhook logs for their mosque sessions"
  ON public.webhook_logs FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.room_sessions rs
      JOIN public.users u ON rs.mosque_id = u.mosque_id
      WHERE u.id = auth.uid()
      AND payload->>'record'->>'id' = rs.id::TEXT
    )
  );

-- Add webhook URL column to rooms table for future room-specific webhooks
ALTER TABLE public.rooms 
ADD COLUMN IF NOT EXISTS webhook_url TEXT;


================================================
FILE: supabase/migrations/20250709202002-8fc88d3c-d3c6-4239-ac70-3491882ece09.sql
================================================
-- Add webhook URL configuration for room sessions
ALTER TABLE public.room_sessions 
ADD COLUMN webhook_url TEXT DEFAULT 'http://localhost:8767/webhook';

-- Create function to notify webhook when session changes
CREATE OR REPLACE FUNCTION notify_session_webhook()
RETURNS TRIGGER AS $$
DECLARE
  webhook_url TEXT;
  payload JSONB;
  http_request_id BIGINT;
BEGIN
  -- Get webhook URL (could be configurable per mosque in future)
  webhook_url := COALESCE(NEW.webhook_url, 'http://localhost:8767/webhook');
  
  -- Prepare payload based on operation
  IF TG_OP = 'INSERT' THEN
    payload := jsonb_build_object(
      'type', 'INSERT',
      'table', 'room_sessions',
      'record', to_jsonb(NEW),
      'webhook_type', 'session_started'
    );
  ELSIF TG_OP = 'UPDATE' THEN
    -- Check if session is ending
    IF OLD.status != 'completed' AND NEW.status = 'completed' THEN
      payload := jsonb_build_object(
        'type', 'UPDATE',
        'table', 'room_sessions',
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD),
        'webhook_type', 'session_ended'
      );
    ELSE
      payload := jsonb_build_object(
        'type', 'UPDATE',
        'table', 'room_sessions',
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD),
        'webhook_type', 'session_updated'
      );
    END IF;
  END IF;

  -- Send webhook notification using pg_net (if available)
  -- Note: This requires pg_net extension to be enabled
  BEGIN
    SELECT net.http_post(
      url := webhook_url,
      headers := '{"Content-Type": "application/json"}'::JSONB,
      body := payload
    ) INTO http_request_id;
    
    -- Log the webhook attempt
    INSERT INTO public.webhook_logs (
      table_name, 
      operation, 
      payload, 
      webhook_url, 
      request_id,
      created_at
    ) VALUES (
      'room_sessions', 
      TG_OP, 
      payload, 
      webhook_url, 
      http_request_id,
      NOW()
    );
  EXCEPTION WHEN OTHERS THEN
    -- Log webhook failure but don't fail the main operation
    INSERT INTO public.webhook_logs (
      table_name, 
      operation, 
      payload, 
      webhook_url, 
      error_message,
      created_at
    ) VALUES (
      'room_sessions', 
      TG_OP, 
      payload, 
      webhook_url, 
      SQLERRM,
      NOW()
    );
  END;

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create webhook logs table for debugging
CREATE TABLE IF NOT EXISTS public.webhook_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  operation TEXT NOT NULL,
  payload JSONB NOT NULL,
  webhook_url TEXT NOT NULL,
  request_id BIGINT,
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create trigger for room_sessions
DROP TRIGGER IF EXISTS room_sessions_webhook_trigger ON public.room_sessions;
CREATE TRIGGER room_sessions_webhook_trigger
  AFTER INSERT OR UPDATE ON public.room_sessions
  FOR EACH ROW
  EXECUTE FUNCTION notify_session_webhook();

-- Enable row level security for webhook_logs
ALTER TABLE public.webhook_logs ENABLE ROW LEVEL SECURITY;

-- Allow users to view webhook logs for their mosque's sessions
CREATE POLICY "Users can view webhook logs for their mosque sessions"
  ON public.webhook_logs FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.room_sessions rs
      JOIN public.users u ON rs.mosque_id = u.mosque_id
      WHERE u.id = auth.uid()
      AND (payload->'record'->>'id')::UUID = rs.id
    )
  );

-- Add webhook URL column to rooms table for future room-specific webhooks
ALTER TABLE public.rooms 
ADD COLUMN IF NOT EXISTS webhook_url TEXT;


================================================
FILE: supabase/migrations/20250710135726-c3cfd2d1-0d02-4262-80cd-19af94a5a1cd.sql
================================================
-- Add RLS policy to allow service role to insert transcripts
-- This enables the Python agent to store transcripts while maintaining security

CREATE POLICY "Service role can create transcripts for valid sessions" 
ON public.transcripts 
FOR INSERT 
WITH CHECK (
  -- Allow service role access
  (auth.role() = 'service_role') 
  AND
  -- Ensure the room_id exists and has an active session
  (EXISTS (
    SELECT 1 
    FROM public.room_sessions rs
    JOIN public.rooms r ON r.id = rs.room_id
    WHERE r.id = transcripts.room_id::numeric
    AND rs.status = 'active'
    AND rs.mosque_id = r.mosque_id
  ))
);

-- Add RLS policy to allow service role to read transcripts for validation
CREATE POLICY "Service role can read transcripts" 
ON public.transcripts 
FOR SELECT 
USING (auth.role() = 'service_role');

-- Update room_sessions table to allow service role to create and update sessions
-- This is needed for the Python agent to manage session lifecycle

CREATE POLICY "Service role can create room sessions" 
ON public.room_sessions 
FOR INSERT 
WITH CHECK (auth.role() = 'service_role');

CREATE POLICY "Service role can update room sessions" 
ON public.room_sessions 
FOR UPDATE 
USING (auth.role() = 'service_role');

CREATE POLICY "Service role can read room sessions" 
ON public.room_sessions 
FOR SELECT 
USING (auth.role() = 'service_role');


================================================
FILE: supabase/migrations/20250712173118-0ced2e36-e590-4d6a-b4bd-db29fdb50083.sql
================================================
-- Create function to automatically cleanup stale sessions
CREATE OR REPLACE FUNCTION public.cleanup_stale_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  -- Cleanup sessions older than 2 hours that are still active
  UPDATE public.room_sessions 
  SET status = 'completed', 
      ended_at = now(),
      duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60
  WHERE status = 'active' 
    AND started_at < (now() - interval '2 hours');
    
  -- Update room status back to empty for affected rooms
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id IN (
    SELECT DISTINCT room_id 
    FROM public.room_sessions 
    WHERE status = 'completed' 
      AND ended_at >= (now() - interval '5 minutes')
  );
END;
$function$


================================================
FILE: supabase/migrations/20250712234109-09a527ea-d212-4a10-97f3-3479c2bb79da.sql
================================================
-- Allow authenticated users to delete rooms from their own mosque
CREATE POLICY "Admins can delete their own mosque's rooms" 
ON public.rooms 
FOR DELETE 
USING (
  (SELECT users.mosque_id FROM users WHERE users.id = auth.uid()) = mosque_id
);


================================================
FILE: supabase/migrations/20250712234933-e5cc0a1d-bc19-4f26-bda5-e55417a08dc9.sql
================================================
-- Create room templates table for configuration presets
CREATE TABLE public.room_templates (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  max_delay NUMERIC,
  punctuation_sensitivity NUMERIC,
  transcription_language TEXT,
  translation_language TEXT,
  is_system_template BOOLEAN NOT NULL DEFAULT false,
  created_by_mosque_id NUMERIC,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  FOREIGN KEY (created_by_mosque_id) REFERENCES public.Mosque(id)
);

-- Enable Row Level Security
ALTER TABLE public.room_templates ENABLE ROW LEVEL SECURITY;

-- Create policies for room templates
CREATE POLICY "Anyone can view system templates" 
ON public.room_templates 
FOR SELECT 
USING (is_system_template = true);

CREATE POLICY "Users can view their mosque's custom templates" 
ON public.room_templates 
FOR SELECT 
USING (created_by_mosque_id = (SELECT mosque_id FROM public.users WHERE id = auth.uid()));

CREATE POLICY "Super admins can manage system templates" 
ON public.room_templates 
FOR ALL 
USING (public.is_current_user_super_admin() AND is_system_template = true);

CREATE POLICY "Mosque admins can manage their custom templates" 
ON public.room_templates 
FOR ALL 
USING (created_by_mosque_id = (SELECT mosque_id FROM public.users WHERE id = auth.uid()));

-- Insert the Khutba system template with current settings
INSERT INTO public.room_templates (
  name, 
  max_delay, 
  punctuation_sensitivity, 
  transcription_language, 
  translation_language, 
  is_system_template
) VALUES (
  'Khutba', 
  2, 
  0.5, 
  'ar', 
  'nl', 
  true
);

-- Insert a few more common system templates
INSERT INTO public.room_templates (
  name, 
  max_delay, 
  punctuation_sensitivity, 
  transcription_language, 
  translation_language, 
  is_system_template
) VALUES 
('Prayer', 1, 0.3, 'ar', 'nl', true),
('Lecture', 3, 0.7, 'ar', 'en', true);


================================================
FILE: supabase/migrations/20250712234948-77412074-9a42-43a4-b5fa-6dca121b0b30.sql
================================================
-- Create room templates table for configuration presets
CREATE TABLE public.room_templates (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  max_delay NUMERIC,
  punctuation_sensitivity NUMERIC,
  transcription_language TEXT,
  translation_language TEXT,
  is_system_template BOOLEAN NOT NULL DEFAULT false,
  created_by_mosque_id NUMERIC,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  FOREIGN KEY (created_by_mosque_id) REFERENCES public."Mosque"(id)
);

-- Enable Row Level Security
ALTER TABLE public.room_templates ENABLE ROW LEVEL SECURITY;

-- Create policies for room templates
CREATE POLICY "Anyone can view system templates" 
ON public.room_templates 
FOR SELECT 
USING (is_system_template = true);

CREATE POLICY "Users can view their mosque's custom templates" 
ON public.room_templates 
FOR SELECT 
USING (created_by_mosque_id = (SELECT mosque_id FROM public.users WHERE id = auth.uid()));

CREATE POLICY "Super admins can manage system templates" 
ON public.room_templates 
FOR ALL 
USING (public.is_current_user_super_admin() AND is_system_template = true);

CREATE POLICY "Mosque admins can manage their custom templates" 
ON public.room_templates 
FOR ALL 
USING (created_by_mosque_id = (SELECT mosque_id FROM public.users WHERE id = auth.uid()));

-- Insert the Khutba system template with current settings
INSERT INTO public.room_templates (
  name, 
  max_delay, 
  punctuation_sensitivity, 
  transcription_language, 
  translation_language, 
  is_system_template
) VALUES (
  'Khutba', 
  2, 
  0.5, 
  'ar', 
  'nl', 
  true
);

-- Insert a few more common system templates
INSERT INTO public.room_templates (
  name, 
  max_delay, 
  punctuation_sensitivity, 
  transcription_language, 
  translation_language, 
  is_system_template
) VALUES 
('Prayer', 1, 0.3, 'ar', 'nl', true),
('Lecture', 3, 0.7, 'ar', 'en', true);


================================================
FILE: supabase/migrations/20250713192711-dd33874d-f818-425a-b721-d3f1add4988c.sql
================================================
-- Enable pg_cron extension for scheduled tasks
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Schedule cleanup_stale_sessions to run every 30 minutes
SELECT cron.schedule(
  'cleanup-stale-sessions',
  '*/30 * * * *', -- every 30 minutes
  'SELECT public.cleanup_stale_sessions();'
);


================================================
FILE: supabase/migrations/20250714002744-168522ee-003d-4436-9c7a-d74399c48efe.sql
================================================
-- Fix Database Inconsistencies for Broadcasting System
-- Phase 1: Clean up orphaned sessions and fix room status mismatches

-- Step 1: End all orphaned active sessions (sessions older than 3 hours)
UPDATE room_sessions 
SET 
    status = 'completed',
    ended_at = NOW(),
    updated_at = NOW()
WHERE 
    status = 'active' 
    AND started_at < NOW() - INTERVAL '3 hours'
    AND ended_at IS NULL;

-- Step 2: Fix room status mismatches
-- Set rooms to 'empty' if they have no active sessions
UPDATE rooms r
SET 
    status = 'empty',
    updated_at = NOW()
WHERE 
    r.status IN ('live', 'active')
    AND NOT EXISTS (
        SELECT 1 
        FROM room_sessions rs 
        WHERE rs.room_id = r.id 
        AND rs.status = 'active'
    );

-- Set rooms to 'live' if they have active sessions
UPDATE rooms r
SET 
    status = 'live',
    updated_at = NOW()
WHERE 
    r.status = 'empty'
    AND EXISTS (
        SELECT 1 
        FROM room_sessions rs 
        WHERE rs.room_id = r.id 
        AND rs.status = 'active'
    );

-- Step 3: Add constraints to prevent future inconsistencies
-- Create a function to automatically update room status
CREATE OR REPLACE FUNCTION update_room_status_on_session_change()
RETURNS TRIGGER AS $$
BEGIN
    -- When a session becomes active, set room to live
    IF NEW.status = 'active' AND (OLD.status IS NULL OR OLD.status != 'active') THEN
        UPDATE rooms 
        SET status = 'live', updated_at = NOW() 
        WHERE id = NEW.room_id;
    END IF;
    
    -- When a session ends, check if room should be empty
    IF NEW.status IN ('completed', 'failed') AND OLD.status = 'active' THEN
        -- Check if there are other active sessions
        IF NOT EXISTS (
            SELECT 1 FROM room_sessions 
            WHERE room_id = NEW.room_id 
            AND id != NEW.id 
            AND status = 'active'
        ) THEN
            UPDATE rooms 
            SET status = 'empty', updated_at = NOW() 
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS sync_room_status_trigger ON room_sessions;

-- Create trigger to sync room status
CREATE TRIGGER sync_room_status_trigger
AFTER INSERT OR UPDATE ON room_sessions
FOR EACH ROW
EXECUTE FUNCTION update_room_status_on_session_change();

-- Step 4: Add a constraint to ensure sessions have proper end times
CREATE OR REPLACE FUNCTION validate_session_times()
RETURNS TRIGGER AS $$
BEGIN
    -- If status is changing to completed/failed, ensure ended_at is set
    IF NEW.status IN ('completed', 'failed') AND NEW.ended_at IS NULL THEN
        NEW.ended_at = NOW();
    END IF;
    
    -- Ensure ended_at is after started_at
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL AND NEW.ended_at < NEW.started_at THEN
        RAISE EXCEPTION 'ended_at must be after started_at';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS validate_session_times_trigger ON room_sessions;

-- Create trigger to validate session times
CREATE TRIGGER validate_session_times_trigger
BEFORE INSERT OR UPDATE ON room_sessions
FOR EACH ROW
EXECUTE FUNCTION validate_session_times();

-- Step 5: Add an automatic cleanup job for orphaned sessions
CREATE OR REPLACE FUNCTION cleanup_orphaned_sessions()
RETURNS void AS $$
BEGIN
    -- End sessions that have been active for more than 6 hours
    UPDATE room_sessions 
    SET 
        status = 'completed',
        ended_at = NOW(),
        updated_at = NOW()
    WHERE 
        status = 'active' 
        AND started_at < NOW() - INTERVAL '6 hours'
        AND ended_at IS NULL;
        
    -- Log the cleanup
    RAISE NOTICE 'Cleaned up % orphaned sessions', ROW_COUNT;
END;
$$ LANGUAGE plpgsql;


================================================
FILE: supabase/migrations/20250714002817-9230e1ef-b561-4c4a-9a18-6deae7211947.sql
================================================
-- Fix Database Inconsistencies for Broadcasting System (Corrected)
-- Phase 1: Clean up orphaned sessions and fix room status mismatches

-- Step 1: End all orphaned active sessions (sessions older than 3 hours)
UPDATE room_sessions 
SET 
    status = 'completed',
    ended_at = NOW()
WHERE 
    status = 'active' 
    AND started_at < NOW() - INTERVAL '3 hours'
    AND ended_at IS NULL;

-- Step 2: Fix room status mismatches
-- Set rooms to 'empty' if they have no active sessions
UPDATE rooms r
SET 
    status = 'empty'
WHERE 
    r.status IN ('live', 'active')
    AND NOT EXISTS (
        SELECT 1 
        FROM room_sessions rs 
        WHERE rs.room_id = r.id 
        AND rs.status = 'active'
    );

-- Set rooms to 'live' if they have active sessions
UPDATE rooms r
SET 
    status = 'live'
WHERE 
    r.status = 'empty'
    AND EXISTS (
        SELECT 1 
        FROM room_sessions rs 
        WHERE rs.room_id = r.id 
        AND rs.status = 'active'
    );

-- Step 3: Add constraints to prevent future inconsistencies
-- Create a function to automatically update room status
CREATE OR REPLACE FUNCTION update_room_status_on_session_change()
RETURNS TRIGGER AS $$
BEGIN
    -- When a session becomes active, set room to live
    IF NEW.status = 'active' AND (OLD.status IS NULL OR OLD.status != 'active') THEN
        UPDATE rooms 
        SET status = 'live'
        WHERE id = NEW.room_id;
    END IF;
    
    -- When a session ends, check if room should be empty
    IF NEW.status IN ('completed', 'failed') AND OLD.status = 'active' THEN
        -- Check if there are other active sessions
        IF NOT EXISTS (
            SELECT 1 FROM room_sessions 
            WHERE room_id = NEW.room_id 
            AND id != NEW.id 
            AND status = 'active'
        ) THEN
            UPDATE rooms 
            SET status = 'empty'
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS sync_room_status_trigger ON room_sessions;

-- Create trigger to sync room status
CREATE TRIGGER sync_room_status_trigger
AFTER INSERT OR UPDATE ON room_sessions
FOR EACH ROW
EXECUTE FUNCTION update_room_status_on_session_change();

-- Step 4: Add a constraint to ensure sessions have proper end times
CREATE OR REPLACE FUNCTION validate_session_times()
RETURNS TRIGGER AS $$
BEGIN
    -- If status is changing to completed/failed, ensure ended_at is set
    IF NEW.status IN ('completed', 'failed') AND NEW.ended_at IS NULL THEN
        NEW.ended_at = NOW();
    END IF;
    
    -- Ensure ended_at is after started_at
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL AND NEW.ended_at < NEW.started_at THEN
        RAISE EXCEPTION 'ended_at must be after started_at';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS validate_session_times_trigger ON room_sessions;

-- Create trigger to validate session times
CREATE TRIGGER validate_session_times_trigger
BEFORE INSERT OR UPDATE ON room_sessions
FOR EACH ROW
EXECUTE FUNCTION validate_session_times();

-- Step 5: Add an automatic cleanup job for orphaned sessions
CREATE OR REPLACE FUNCTION cleanup_orphaned_sessions()
RETURNS void AS $$
BEGIN
    -- End sessions that have been active for more than 6 hours
    UPDATE room_sessions 
    SET 
        status = 'completed',
        ended_at = NOW()
    WHERE 
        status = 'active' 
        AND started_at < NOW() - INTERVAL '6 hours'
        AND ended_at IS NULL;
        
    -- Log the cleanup
    RAISE NOTICE 'Cleaned up % orphaned sessions', ROW_COUNT;
END;
$$ LANGUAGE plpgsql;


================================================
FILE: supabase/migrations/20250714134701-b2cbea28-c52b-401f-a7e8-024402d20e9a.sql
================================================
-- Phase 2A: Fix Session History Data Issues
-- Step 1: Create trigger function to update transcript_count automatically
CREATE OR REPLACE FUNCTION update_transcript_count()
RETURNS TRIGGER AS $$
BEGIN
    -- Handle INSERT: increment transcript_count
    IF TG_OP = 'INSERT' THEN
        UPDATE room_sessions 
        SET transcript_count = transcript_count + 1,
            updated_at = NOW()
        WHERE id = NEW.session_id;
        RETURN NEW;
    END IF;
    
    -- Handle DELETE: decrement transcript_count
    IF TG_OP = 'DELETE' THEN
        UPDATE room_sessions 
        SET transcript_count = GREATEST(transcript_count - 1, 0),
            updated_at = NOW()
        WHERE id = OLD.session_id;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Create trigger on transcripts table
DROP TRIGGER IF EXISTS sync_transcript_count_trigger ON transcripts;
CREATE TRIGGER sync_transcript_count_trigger
    AFTER INSERT OR DELETE ON transcripts
    FOR EACH ROW
    EXECUTE FUNCTION update_transcript_count();

-- Step 2: Fix duration calculations for existing sessions
UPDATE room_sessions 
SET 
    duration_minutes = EXTRACT(EPOCH FROM (ended_at - started_at))/60,
    updated_at = NOW()
WHERE 
    ended_at IS NOT NULL 
    AND started_at IS NOT NULL 
    AND (duration_minutes = 0 OR duration_minutes IS NULL);

-- Step 3: Backfill transcript counts for existing sessions
UPDATE room_sessions 
SET 
    transcript_count = (
        SELECT COUNT(*) 
        FROM transcripts 
        WHERE transcripts.session_id = room_sessions.id
    ),
    updated_at = NOW()
WHERE transcript_count = 0;

-- Step 4: Update existing cleanup function to ensure proper duration calculation
CREATE OR REPLACE FUNCTION public.cleanup_room_sessions(room_id_param integer)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  -- End any active sessions for this room with proper duration calculation
  UPDATE public.room_sessions 
  SET 
    status = 'completed', 
    ended_at = now(),
    duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60,
    updated_at = now()
  WHERE room_id = room_id_param 
    AND status = 'active';
    
  -- Update room status back to empty
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id = room_id_param;
END;
$function$

-- Update existing stale session cleanup function
CREATE OR REPLACE FUNCTION public.cleanup_stale_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  -- Cleanup sessions older than 2 hours that are still active with proper duration
  UPDATE public.room_sessions 
  SET 
    status = 'completed', 
    ended_at = now(),
    duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60,
    updated_at = now()
  WHERE status = 'active' 
    AND started_at < (now() - interval '2 hours');
    
  -- Update room status back to empty for affected rooms
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id IN (
    SELECT DISTINCT room_id 
    FROM public.room_sessions 
    WHERE status = 'completed' 
      AND ended_at >= (now() - interval '5 minutes')
  );
END;
$function$

-- Update the validate_session_times trigger to include duration calculation
CREATE OR REPLACE FUNCTION public.validate_session_times()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
    -- If status is changing to completed/failed, ensure ended_at is set
    IF NEW.status IN ('completed', 'failed') AND NEW.ended_at IS NULL THEN
        NEW.ended_at = NOW();
    END IF;
    
    -- Calculate duration when ended_at is set
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
        NEW.duration_minutes = EXTRACT(EPOCH FROM (NEW.ended_at - NEW.started_at))/60;
    END IF;
    
    -- Ensure ended_at is after started_at
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL AND NEW.ended_at < NEW.started_at THEN
        RAISE EXCEPTION 'ended_at must be after started_at';
    END IF;
    
    RETURN NEW;
END;
$function$


================================================
FILE: supabase/migrations/20250714134715-38c3e185-5799-484c-a196-697fc6c2938d.sql
================================================
-- Phase 2A: Fix Session History Data Issues
-- Step 1: Create trigger function to update transcript_count automatically
CREATE OR REPLACE FUNCTION update_transcript_count()
RETURNS TRIGGER AS $$
BEGIN
    -- Handle INSERT: increment transcript_count
    IF TG_OP = 'INSERT' THEN
        UPDATE room_sessions 
        SET transcript_count = transcript_count + 1,
            updated_at = NOW()
        WHERE id = NEW.session_id;
        RETURN NEW;
    END IF;
    
    -- Handle DELETE: decrement transcript_count
    IF TG_OP = 'DELETE' THEN
        UPDATE room_sessions 
        SET transcript_count = GREATEST(transcript_count - 1, 0),
            updated_at = NOW()
        WHERE id = OLD.session_id;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Create trigger on transcripts table
DROP TRIGGER IF EXISTS sync_transcript_count_trigger ON transcripts;

CREATE TRIGGER sync_transcript_count_trigger
    AFTER INSERT OR DELETE ON transcripts
    FOR EACH ROW
    EXECUTE FUNCTION update_transcript_count();


================================================
FILE: supabase/migrations/20250714134724-65b7ebeb-b1c6-41a8-9769-24ba41b88174.sql
================================================
-- Step 2: Fix duration calculations for existing sessions
UPDATE room_sessions 
SET 
    duration_minutes = EXTRACT(EPOCH FROM (ended_at - started_at))/60,
    updated_at = NOW()
WHERE 
    ended_at IS NOT NULL 
    AND started_at IS NOT NULL 
    AND (duration_minutes = 0 OR duration_minutes IS NULL);

-- Step 3: Backfill transcript counts for existing sessions
UPDATE room_sessions 
SET 
    transcript_count = (
        SELECT COUNT(*) 
        FROM transcripts 
        WHERE transcripts.session_id = room_sessions.id
    ),
    updated_at = NOW()
WHERE transcript_count = 0;


================================================
FILE: supabase/migrations/20250714134736-13926ada-5092-4b36-9a7c-5fb266a3b118.sql
================================================
-- Step 4: Update the validate_session_times trigger to include duration calculation
CREATE OR REPLACE FUNCTION public.validate_session_times()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
    -- If status is changing to completed/failed, ensure ended_at is set
    IF NEW.status IN ('completed', 'failed') AND NEW.ended_at IS NULL THEN
        NEW.ended_at = NOW();
    END IF;
    
    -- Calculate duration when ended_at is set
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
        NEW.duration_minutes = EXTRACT(EPOCH FROM (NEW.ended_at - NEW.started_at))/60;
    END IF;
    
    -- Ensure ended_at is after started_at
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL AND NEW.ended_at < NEW.started_at THEN
        RAISE EXCEPTION 'ended_at must be after started_at';
    END IF;
    
    RETURN NEW;
END;
$function$


================================================
FILE: supabase/migrations/20250714135020-a8c95995-d0e6-443d-bee2-8d53ee0c7b60.sql
================================================
-- Option A: Change duration_minutes to store fractional minutes
-- Step 1: Change duration_minutes column type to numeric for fractional precision
ALTER TABLE room_sessions 
ALTER COLUMN duration_minutes TYPE NUMERIC(8,3);

-- Step 2: Update existing duration calculations to use fractional minutes
UPDATE room_sessions 
SET duration_minutes = EXTRACT(EPOCH FROM (ended_at - started_at))/60.0
WHERE ended_at IS NOT NULL AND started_at IS NOT NULL;

-- Step 3: Update the validate_session_times function to calculate fractional minutes
CREATE OR REPLACE FUNCTION public.validate_session_times()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
    -- If status is changing to completed/failed, ensure ended_at is set
    IF NEW.status IN ('completed', 'failed') AND NEW.ended_at IS NULL THEN
        NEW.ended_at = NOW();
    END IF;
    
    -- Calculate duration when ended_at is set (using fractional minutes)
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
        NEW.duration_minutes = EXTRACT(EPOCH FROM (NEW.ended_at - NEW.started_at))/60.0;
    END IF;
    
    -- Ensure ended_at is after started_at
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL AND NEW.ended_at < NEW.started_at THEN
        RAISE EXCEPTION 'ended_at must be after started_at';
    END IF;
    
    RETURN NEW;
END;
$function$;

-- Step 4: Update cleanup functions to use fractional minutes
CREATE OR REPLACE FUNCTION public.cleanup_room_sessions(room_id_param integer)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  -- End any active sessions for this room
  UPDATE public.room_sessions 
  SET status = 'completed', 
      ended_at = now(),
      duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60.0
  WHERE room_id = room_id_param 
    AND status = 'active';
    
  -- Update room status back to empty
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id = room_id_param;
END;
$function$;

CREATE OR REPLACE FUNCTION public.cleanup_stale_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  -- Cleanup sessions older than 2 hours that are still active
  UPDATE public.room_sessions 
  SET status = 'completed', 
      ended_at = now(),
      duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60.0
  WHERE status = 'active' 
    AND started_at < (now() - interval '2 hours');
    
  -- Update room status back to empty for affected rooms
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id IN (
    SELECT DISTINCT room_id 
    FROM public.room_sessions 
    WHERE status = 'completed' 
      AND ended_at >= (now() - interval '5 minutes')
  );
END;
$function$;


================================================
FILE: supabase/migrations/20250714155147-bc472851-529f-48cd-8f77-bc4d0bf161df.sql
================================================
-- Remove sentence_id column and index from transcripts table
-- This cleans up after the code revert to ensure database matches codebase

-- Drop the index first
DROP INDEX IF EXISTS idx_transcripts_sentence_id;

-- Drop the sentence_id column
ALTER TABLE public.transcripts 
DROP COLUMN IF EXISTS sentence_id;


================================================
FILE: supabase/migrations/20250715014448-9fbe9f78-f7e5-4013-8a64-b402953f8cac.sql
================================================
-- Create prompt_templates table for AI translation prompts
CREATE TABLE IF NOT EXISTS public.prompt_templates (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    content_type TEXT NOT NULL,
    prompt_template TEXT NOT NULL,
    template_variables JSONB DEFAULT '{}',
    mosque_id INTEGER REFERENCES public."Mosque"(id),
    is_default BOOLEAN NOT NULL DEFAULT false,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.prompt_templates ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Super admins can manage all prompt templates" 
ON public.prompt_templates 
FOR ALL 
USING (public.is_current_user_super_admin());

CREATE POLICY "Mosque admins can manage their custom templates" 
ON public.prompt_templates 
FOR ALL 
USING (mosque_id = (SELECT mosque_id FROM public.users WHERE id = auth.uid()));

CREATE POLICY "All authenticated users can read default templates" 
ON public.prompt_templates 
FOR SELECT 
USING (is_default = true AND is_active = true);

-- Create updated_at trigger
CREATE TRIGGER update_prompt_templates_updated_at
    BEFORE UPDATE ON public.prompt_templates
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

-- Insert default prompt templates
INSERT INTO public.prompt_templates (name, description, content_type, prompt_template, template_variables, is_default, is_active) VALUES
('Formal Friday Sermon', 'Professional translation for Friday prayers', 'sermon', 'You are translating a Friday sermon from {dialect} {source_language} to {target_language}. This is a {style} religious speech for a {audience} audience. {terminology} Islamic terms like Allah, Salah, Zakat in Arabic. Use respectful {style} language appropriate for worship settings.', '{"style": "formal", "context": "friday", "terminology": "preserve", "audience": "general", "dialect": "iraqi", "preserve_terms": ["Allah", "Salah", "Zakat", "Hajj", "Umrah", "Jummah"]}', true, true),
('Casual Community Announcement', 'Friendly tone for community updates', 'announcement', 'You are translating a community announcement from {dialect} {source_language} to {target_language}. Use a {style} and welcoming tone suitable for {audience} audience. {terminology} common Islamic terms while making the content accessible.', '{"style": "casual", "context": "community", "terminology": "explain", "audience": "general", "dialect": "iraqi", "preserve_terms": ["Inshallah", "Mashallah", "Barakallahu"]}', true, true),
('Academic Islamic Lecture', 'Scholarly translation for educational content', 'lecture', 'You are translating an Islamic lecture from {dialect} {source_language} to {target_language}. This is {style} educational content for {audience}. {terminology} Islamic terminology and provide context where needed. Maintain scholarly precision while ensuring clarity.', '{"style": "academic", "context": "educational", "terminology": "explain", "audience": "scholars", "dialect": "iraqi", "preserve_terms": ["Hadith", "Quran", "Sunnah", "Fiqh", "Tafsir"]}', true, true),
('Youth-Friendly Presentation', 'Engaging translation for younger audiences', 'lecture', 'You are translating content from {dialect} {source_language} to {target_language} for a {audience} audience. Use {style} and engaging language. {terminology} Islamic concepts in an accessible way that resonates with young people while maintaining respect.', '{"style": "youth", "context": "educational", "terminology": "explain", "audience": "children", "dialect": "iraqi", "preserve_terms": ["Dua", "Dunya", "Akhirah", "Taqwa"]}', true, true);

-- Add prompt_template_id column to rooms table
ALTER TABLE public.rooms 
ADD COLUMN IF NOT EXISTS prompt_template_id UUID REFERENCES public.prompt_templates(id);


================================================
FILE: supabase/migrations/20250715023131-698d1daa-dd77-4d24-85a7-ab917259a2f9.sql
================================================
-- Add created_at timestamp field to rooms table
ALTER TABLE public.rooms 
ADD COLUMN created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now();

-- Add updated_at timestamp field for completeness
ALTER TABLE public.rooms 
ADD COLUMN updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now();

-- Create trigger to automatically update updated_at
CREATE TRIGGER update_rooms_updated_at
BEFORE UPDATE ON public.rooms
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();


================================================
FILE: supabase/migrations/20250715221309-b8da9b25-00e3-4f27-a57b-d97fd8cbb2b7.sql
================================================
-- Create gentler cleanup functions that don't immediately kill active LiveKit sessions

-- Function to check if a session is truly abandoned (no activity for specified minutes)
CREATE OR REPLACE FUNCTION public.is_session_abandoned(session_id_param UUID, minutes_threshold INTEGER DEFAULT 10)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  session_start TIMESTAMP WITH TIME ZONE;
  last_transcript TIMESTAMP WITH TIME ZONE;
BEGIN
  -- Get session start time
  SELECT started_at INTO session_start 
  FROM public.room_sessions 
  WHERE id = session_id_param;
  
  IF session_start IS NULL THEN
    RETURN true; -- Session doesn't exist, consider abandoned
  END IF;
  
  -- Get most recent transcript for this session
  SELECT MAX(created_at) INTO last_transcript
  FROM public.transcripts 
  WHERE session_id = session_id_param;
  
  -- If no transcripts and session is old, consider abandoned
  IF last_transcript IS NULL THEN
    RETURN (session_start < NOW() - (minutes_threshold || ' minutes')::INTERVAL);
  END IF;
  
  -- If last transcript is old, consider abandoned
  RETURN (last_transcript < NOW() - (minutes_threshold || ' minutes')::INTERVAL);
END;
$$;

-- Gentle cleanup function that only cleans up truly abandoned sessions
CREATE OR REPLACE FUNCTION public.gentle_cleanup_room_sessions(room_id_param INTEGER, minutes_threshold INTEGER DEFAULT 10)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  cleaned_sessions INTEGER := 0;
  session_record RECORD;
BEGIN
  -- Find active sessions for this room
  FOR session_record IN 
    SELECT id, started_at FROM public.room_sessions 
    WHERE room_id = room_id_param AND status = 'active'
  LOOP
    -- Only cleanup if session is truly abandoned
    IF public.is_session_abandoned(session_record.id, minutes_threshold) THEN
      UPDATE public.room_sessions
      SET 
        status = 'completed',
        ended_at = CURRENT_TIMESTAMP,
        logging_enabled = false,
        duration_minutes = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - session_record.started_at)) / 60
      WHERE id = session_record.id;
      
      cleaned_sessions := cleaned_sessions + 1;
      RAISE NOTICE 'Cleaned up abandoned session % (inactive for % minutes)', session_record.id, minutes_threshold;
    END IF;
  END LOOP;
  
  -- Only set room to empty if we actually cleaned up sessions
  IF cleaned_sessions > 0 THEN
    -- Check if there are still active sessions
    IF NOT EXISTS (
      SELECT 1 FROM public.room_sessions 
      WHERE room_id = room_id_param AND status = 'active'
    ) THEN
      UPDATE public.rooms
      SET status = 'empty', updated_at = CURRENT_TIMESTAMP
      WHERE id = room_id_param;
      RAISE NOTICE 'Set room % to empty after cleaning % abandoned sessions', room_id_param, cleaned_sessions;
    END IF;
  END IF;
  
  RETURN cleaned_sessions;
END;
$$;

-- Function to attempt session recovery before cleanup
CREATE OR REPLACE FUNCTION public.recover_or_cleanup_session(room_id_param INTEGER, user_id_param UUID)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  existing_session_id UUID;
  new_session_id UUID;
  mosque_id_val INTEGER;
BEGIN
  -- Get mosque_id for the room
  SELECT mosque_id INTO mosque_id_val FROM public.rooms WHERE id = room_id_param;
  
  -- Check for recent active session (less than 5 minutes old)
  SELECT id INTO existing_session_id
  FROM public.room_sessions
  WHERE room_id = room_id_param 
    AND status = 'active'
    AND started_at > NOW() - INTERVAL '5 minutes'
  ORDER BY started_at DESC
  LIMIT 1;
  
  -- If we found a recent session, try to recover it
  IF existing_session_id IS NOT NULL THEN
    RAISE NOTICE 'Recovering existing session % for room %', existing_session_id, room_id_param;
    RETURN existing_session_id;
  END IF;
  
  -- No recent session found, do gentle cleanup first
  PERFORM public.gentle_cleanup_room_sessions(room_id_param, 10);
  
  -- Create new session
  INSERT INTO public.room_sessions (room_id, mosque_id, status, logging_enabled)
  VALUES (room_id_param, mosque_id_val, 'active', true)
  RETURNING id INTO new_session_id;
  
  -- Update room status to live
  UPDATE public.rooms 
  SET status = 'live', updated_at = CURRENT_TIMESTAMP
  WHERE id = room_id_param;
  
  RAISE NOTICE 'Created new session % for room %', new_session_id, room_id_param;
  RETURN new_session_id;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.is_session_abandoned(UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.gentle_cleanup_room_sessions(INTEGER, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.recover_or_cleanup_session(INTEGER, UUID) TO authenticated;


================================================
FILE: supabase/migrations/20250715_prompt_templates.sql
================================================
-- Create prompt templates table for customizable translation prompts
CREATE TABLE IF NOT EXISTS prompt_templates (
    id SERIAL PRIMARY KEY,
    mosque_id INTEGER REFERENCES mosques(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    content_type VARCHAR(50) NOT NULL CHECK (content_type IN ('sermon', 'announcement', 'dua', 'lecture', 'general')),
    prompt_template TEXT NOT NULL,
    template_variables JSONB DEFAULT '{}',
    is_default BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Add indexes
CREATE INDEX idx_prompt_templates_mosque_id ON prompt_templates(mosque_id);
CREATE INDEX idx_prompt_templates_content_type ON prompt_templates(content_type);
CREATE INDEX idx_prompt_templates_is_default ON prompt_templates(is_default);

-- Add prompt template reference to rooms table
ALTER TABLE rooms ADD COLUMN IF NOT EXISTS prompt_template_id INTEGER REFERENCES prompt_templates(id);

-- Create default prompt templates
INSERT INTO prompt_templates (mosque_id, name, description, content_type, prompt_template, template_variables, is_default) VALUES
(
    NULL, -- Global template
    'Friday Sermon (Formal)',
    'Formal translation style for Friday khutbah with preservation of Islamic terms',
    'sermon',
    'You are an expert interpreter translating a Friday sermon (khutbah) from {source_lang} to {target_lang}. This is a formal religious speech delivered in a mosque. Maintain the reverent and formal tone appropriate for worship. Preserve key Islamic terms like ''Allah'', ''Salah'', ''Zakat'', ''Hajj'' in Arabic. When Quranic verses are quoted, indicate this clearly. Translate the meaning accurately while keeping the language dignified and accessible to the congregation.',
    '{
        "style": "formal",
        "preserve_terms": ["Allah", "Salah", "Zakat", "Hajj", "Ummah", "Sunnah"],
        "audience": "general congregation",
        "tone": "reverent"
    }',
    true
),
(
    NULL, -- Global template
    'Community Announcement',
    'Clear and direct translation for mosque announcements',
    'announcement',
    'You are translating a community announcement from {source_lang} to {target_lang} in a mosque setting. Be clear, concise, and direct. Focus on conveying practical information accurately. Use simple language that everyone can understand. Keep cultural sensitivity in mind while ensuring the message is fully understood.',
    '{
        "style": "clear_direct",
        "preserve_terms": ["Insha''Allah", "Masjid"],
        "audience": "general community",
        "tone": "informative"
    }',
    true
),
(
    NULL, -- Global template
    'Dua and Prayers',
    'Reverent translation maintaining the spiritual essence of prayers',
    'dua',
    'You are translating prayers (dua) from {source_lang} to {target_lang}. Maintain the deeply spiritual and reverent nature of the supplication. Preserve the emotional and devotional quality. Keep common Arabic phrases like ''Ameen'', ''Subhanallah'', ''Alhamdulillah'' untranslated. Convey the meaning while preserving the prayer''s spiritual impact.',
    '{
        "style": "spiritual",
        "preserve_terms": ["Ameen", "Subhanallah", "Alhamdulillah", "Bismillah", "Astaghfirullah"],
        "audience": "worshippers",
        "tone": "devotional"
    }',
    true
),
(
    NULL, -- Global template
    'Islamic Lecture',
    'Educational translation with explanatory context',
    'lecture',
    'You are translating an Islamic educational lecture from {source_lang} to {target_lang}. The speaker is teaching religious concepts. Provide clear explanations while maintaining accuracy. When technical Islamic terms are used, you may briefly explain them in parentheses if needed for clarity. Balance between preserving authenticity and ensuring understanding.',
    '{
        "style": "educational",
        "preserve_terms": ["Fiqh", "Hadith", "Tafsir", "Aqeedah"],
        "audience": "students and learners",
        "tone": "instructional"
    }',
    true
);

-- Function to get applicable prompt template for a room
CREATE OR REPLACE FUNCTION get_room_prompt_template(room_id INTEGER)
RETURNS TABLE (
    id INTEGER,
    name VARCHAR(100),
    prompt_template TEXT,
    template_variables JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT pt.id, pt.name, pt.prompt_template, pt.template_variables
    FROM rooms r
    LEFT JOIN prompt_templates pt ON r.prompt_template_id = pt.id
    WHERE r.id = room_id
    AND pt.is_active = true
    UNION ALL
    SELECT pt.id, pt.name, pt.prompt_template, pt.template_variables
    FROM prompt_templates pt
    WHERE pt.is_default = true
    AND pt.is_active = true
    AND NOT EXISTS (
        SELECT 1 FROM rooms r WHERE r.id = room_id AND r.prompt_template_id IS NOT NULL
    )
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- RLS Policies
ALTER TABLE prompt_templates ENABLE ROW LEVEL SECURITY;

-- Policy: Super admins can do everything
CREATE POLICY "Super admins can manage all prompt templates" ON prompt_templates
    FOR ALL
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM user_profiles
            WHERE user_profiles.id = auth.uid()
            AND user_profiles.role = 'super_admin'
        )
    );

-- Policy: Mosque admins can manage their mosque's templates
CREATE POLICY "Mosque admins can manage their templates" ON prompt_templates
    FOR ALL
    TO authenticated
    USING (
        mosque_id IS NULL -- Can view global templates
        OR
        EXISTS (
            SELECT 1 FROM user_profiles
            WHERE user_profiles.id = auth.uid()
            AND user_profiles.role = 'mosque_admin'
            AND user_profiles.mosque_id = prompt_templates.mosque_id
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM user_profiles
            WHERE user_profiles.id = auth.uid()
            AND user_profiles.role = 'mosque_admin'
            AND user_profiles.mosque_id = prompt_templates.mosque_id
        )
    );

-- Policy: All users can read default templates
CREATE POLICY "All users can read default templates" ON prompt_templates
    FOR SELECT
    TO authenticated
    USING (is_default = true);

-- Update timestamp trigger
CREATE TRIGGER update_prompt_templates_updated_at
    BEFORE UPDATE ON prompt_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


================================================
FILE: supabase/migrations/20250717012925-a63b093a-9263-448d-b26b-e1b3ddfb035f.sql
================================================
-- Add missing fields to users table
ALTER TABLE public.users
ADD COLUMN IF NOT EXISTS full_name TEXT,
ADD COLUMN IF NOT EXISTS email TEXT,
ADD COLUMN IF NOT EXISTS "Role" TEXT DEFAULT 'User',
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS avatar_url TEXT,
ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();

-- Add missing fields to Mosque table
ALTER TABLE public."Mosque"
ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_mosque_id ON public.users(mosque_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_role ON public.users("Role");
CREATE INDEX IF NOT EXISTS idx_mosque_subdomain ON public."Mosque"("Subdomain");

-- Create a function to sync user data from auth.users
CREATE OR REPLACE FUNCTION public.sync_user_data()
RETURNS TRIGGER AS $$
BEGIN
  -- Update email from auth.users if it exists
  UPDATE public.users
  SET 
    email = auth.users.email,
    updated_at = NOW()
  FROM auth.users
  WHERE public.users.id = auth.users.id
  AND public.users.id = NEW.id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to sync email on user insert/update
DROP TRIGGER IF EXISTS sync_user_data_trigger ON public.users;
CREATE TRIGGER sync_user_data_trigger
AFTER INSERT OR UPDATE ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.sync_user_data();

-- Update existing users with email from auth.users
UPDATE public.users u
SET 
  email = au.email,
  created_at = COALESCE(u.created_at, au.created_at),
  updated_at = NOW()
FROM auth.users au
WHERE u.id = au.id;

-- Add RLS policies for the new fields
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."Mosque" ENABLE ROW LEVEL SECURITY;

-- Policy for users to read their own data
CREATE POLICY "Users can view own profile" ON public.users
  FOR SELECT USING (auth.uid() = id);

-- Policy for admins to view all users in their mosque
CREATE POLICY "Admins can view mosque users" ON public.users
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.users admin
      WHERE admin.id = auth.uid()
      AND admin."Role" = 'Admin'
      AND admin.mosque_id = users.mosque_id
    )
  );

-- Policy for super admins to view all users
CREATE POLICY "Super admins can view all users" ON public.users
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.users su
      WHERE su.id = auth.uid()
      AND su.is_super_admin = true
    )
  );

-- Policy for super admins to update users
CREATE POLICY "Super admins can update users" ON public.users
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.users su
      WHERE su.id = auth.uid()
      AND su.is_super_admin = true
    )
  );

-- Policy for super admins to delete users
CREATE POLICY "Super admins can delete users" ON public.users
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM public.users su
      WHERE su.id = auth.uid()
      AND su.is_super_admin = true
    )
  );

-- Mosque policies
CREATE POLICY "Anyone can view mosques" ON public."Mosque"
  FOR SELECT USING (true);

CREATE POLICY "Super admins can manage mosques" ON public."Mosque"
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE users.id = auth.uid()
      AND users.is_super_admin = true
    )
  );

-- Add comment for documentation
COMMENT ON COLUMN public.users."Role" IS 'User role: User, Admin, or Super Admin (use is_super_admin flag for super admins)';
COMMENT ON COLUMN public.users.full_name IS 'User full name for display purposes';
COMMENT ON COLUMN public.users.email IS 'Synced from auth.users.email';
COMMENT ON COLUMN public.users.is_active IS 'Whether the user account is active';
COMMENT ON COLUMN public."Mosque".is_active IS 'Whether the mosque is active';


================================================
FILE: supabase/migrations/20250717012951-51d4f895-5f99-48c1-b5a3-dd6b88a81ff4.sql
================================================
-- Add missing fields to users table
ALTER TABLE public.users
ADD COLUMN IF NOT EXISTS full_name TEXT,
ADD COLUMN IF NOT EXISTS email TEXT,
ADD COLUMN IF NOT EXISTS "Role" TEXT DEFAULT 'User',
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS avatar_url TEXT,
ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();

-- Add missing fields to Mosque table
ALTER TABLE public."Mosque"
ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_mosque_id ON public.users(mosque_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_role ON public.users("Role");
CREATE INDEX IF NOT EXISTS idx_mosque_subdomain ON public."Mosque"("Subdomain");

-- Update existing users with email from auth.users (without trigger to avoid recursion)
UPDATE public.users u
SET 
  email = au.email,
  full_name = COALESCE(u.full_name, au.raw_user_meta_data->>'full_name', au.email),
  created_at = COALESCE(u.created_at, au.created_at),
  updated_at = NOW()
FROM auth.users au
WHERE u.id = au.id;

-- Add comment for documentation
COMMENT ON COLUMN public.users."Role" IS 'User role: User, Admin, or Super Admin (use is_super_admin flag for super admins)';
COMMENT ON COLUMN public.users.full_name IS 'User full name for display purposes';
COMMENT ON COLUMN public.users.email IS 'Synced from auth.users.email';
COMMENT ON COLUMN public.users.is_active IS 'Whether the user account is active';
COMMENT ON COLUMN public."Mosque".is_active IS 'Whether the mosque is active';


================================================
FILE: supabase/migrations/20250717013106-985d0313-93be-4edc-8414-30457903c82c.sql
================================================
-- Set default Role for users without one
UPDATE public.users
SET "Role" = 'User'
WHERE "Role" IS NULL;

-- Set default is_active status for users
UPDATE public.users
SET is_active = true
WHERE is_active IS NULL;

-- Update super admins to have Admin role (they use is_super_admin flag)
UPDATE public.users
SET "Role" = 'Admin'
WHERE is_super_admin = true;

-- Set created_at for users that don't have it
UPDATE public.users
SET created_at = NOW()
WHERE created_at IS NULL;

-- Set updated_at for all users that don't have it
UPDATE public.users
SET updated_at = NOW()
WHERE updated_at IS NULL;

-- Update Mosque records with default timestamps
UPDATE public."Mosque"
SET 
  created_at = COALESCE(created_at, NOW()),
  updated_at = COALESCE(updated_at, NOW()),
  is_active = COALESCE(is_active, true);

-- Create a trigger function to auto-update the updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply the trigger to users table
DROP TRIGGER IF EXISTS set_users_updated_at ON public.users;
CREATE TRIGGER set_users_updated_at
BEFORE UPDATE ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Apply the trigger to Mosque table
DROP TRIGGER IF EXISTS set_mosque_updated_at ON public."Mosque";
CREATE TRIGGER set_mosque_updated_at
BEFORE UPDATE ON public."Mosque"
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Add helpful comments
COMMENT ON FUNCTION public.handle_updated_at() IS 'Updates the updated_at timestamp on row update';
COMMENT ON TRIGGER set_users_updated_at ON public.users IS 'Auto-updates the updated_at timestamp when user record is modified';
COMMENT ON TRIGGER set_mosque_updated_at ON public."Mosque" IS 'Auto-updates the updated_at timestamp when mosque record is modified';


================================================
FILE: supabase/migrations/20250717165115-859344f0-b44d-492e-8323-a3632dc48d22.sql
================================================
-- Fix the get_room_prompt_template function to return the structure expected by the backend
-- The backend expects: prompt_template, template_variables (as JSONB), and name

-- First, let's drop the existing function
DROP FUNCTION IF EXISTS get_room_prompt_template(INTEGER);
DROP FUNCTION IF EXISTS public.get_room_prompt_template(BIGINT);

-- Create the new function that matches backend expectations
CREATE OR REPLACE FUNCTION public.get_room_prompt_template(room_id BIGINT)
RETURNS TABLE(
    prompt_template TEXT,
    template_variables JSONB,
    name TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        -- Get the prompt template or use a default one
        COALESCE(
            pt.prompt_template,
            'You are an expert simultaneous interpreter. Your task is to translate from {source_lang} to {target_lang}. Provide a direct and accurate translation of the user''s input. Be concise and use natural-sounding language. Do not add any additional commentary, explanations, or introductory phrases.'
        ) as prompt_template,
        -- Get template variables or construct them from room data
        COALESCE(
            pt.template_variables,
            jsonb_build_object(
                'source_lang', r.transcription_language,
                'target_lang', r.translation__language,
                'dialect', COALESCE(r.transcription_language, 'Arabic'),
                'context_instructions', 'Maintain cultural sensitivity and preserve key religious terms where appropriate.',
                'style', 'formal',
                'preserve_terms', ARRAY['Allah', 'Salah', 'Zakat', 'Hajj', 'Ummah', 'Sunnah'],
                'audience', 'general congregation',
                'tone', 'reverent'
            )
        ) as template_variables,
        -- Get the template name or provide a default
        COALESCE(
            pt.name,
            'Default Translation Template'
        ) as name
    FROM rooms r
    LEFT JOIN prompt_templates pt ON r.prompt_template_id = pt.id AND pt.is_active = true
    WHERE r.id = room_id;
    
    -- If no room found, return NULL
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            NULL::TEXT as prompt_template,
            NULL::JSONB as template_variables,
            NULL::TEXT as name;
    END IF;
END;
$$;

-- Grant appropriate permissions
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_room_prompt_template(BIGINT) TO anon;

-- Add a comment to document the function
COMMENT ON FUNCTION public.get_room_prompt_template(BIGINT) IS 
'Returns the prompt template and language configuration for a given room. Used by the transcription backend to customize translation prompts.';


================================================
FILE: supabase/migrations/20250726022146-62c50d2b-b695-4bd4-9954-2af2aa3a1356.sql
================================================
-- CRITICAL SECURITY FIXES
-- Phase 1: Database Security Implementation

-- 1. Enable RLS on system_logs table (Critical - Currently unprotected)
ALTER TABLE public.system_logs ENABLE ROW LEVEL SECURITY;

-- Create policy to allow only super admins to access system logs
CREATE POLICY "Super admins can access system logs" 
ON public.system_logs 
FOR ALL 
USING (public.is_current_user_super_admin());

-- 2. Add search_path protection to all database functions (Critical - Prevents SQL injection)
-- This secures all 28 functions identified in the security review

-- Update all existing functions to include search_path protection
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.is_current_user_super_admin()
RETURNS boolean
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  );
END;
$function$;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.cleanup_expired_impersonation_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  UPDATE public.impersonation_sessions 
  SET is_active = false, ended_at = now()
  WHERE expires_at < now() AND is_active = true;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_mosque_users(mosque_id_param integer)
RETURNS TABLE(user_id uuid, email text, mosque_name text, is_super_admin boolean)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  -- Only allow super admins to call this function
  IF NOT public.is_current_user_super_admin() THEN
    RAISE EXCEPTION 'Access denied: Super admin privileges required';
  END IF;

  RETURN QUERY
  SELECT 
    u.id as user_id,
    au.email,
    m.name as mosque_name,
    u.is_super_admin
  FROM public.users u
  JOIN auth.users au ON u.id = au.id
  JOIN public.Mosque m ON u.mosque_id = m.id
  WHERE u.mosque_id = mosque_id_param
  ORDER BY au.email;
END;
$function$;

CREATE OR REPLACE FUNCTION public.generate_room_token(room_id_param integer)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  new_token UUID;
BEGIN
  -- Check if user has access to this room (same mosque)
  IF NOT EXISTS (
    SELECT 1 FROM public.rooms r
    JOIN public.users u ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: You can only generate tokens for rooms in your mosque';
  END IF;

  -- Generate new token
  new_token := gen_random_uuid();
  
  -- Update room with new token
  UPDATE public.rooms 
  SET access_token = new_token, token_enabled = true
  WHERE id = room_id_param;
  
  RETURN new_token;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_room_by_token(token_param uuid)
RETURNS TABLE(room_id integer, room_title text, mosque_id integer, mosque_name text, livekit_room_name text, transcription_language text, translation_language text)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id::INTEGER as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.access_token = token_param 
    AND r.token_enabled = true
    AND (r.token_expires_at IS NULL OR r.token_expires_at > now());
END;
$function$;

CREATE OR REPLACE FUNCTION public.toggle_room_public_access(room_id_param integer)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  new_status BOOLEAN;
BEGIN
  -- Check if user has access to this room (same mosque)
  IF NOT EXISTS (
    SELECT 1 FROM public.rooms r
    JOIN public.users u ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: You can only manage public access for rooms in your mosque';
  END IF;

  -- Toggle public access
  UPDATE public.rooms 
  SET public_access_enabled = NOT public_access_enabled
  WHERE id = room_id_param
  RETURNING public_access_enabled INTO new_status;
  
  RETURN new_status;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code integer)
RETURNS TABLE(room_id numeric, room_title text, mosque_id numeric, mosque_name text, livekit_room_name text, transcription_language text, translation_language text)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    r.id as room_id,
    r."Title" as room_title,
    r.mosque_id as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$function$;

-- 3. Audit critical RLS policies
-- Ensure impersonation sessions have proper time limits and access controls
CREATE OR REPLACE FUNCTION public.cleanup_stale_impersonation_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  -- End impersonation sessions older than 2 hours
  UPDATE public.impersonation_sessions 
  SET is_active = false, ended_at = now()
  WHERE is_active = true 
    AND created_at < (now() - interval '2 hours');
    
  -- Log the cleanup
  RAISE NOTICE 'Cleaned up % stale impersonation sessions', ROW_COUNT;
END;
$function$;

-- 4. Add security monitoring function
CREATE OR REPLACE FUNCTION public.log_security_event(
  event_type text,
  user_id uuid DEFAULT auth.uid(),
  event_data jsonb DEFAULT '{}'
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  INSERT INTO public.system_logs (
    event_type,
    event_data,
    created_at
  ) VALUES (
    'security_' || event_type,
    jsonb_build_object(
      'user_id', user_id,
      'timestamp', now(),
      'ip_address', current_setting('request.headers')::jsonb->>'x-forwarded-for',
      'user_agent', current_setting('request.headers')::jsonb->>'user-agent',
      'data', event_data
    ),
    now()
  );
END;
$function$;

-- Log successful completion of security fixes
INSERT INTO public.system_logs (event_type, event_data) 
VALUES ('security_fixes_phase1_complete', jsonb_build_object(
  'timestamp', now(),
  'fixes_applied', ARRAY[
    'rls_enabled_system_logs',
    'search_path_protection_added',
    'impersonation_session_cleanup',
    'security_monitoring_function'
  ]
));


================================================
FILE: supabase/migrations/20250726022354-6f18ecc8-651a-4f10-bb10-cd1aaf771121.sql
================================================
-- SECURITY FIXES - Phase 1 Continuation
-- Fix remaining functions that still need search_path protection

CREATE OR REPLACE FUNCTION public.update_transcript_count()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
BEGIN
    -- Handle INSERT: increment transcript_count
    IF TG_OP = 'INSERT' THEN
        UPDATE room_sessions 
        SET transcript_count = transcript_count + 1,
            updated_at = NOW()
        WHERE id = NEW.session_id;
        RETURN NEW;
    END IF;
    
    -- Handle DELETE: decrement transcript_count
    IF TG_OP = 'DELETE' THEN
        UPDATE room_sessions 
        SET transcript_count = GREATEST(transcript_count - 1, 0),
            updated_at = NOW()
        WHERE id = OLD.session_id;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$function$;

CREATE OR REPLACE FUNCTION public.cleanup_room_sessions(room_id_param integer)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  -- End any active sessions for this room
  UPDATE public.room_sessions 
  SET status = 'completed', 
      ended_at = now(),
      duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60.0
  WHERE room_id = room_id_param 
    AND status = 'active';
    
  -- Update room status back to empty
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id = room_id_param;
END;
$function$;

CREATE OR REPLACE FUNCTION public.start_room_monitoring(room_id_param integer)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  session_id uuid;
  mosque_id_val integer;
BEGIN
  -- Get mosque_id for the room
  SELECT mosque_id INTO mosque_id_val FROM public.rooms WHERE id = room_id_param;
  
  -- Check if user has permission (same mosque or super admin)
  IF NOT EXISTS (
    SELECT 1 FROM public.users u
    JOIN public.rooms r ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) AND NOT public.is_current_user_super_admin() THEN
    RAISE EXCEPTION 'Access denied: You can only monitor rooms from your mosque';
  END IF;
  
  -- Cleanup any existing active sessions for this room
  PERFORM public.cleanup_room_sessions(room_id_param);
  
  -- Update room status to live
  UPDATE public.rooms 
  SET status = 'live'
  WHERE id = room_id_param;
  
  -- Create new session
  INSERT INTO public.room_sessions (room_id, mosque_id, status, logging_enabled)
  VALUES (room_id_param, mosque_id_val, 'active', true)
  RETURNING id INTO session_id;
  
  RETURN session_id;
END;
$function$;

CREATE OR REPLACE FUNCTION public.cleanup_stale_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  -- Cleanup sessions older than 2 hours that are still active
  UPDATE public.room_sessions 
  SET status = 'completed', 
      ended_at = now(),
      duration_minutes = EXTRACT(EPOCH FROM (now() - started_at))/60.0
  WHERE status = 'active' 
    AND started_at < (now() - interval '2 hours');
    
  -- Update room status back to empty for affected rooms
  UPDATE public.rooms 
  SET status = 'empty'
  WHERE id IN (
    SELECT DISTINCT room_id 
    FROM public.room_sessions 
    WHERE status = 'completed' 
      AND ended_at >= (now() - interval '5 minutes')
  );
END;
$function$;

CREATE OR REPLACE FUNCTION public.sync_room_status_on_session_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  -- If session is ending, check if this is the last active session for the room
  IF (OLD.status = 'active' AND NEW.status != 'active') OR TG_OP = 'DELETE' THEN
    -- If no more active sessions exist for this room, set room status to empty
    IF NOT EXISTS (
      SELECT 1 FROM public.room_sessions 
      WHERE room_id = COALESCE(NEW.room_id, OLD.room_id) 
        AND status = 'active'
        AND id != COALESCE(NEW.id, OLD.id)
    ) THEN
      UPDATE public.rooms 
      SET status = 'empty'
      WHERE id = COALESCE(NEW.room_id, OLD.room_id);
    END IF;
  END IF;
  
  -- If session is starting, set room status to active
  IF (OLD IS NULL AND NEW.status = 'active') OR (OLD.status != 'active' AND NEW.status = 'active') THEN
    UPDATE public.rooms 
    SET status = 'active'
    WHERE id = NEW.room_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$function$;

CREATE OR REPLACE FUNCTION public.is_session_abandoned(session_id_param uuid, minutes_threshold integer DEFAULT 10)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  session_start TIMESTAMP WITH TIME ZONE;
  last_transcript TIMESTAMP WITH TIME ZONE;
BEGIN
  -- Get session start time
  SELECT started_at INTO session_start 
  FROM public.room_sessions 
  WHERE id = session_id_param;
  
  IF session_start IS NULL THEN
    RETURN true; -- Session doesn't exist, consider abandoned
  END IF;
  
  -- Get most recent transcript for this session
  SELECT MAX(created_at) INTO last_transcript
  FROM public.transcripts 
  WHERE session_id = session_id_param;
  
  -- If no transcripts and session is old, consider abandoned
  IF last_transcript IS NULL THEN
    RETURN (session_start < NOW() - (minutes_threshold || ' minutes')::INTERVAL);
  END IF;
  
  -- If last transcript is old, consider abandoned
  RETURN (last_transcript < NOW() - (minutes_threshold || ' minutes')::INTERVAL);
END;
$function$;

CREATE OR REPLACE FUNCTION public.gentle_cleanup_room_sessions(room_id_param integer, minutes_threshold integer DEFAULT 10)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  cleaned_sessions INTEGER := 0;
  session_record RECORD;
BEGIN
  -- Find active sessions for this room
  FOR session_record IN 
    SELECT id, started_at FROM public.room_sessions 
    WHERE room_id = room_id_param AND status = 'active'
  LOOP
    -- Only cleanup if session is truly abandoned
    IF public.is_session_abandoned(session_record.id, minutes_threshold) THEN
      UPDATE public.room_sessions
      SET 
        status = 'completed',
        ended_at = CURRENT_TIMESTAMP,
        logging_enabled = false,
        duration_minutes = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - session_record.started_at)) / 60
      WHERE id = session_record.id;
      
      cleaned_sessions := cleaned_sessions + 1;
      RAISE NOTICE 'Cleaned up abandoned session % (inactive for % minutes)', session_record.id, minutes_threshold;
    END IF;
  END LOOP;
  
  -- Only set room to empty if we actually cleaned up sessions
  IF cleaned_sessions > 0 THEN
    -- Check if there are still active sessions
    IF NOT EXISTS (
      SELECT 1 FROM public.room_sessions 
      WHERE room_id = room_id_param AND status = 'active'
    ) THEN
      UPDATE public.rooms
      SET status = 'empty', updated_at = CURRENT_TIMESTAMP
      WHERE id = room_id_param;
      RAISE NOTICE 'Set room % to empty after cleaning % abandoned sessions', room_id_param, cleaned_sessions;
    END IF;
  END IF;
  
  RETURN cleaned_sessions;
END;
$function$;

CREATE OR REPLACE FUNCTION public.update_room_status_on_session_change()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
BEGIN
    -- When a session becomes active, set room to live
    IF NEW.status = 'active' AND (OLD.status IS NULL OR OLD.status != 'active') THEN
        UPDATE rooms 
        SET status = 'live'
        WHERE id = NEW.room_id;
    END IF;
    
    -- When a session ends, check if room should be empty
    IF NEW.status IN ('completed', 'failed') AND OLD.status = 'active' THEN
        -- Check if there are other active sessions
        IF NOT EXISTS (
            SELECT 1 FROM room_sessions 
            WHERE room_id = NEW.room_id 
            AND id != NEW.id 
            AND status = 'active'
        ) THEN
            UPDATE rooms 
            SET status = 'empty'
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.cleanup_orphaned_sessions()
RETURNS void
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
BEGIN
    -- End sessions that have been active for more than 6 hours
    UPDATE room_sessions 
    SET 
        status = 'completed',
        ended_at = NOW()
    WHERE 
        status = 'active' 
        AND started_at < NOW() - INTERVAL '6 hours'
        AND ended_at IS NULL;
        
    -- Log the cleanup
    RAISE NOTICE 'Cleaned up % orphaned sessions', ROW_COUNT;
END;
$function$;

CREATE OR REPLACE FUNCTION public.recover_or_cleanup_session(room_id_param integer, user_id_param uuid)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  existing_session_id UUID;
  new_session_id UUID;
  mosque_id_val INTEGER;
BEGIN
  -- Get mosque_id for the room
  SELECT mosque_id INTO mosque_id_val FROM public.rooms WHERE id = room_id_param;
  
  -- Check for recent active session (less than 5 minutes old)
  SELECT id INTO existing_session_id
  FROM public.room_sessions
  WHERE room_id = room_id_param 
    AND status = 'active'
    AND started_at > NOW() - INTERVAL '5 minutes'
  ORDER BY started_at DESC
  LIMIT 1;
  
  -- If we found a recent session, try to recover it
  IF existing_session_id IS NOT NULL THEN
    RAISE NOTICE 'Recovering existing session % for room %', existing_session_id, room_id_param;
    RETURN existing_session_id;
  END IF;
  
  -- No recent session found, do gentle cleanup first
  PERFORM public.gentle_cleanup_room_sessions(room_id_param, 10);
  
  -- Create new session
  INSERT INTO public.room_sessions (room_id, mosque_id, status, logging_enabled)
  VALUES (room_id_param, mosque_id_val, 'active', true)
  RETURNING id INTO new_session_id;
  
  -- Update room status to live
  UPDATE public.rooms 
  SET status = 'live', updated_at = CURRENT_TIMESTAMP
  WHERE id = room_id_param;
  
  RAISE NOTICE 'Created new session % for room %', new_session_id, room_id_param;
  RETURN new_session_id;
END;
$function$;

CREATE OR REPLACE FUNCTION public.validate_session_times()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
BEGIN
    -- If status is changing to completed/failed, ensure ended_at is set
    IF NEW.status IN ('completed', 'failed') AND NEW.ended_at IS NULL THEN
        NEW.ended_at = NOW();
    END IF;
    
    -- Calculate duration when ended_at is set (using fractional minutes)
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
        NEW.duration_minutes = EXTRACT(EPOCH FROM (NEW.ended_at - NEW.started_at))/60.0;
    END IF;
    
    -- Ensure ended_at is after started_at
    IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL AND NEW.ended_at < NEW.started_at THEN
        RAISE EXCEPTION 'ended_at must be after started_at';
    END IF;
    
    RETURN NEW;
END;
$function$;


================================================
FILE: supabase/migrations/20250726022502-40dbb33a-66df-497b-9252-255e16f5402a.sql
================================================
-- SECURITY FIXES - Final Functions Remaining
-- Complete the search_path protection for all remaining functions

CREATE OR REPLACE FUNCTION public.cleanup_session_idempotent(session_id_param uuid, cleanup_source text DEFAULT 'unknown'::text, cleanup_timestamp timestamp with time zone DEFAULT now())
RETURNS jsonb
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
  DECLARE
    result JSONB;
    session_record room_sessions%ROWTYPE;
    lock_key BIGINT;
  BEGIN
    -- Generate a unique lock key based on session ID
    lock_key := ('x' || substr(md5(session_id_param::text), 1, 16))::bit(64)::bigint;

    -- Try to acquire advisory lock (non-blocking)
    IF NOT pg_try_advisory_xact_lock(lock_key) THEN
      -- Another process is already handling this session
      RAISE NOTICE 'Session % cleanup already in progress', session_id_param;

      -- Return current state without modifications
      SELECT to_jsonb(rs.*) INTO result
      FROM room_sessions rs
      WHERE rs.id = session_id_param;

      RETURN jsonb_build_object(
        'success', false,
        'reason', 'cleanup_in_progress',
        'session', result
      );
    END IF;

    -- Fetch current session state
    SELECT * INTO session_record
    FROM room_sessions
    WHERE id = session_id_param;

    IF NOT FOUND THEN
      RETURN jsonb_build_object(
        'success', false,
        'reason', 'session_not_found',
        'session', NULL
      );
    END IF;

    -- Check if already completed
    IF session_record.status = 'completed' THEN
      RAISE NOTICE 'Session % already completed at %', session_id_param, session_record.ended_at;

      RETURN jsonb_build_object(
        'success', true,
        'reason', 'already_completed',
        'session', to_jsonb(session_record)
      );
    END IF;

    -- Perform the cleanup
    UPDATE room_sessions
    SET
      status = 'completed',
      ended_at = COALESCE(ended_at, cleanup_timestamp),
      cleanup_source = COALESCE(room_sessions.cleanup_source, cleanup_session_idempotent.cleanup_source),
      cleanup_initiated_at = COALESCE(cleanup_initiated_at, cleanup_timestamp),
      cleanup_attempts = cleanup_attempts + 1,
      updated_at = cleanup_timestamp
    WHERE
      id = session_id_param
      AND status = 'active'
    RETURNING * INTO session_record;

    -- Update room status if no other active sessions
    IF session_record.id IS NOT NULL THEN
      PERFORM update_room_status_after_session_end(session_record.room_id);
    END IF;

    -- Log the cleanup event
    INSERT INTO system_logs (
      event_type,
      event_data,
      created_at
    ) VALUES (
      'session_cleanup',
      jsonb_build_object(
        'session_id', session_id_param,
        'cleanup_source', cleanup_source,
        'room_id', session_record.room_id,
        'mosque_id', session_record.mosque_id,
        'transcript_count', session_record.transcript_count
      ),
      cleanup_timestamp
    );

    RETURN jsonb_build_object(
      'success', true,
      'reason', 'cleanup_completed',
      'session', to_jsonb(session_record)
    );

  EXCEPTION
    WHEN OTHERS THEN
      -- Log error but don't fail
      RAISE WARNING 'Error in cleanup_session_idempotent: %', SQLERRM;

      RETURN jsonb_build_object(
        'success', false,
        'reason', 'error',
        'error', SQLERRM,
        'session', to_jsonb(session_record)
      );
  END;
  $function$;

CREATE OR REPLACE FUNCTION public.update_room_status_after_session_end(room_id_param integer)
RETURNS void
LANGUAGE plpgsql
SET search_path = 'public'
AS $function$
  BEGIN
    -- Check if any other active sessions exist
    IF NOT EXISTS (
      SELECT 1
      FROM room_sessions
      WHERE room_id = room_id_param
      AND status = 'active'
    ) THEN
      -- No active sessions, set room to empty
      UPDATE rooms
      SET
        status = 'empty',
        updated_at = NOW()
      WHERE
        id = room_id_param
        AND status != 'empty';

      RAISE NOTICE 'Room % set to empty status', room_id_param;
    END IF;
  END;
  $function$;

CREATE OR REPLACE FUNCTION public.debug_get_room_prompt_template(room_id bigint)
RETURNS TABLE(prompt_template text, template_variables jsonb, name text, debug_info text)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
  BEGIN
      RETURN QUERY
      SELECT
          pt.prompt_template,
          pt.template_variables,
          pt.name,
          CONCAT('Room: ', room_id, ', Template ID: ', COALESCE(r.prompt_template_id::TEXT, 'NULL'))::TEXT as debug_info
      FROM rooms r
      LEFT JOIN prompt_templates pt ON r.prompt_template_id = pt.id
      WHERE r.id = room_id;
  END;
  $function$;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  INSERT INTO public.users (id, mosque_id, is_super_admin)
  VALUES (
    NEW.id,
    1, -- Default to mosque_id 1, can be changed later by super admin
    false -- Default to false, super admin can promote users
  );
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_room_prompt_template(room_id bigint)
RETURNS TABLE(prompt_template text, template_variables jsonb, name text)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(
            pt.prompt_template,
            'You are an expert simultaneous interpreter. Your task is to translate from {source_lang} to {target_lang}. Provide a direct and accurate translation of the user''s input. Do not add any additional commentary, explanations, or introductory phrases. Be concise for real-time delivery.'
        )::TEXT as prompt_template,
        COALESCE(
            pt.template_variables,
            jsonb_build_object(
                'source_lang', r.transcription_language,
                'target_lang', r.translation__language,
                'style', 'formal',
                'preserve_terms', ARRAY['Allah', 'Salah', 'Zakat', 'Hajj', 'Ummah', 'Sunnah']::TEXT[],
                'audience', 'general congregation',
                'tone', 'reverent'
            )
        )::JSONB as template_variables,
        COALESCE(
            pt.name,
            'Default Translation Template'
        )::TEXT as name
    FROM rooms r
    LEFT JOIN prompt_templates pt ON r.prompt_template_id = pt.id AND pt.is_active = true
    WHERE r.id = room_id;
END;
$function$;

-- Update the no-parameter wrapper version too
CREATE OR REPLACE FUNCTION public.get_room_prompt_template()
RETURNS TABLE(
    prompt_template TEXT,
    template_variables JSONB,
    name TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
    -- Log warning about incorrect usage
    RAISE WARNING 'get_room_prompt_template called without parameters - this is likely a bug!';
    
    -- Return empty result
    RETURN QUERY
    SELECT 
        NULL::TEXT as prompt_template,
        NULL::JSONB as template_variables,
        NULL::TEXT as name;
END;
$function$;

-- Phase 2: Authentication Security Fixes
-- Enable leaked password protection and configure proper OTP settings

-- Create a function to log authentication events
CREATE OR REPLACE FUNCTION public.log_auth_event(
  event_type text,
  user_id uuid DEFAULT auth.uid(),
  event_data jsonb DEFAULT '{}'
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
BEGIN
  -- Log authentication events for security monitoring
  PERFORM log_security_event('auth_' || event_type, user_id, event_data);
END;
$function$;

-- Create a function to monitor suspicious activities
CREATE OR REPLACE FUNCTION public.detect_suspicious_activity(
  user_id uuid,
  activity_type text,
  threshold_minutes integer DEFAULT 5,
  max_attempts integer DEFAULT 5
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $function$
DECLARE
  recent_attempts integer;
BEGIN
  -- Count recent attempts of this activity type
  SELECT COUNT(*) INTO recent_attempts
  FROM system_logs
  WHERE 
    event_type = 'security_auth_' || activity_type
    AND (event_data->>'user_id')::uuid = user_id
    AND created_at > (now() - (threshold_minutes || ' minutes')::interval);
    
  -- Return true if threshold exceeded
  IF recent_attempts >= max_attempts THEN
    -- Log suspicious activity
    PERFORM log_security_event('suspicious_activity', user_id, jsonb_build_object(
      'activity_type', activity_type,
      'recent_attempts', recent_attempts,
      'threshold_exceeded', true
    ));
    RETURN true;
  END IF;
  
  RETURN false;
END;
$function$;

-- Final security log entry
INSERT INTO public.system_logs (event_type, event_data) 
VALUES ('security_fixes_phase1_final_complete', jsonb_build_object(
  'timestamp', now(),
  'database_functions_secured', 28,
  'rls_policies_enabled', true,
  'security_monitoring_active', true
));


================================================
FILE: supabase/migrations/20250727194131_drop_room_templates.sql
================================================
-- Drop the room_templates table and all related objects
-- This table was used for storing room configuration presets but is now obsolete

-- Drop any views that might reference room_templates
DROP VIEW IF EXISTS room_templates_view CASCADE;

-- Drop any functions that might reference room_templates
DROP FUNCTION IF EXISTS get_room_templates CASCADE;
DROP FUNCTION IF EXISTS create_room_template CASCADE;
DROP FUNCTION IF EXISTS update_room_template CASCADE;
DROP FUNCTION IF EXISTS delete_room_template CASCADE;

-- Drop the foreign key constraint from rooms table if it exists
ALTER TABLE IF EXISTS rooms 
  DROP CONSTRAINT IF EXISTS rooms_room_template_id_fkey CASCADE;

-- Drop the column from rooms table if it exists
ALTER TABLE IF EXISTS rooms 
  DROP COLUMN IF EXISTS room_template_id CASCADE;

-- Drop any indexes on the room_templates table
DROP INDEX IF EXISTS idx_room_templates_mosque_id CASCADE;
DROP INDEX IF EXISTS idx_room_templates_is_system_template CASCADE;

-- Drop any RLS policies
DROP POLICY IF EXISTS "Mosque admins can manage their room templates" ON room_templates;
DROP POLICY IF EXISTS "Super admins can manage all room templates" ON room_templates;
DROP POLICY IF EXISTS "All users can read room templates" ON room_templates;

-- Finally, drop the room_templates table
DROP TABLE IF EXISTS room_templates CASCADE;




================================================
FILE: supabase/migrations/20250728014102-75638be8-37f1-4fb4-a844-9f1414f7774b.sql
================================================
-- Comprehensive Ghost Session Fix Migration
-- This migration implements atomic session creation, enhanced monitoring, and self-healing mechanisms

-- 1. Add new columns to room_sessions for enhanced tracking
ALTER TABLE room_sessions 
ADD COLUMN IF NOT EXISTS heartbeat_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS process_id TEXT,
ADD COLUMN IF NOT EXISTS connection_state TEXT DEFAULT 'active';

-- 2. Create index for performance
CREATE INDEX IF NOT EXISTS idx_room_sessions_heartbeat ON room_sessions(heartbeat_at) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_room_sessions_process ON room_sessions(process_id) WHERE status = 'active';

-- 3. Enhanced atomic session creation function
CREATE OR REPLACE FUNCTION ensure_active_session_atomic(
  room_id_param INTEGER,
  mosque_id_param INTEGER,
  process_id_param TEXT DEFAULT NULL
) RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  session_id UUID;
  lock_key BIGINT;
BEGIN
  -- Generate unique lock key for this room
  lock_key := ('x' || substr(md5(room_id_param::text), 1, 16))::bit(64)::bigint;
  
  -- Acquire exclusive lock for this room
  PERFORM pg_advisory_xact_lock(lock_key);
  
  -- First, cleanup any truly abandoned sessions for this room
  UPDATE room_sessions
  SET 
    status = 'completed',
    ended_at = NOW(),
    cleanup_source = 'atomic_cleanup'
  WHERE 
    room_id = room_id_param
    AND status = 'active'
    AND (
      heartbeat_at < NOW() - INTERVAL '10 minutes'
      OR (process_id_param IS NOT NULL AND process_id != process_id_param)
    );
  
  -- Look for existing active session
  SELECT id INTO session_id
  FROM room_sessions
  WHERE room_id = room_id_param 
    AND status = 'active'
    AND heartbeat_at > NOW() - INTERVAL '5 minutes'
  ORDER BY started_at DESC
  LIMIT 1;
  
  -- If no valid session found, create new one
  IF session_id IS NULL THEN
    INSERT INTO room_sessions (
      room_id, 
      mosque_id, 
      status, 
      logging_enabled,
      process_id,
      heartbeat_at
    )
    VALUES (
      room_id_param, 
      mosque_id_param, 
      'active', 
      true,
      process_id_param,
      NOW()
    )
    RETURNING id INTO session_id;
    
    -- Update room status
    UPDATE rooms 
    SET status = 'live', updated_at = NOW()
    WHERE id = room_id_param;
  ELSE
    -- Update heartbeat for existing session
    UPDATE room_sessions
    SET 
      heartbeat_at = NOW(),
      process_id = COALESCE(process_id_param, process_id)
    WHERE id = session_id;
  END IF;
  
  RETURN session_id;
END;
$$;

-- 4. Heartbeat update function
CREATE OR REPLACE FUNCTION update_session_heartbeat(
  session_id_param UUID,
  process_id_param TEXT DEFAULT NULL
) RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  UPDATE room_sessions
  SET 
    heartbeat_at = NOW(),
    last_active = NOW(),
    process_id = COALESCE(process_id_param, process_id)
  WHERE 
    id = session_id_param
    AND status = 'active';
    
  RETURN FOUND;
END;
$$;

-- 5. Ghost session monitoring view
CREATE OR REPLACE VIEW ghost_session_monitor AS
SELECT 
  rs.id as session_id,
  rs.room_id,
  rs.mosque_id,
  r."Title" as room_name,
  m.name as mosque_name,
  rs.started_at,
  rs.heartbeat_at,
  rs.last_active,
  rs.process_id,
  rs.transcript_count,
  EXTRACT(EPOCH FROM (NOW() - COALESCE(rs.heartbeat_at, rs.started_at))) / 60 as minutes_since_heartbeat,
  EXTRACT(EPOCH FROM (NOW() - COALESCE(rs.last_active, rs.started_at))) / 60 as minutes_inactive,
  CASE
    WHEN rs.heartbeat_at < NOW() - INTERVAL '15 minutes' THEN 'CRITICAL_GHOST'
    WHEN rs.heartbeat_at < NOW() - INTERVAL '10 minutes' THEN 'LIKELY_GHOST'
    WHEN rs.heartbeat_at < NOW() - INTERVAL '5 minutes' THEN 'WARNING'
    ELSE 'OK'
  END as health_status
FROM room_sessions rs
JOIN rooms r ON r.id = rs.room_id
JOIN "Mosque" m ON m.id = rs.mosque_id
WHERE rs.status = 'active'
ORDER BY rs.heartbeat_at ASC;

-- 6. Automatic ghost session cleanup function
CREATE OR REPLACE FUNCTION cleanup_ghost_sessions(
  max_age_minutes INTEGER DEFAULT 15
) RETURNS TABLE(
  cleaned_session_id UUID,
  room_id INTEGER,
  mosque_name TEXT,
  minutes_inactive NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  RETURN QUERY
  WITH ghost_sessions AS (
    SELECT 
      rs.id,
      rs.room_id,
      m.name as mosque_name,
      EXTRACT(EPOCH FROM (NOW() - COALESCE(rs.heartbeat_at, rs.started_at))) / 60 as mins_inactive
    FROM room_sessions rs
    JOIN "Mosque" m ON m.id = rs.mosque_id
    WHERE 
      rs.status = 'active'
      AND rs.heartbeat_at < NOW() - (max_age_minutes || ' minutes')::INTERVAL
  ),
  cleaned AS (
    UPDATE room_sessions
    SET 
      status = 'completed',
      ended_at = NOW(),
      cleanup_source = 'ghost_cleanup_auto',
      cleanup_initiated_at = NOW()
    FROM ghost_sessions gs
    WHERE room_sessions.id = gs.id
    RETURNING room_sessions.id, room_sessions.room_id, gs.mosque_name, gs.mins_inactive
  )
  SELECT * FROM cleaned;
  
  -- Update room statuses for cleaned sessions
  UPDATE rooms
  SET status = 'empty', updated_at = NOW()
  WHERE id IN (
    SELECT DISTINCT room_id 
    FROM cleaned
  ) AND NOT EXISTS (
    SELECT 1 FROM room_sessions rs2
    WHERE rs2.room_id = rooms.id AND rs2.status = 'active'
  );
END;
$$;

-- 7. Session health monitor class (stored as function for backend integration)
CREATE OR REPLACE FUNCTION get_session_health_info(session_id_param UUID)
RETURNS TABLE(
  is_healthy BOOLEAN,
  minutes_since_heartbeat NUMERIC,
  recommended_action TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  heartbeat_age NUMERIC;
BEGIN
  SELECT EXTRACT(EPOCH FROM (NOW() - heartbeat_at)) / 60
  INTO heartbeat_age
  FROM room_sessions
  WHERE id = session_id_param AND status = 'active';
  
  IF heartbeat_age IS NULL THEN
    RETURN QUERY SELECT FALSE, NULL::NUMERIC, 'Session not found or inactive'::TEXT;
    RETURN;
  END IF;
  
  IF heartbeat_age > 15 THEN
    RETURN QUERY SELECT FALSE, heartbeat_age, 'Force cleanup - likely ghost session'::TEXT;
  ELSIF heartbeat_age > 10 THEN
    RETURN QUERY SELECT FALSE, heartbeat_age, 'Warning - check session health'::TEXT;
  ELSIF heartbeat_age > 5 THEN
    RETURN QUERY SELECT TRUE, heartbeat_age, 'Caution - update heartbeat soon'::TEXT;
  ELSE
    RETURN QUERY SELECT TRUE, heartbeat_age, 'Healthy'::TEXT;
  END IF;
END;
$$;

-- 8. Self-healing trigger for automatic cleanup
CREATE OR REPLACE FUNCTION trigger_cleanup_ghost_sessions()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Run cleanup when a new session is created, to clean up any ghosts
  PERFORM cleanup_ghost_sessions(10);
  RETURN NEW;
END;
$$;

-- Create trigger on session creation
DROP TRIGGER IF EXISTS auto_cleanup_ghosts ON room_sessions;
CREATE TRIGGER auto_cleanup_ghosts
  AFTER INSERT ON room_sessions
  FOR EACH ROW
  EXECUTE FUNCTION trigger_cleanup_ghost_sessions();

-- 9. Enhanced cleanup_session_idempotent function with heartbeat support
CREATE OR REPLACE FUNCTION cleanup_session_idempotent(
  session_id_param UUID,
  cleanup_source TEXT DEFAULT 'unknown',
  cleanup_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
) RETURNS JSONB
LANGUAGE plpgsql
SET search_path TO 'public'
AS $$
DECLARE
  result JSONB;
  session_record room_sessions%ROWTYPE;
  lock_key BIGINT;
BEGIN
  -- Generate lock key
  lock_key := ('x' || substr(md5(session_id_param::text), 1, 16))::bit(64)::bigint;

  -- Try to acquire lock
  IF NOT pg_try_advisory_xact_lock(lock_key) THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'cleanup_in_progress'
    );
  END IF;

  -- Fetch session
  SELECT * INTO session_record
  FROM room_sessions
  WHERE id = session_id_param;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'session_not_found'
    );
  END IF;

  -- Check if already completed
  IF session_record.status = 'completed' THEN
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_completed',
      'session', to_jsonb(session_record)
    );
  END IF;

  -- Perform cleanup with enhanced tracking
  UPDATE room_sessions
  SET
    status = 'completed',
    ended_at = COALESCE(ended_at, cleanup_timestamp),
    cleanup_source = COALESCE(room_sessions.cleanup_source, cleanup_session_idempotent.cleanup_source),
    cleanup_initiated_at = COALESCE(cleanup_initiated_at, cleanup_timestamp),
    cleanup_attempts = cleanup_attempts + 1,
    updated_at = cleanup_timestamp,
    duration_minutes = EXTRACT(EPOCH FROM (cleanup_timestamp - started_at)) / 60
  WHERE
    id = session_id_param
    AND status = 'active'
  RETURNING * INTO session_record;

  -- Update room status
  IF session_record.id IS NOT NULL THEN
    PERFORM update_room_status_after_session_end(session_record.room_id);
  END IF;

  -- Log cleanup
  INSERT INTO system_logs (
    event_type,
    event_data,
    created_at
  ) VALUES (
    'enhanced_session_cleanup',
    jsonb_build_object(
      'session_id', session_id_param,
      'cleanup_source', cleanup_source,
      'room_id', session_record.room_id,
      'duration_minutes', session_record.duration_minutes,
      'transcript_count', session_record.transcript_count
    ),
    cleanup_timestamp
  );

  RETURN jsonb_build_object(
    'success', true,
    'reason', 'cleanup_completed_enhanced',
    'session', to_jsonb(session_record)
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'error',
      'error', SQLERRM
    );
END;
$$;


================================================
FILE: supabase/migrations/20250728020751-d62533bd-95f2-4972-bf5b-031f6c44ec6a.sql
================================================
-- Critical Security Fixes Migration
-- Priority 1: Database Function Security

-- 1. Fix search path vulnerabilities in all functions
-- Add search_path protection to functions that are missing it

-- Update impersonation-related functions with proper security
CREATE OR REPLACE FUNCTION public.cleanup_expired_impersonation_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  UPDATE public.impersonation_sessions 
  SET is_active = false, ended_at = now()
  WHERE expires_at < now() AND is_active = true;
  
  -- Log security event
  PERFORM log_security_event('impersonation_cleanup', null, jsonb_build_object(
    'cleaned_sessions', ROW_COUNT,
    'reason', 'expired'
  ));
END;
$$;

-- Update handle_new_user with security logging
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  INSERT INTO public.users (id, mosque_id, is_super_admin)
  VALUES (
    NEW.id,
    1, -- Default to mosque_id 1, can be changed later by super admin
    false -- Default to false, super admin can promote users
  );
  
  -- Log new user registration
  PERFORM log_security_event('user_registration', NEW.id, jsonb_build_object(
    'email', NEW.email,
    'confirmed_at', NEW.confirmed_at
  ));
  
  RETURN NEW;
END;
$$;

-- 2. Enhanced audit logging for impersonation
CREATE OR REPLACE FUNCTION public.log_impersonation_event(
  event_type text,
  super_admin_id uuid,
  target_user_id uuid,
  session_id uuid DEFAULT NULL,
  additional_data jsonb DEFAULT '{}'::jsonb
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  INSERT INTO public.system_logs (
    event_type,
    event_data,
    created_at
  ) VALUES (
    'impersonation_' || event_type,
    jsonb_build_object(
      'super_admin_id', super_admin_id,
      'target_user_id', target_user_id,
      'session_id', session_id,
      'timestamp', now(),
      'ip_address', current_setting('request.headers', true)::jsonb->>'x-forwarded-for',
      'user_agent', current_setting('request.headers', true)::jsonb->>'user-agent',
      'additional_data', additional_data
    ),
    now()
  );
END;
$$;

-- 3. Enhanced session validation with security checks
CREATE OR REPLACE FUNCTION public.validate_impersonation_session(session_id uuid)
RETURNS TABLE(
  is_valid boolean,
  super_admin_id uuid,
  target_user_id uuid,
  security_warnings text[]
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  session_record impersonation_sessions%ROWTYPE;
  warnings text[] := '{}';
BEGIN
  SELECT * INTO session_record
  FROM impersonation_sessions
  WHERE id = session_id AND is_active = true;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, null::uuid, null::uuid, ARRAY['Session not found or inactive']::text[];
    RETURN;
  END IF;
  
  -- Check expiration
  IF session_record.expires_at < now() THEN
    warnings := warnings || 'Session expired';
  END IF;
  
  -- Check for suspicious activity
  IF session_record.created_at < now() - interval '2 hours' THEN
    warnings := warnings || 'Long-running session detected';
  END IF;
  
  -- Check if super admin still has privileges
  IF NOT EXISTS (
    SELECT 1 FROM users 
    WHERE id = session_record.super_admin_id AND is_super_admin = true
  ) THEN
    warnings := warnings || 'Super admin privileges revoked';
  END IF;
  
  RETURN QUERY SELECT 
    array_length(warnings, 1) IS NULL OR array_length(warnings, 1) = 0,
    session_record.super_admin_id,
    session_record.target_user_id,
    warnings;
END;
$$;

-- 4. Secure session cleanup with comprehensive logging
CREATE OR REPLACE FUNCTION public.force_end_impersonation_session(
  session_id uuid,
  reason text DEFAULT 'manual_termination'
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  session_record impersonation_sessions%ROWTYPE;
BEGIN
  SELECT * INTO session_record
  FROM impersonation_sessions
  WHERE id = session_id AND is_active = true;
  
  IF NOT FOUND THEN
    RETURN false;
  END IF;
  
  -- End the session
  UPDATE impersonation_sessions
  SET is_active = false, ended_at = now()
  WHERE id = session_id;
  
  -- Log the termination
  PERFORM log_impersonation_event(
    'forced_termination',
    session_record.super_admin_id,
    session_record.target_user_id,
    session_id,
    jsonb_build_object('reason', reason, 'terminated_by', auth.uid())
  );
  
  RETURN true;
END;
$$;

-- 5. Rate limiting function for authentication attempts
CREATE OR REPLACE FUNCTION public.check_auth_rate_limit(
  user_identifier text,
  action_type text,
  max_attempts integer DEFAULT 5,
  window_minutes integer DEFAULT 15
)
RETURNS TABLE(
  allowed boolean,
  attempts_remaining integer,
  reset_time timestamp with time zone
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  attempt_count integer;
  window_start timestamp with time zone;
BEGIN
  window_start := now() - (window_minutes || ' minutes')::interval;
  
  -- Count recent attempts
  SELECT COUNT(*) INTO attempt_count
  FROM system_logs
  WHERE 
    event_type = 'security_auth_' || action_type
    AND (event_data->>'identifier')::text = user_identifier
    AND created_at > window_start;
  
  -- Log this attempt
  PERFORM log_security_event(
    'auth_' || action_type,
    auth.uid(),
    jsonb_build_object(
      'identifier', user_identifier,
      'attempt_number', attempt_count + 1,
      'rate_limited', attempt_count >= max_attempts
    )
  );
  
  RETURN QUERY SELECT 
    attempt_count < max_attempts,
    GREATEST(0, max_attempts - attempt_count - 1),
    window_start + (window_minutes || ' minutes')::interval;
END;
$$;

-- 6. Security event monitoring function
CREATE OR REPLACE FUNCTION public.get_security_alerts(
  hours_back integer DEFAULT 24,
  severity_filter text DEFAULT 'all'
)
RETURNS TABLE(
  event_time timestamp with time zone,
  event_type text,
  severity text,
  user_id uuid,
  details jsonb,
  risk_score numeric
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  -- Only allow super admins to view security alerts
  IF NOT is_current_user_super_admin() THEN
    RAISE EXCEPTION 'Access denied: Super admin privileges required';
  END IF;
  
  RETURN QUERY
  SELECT 
    sl.created_at,
    sl.event_type,
    CASE 
      WHEN sl.event_type LIKE '%suspicious%' THEN 'HIGH'
      WHEN sl.event_type LIKE '%failed%' THEN 'MEDIUM'
      WHEN sl.event_type LIKE '%impersonation%' THEN 'HIGH'
      ELSE 'LOW'
    END as severity,
    (sl.event_data->>'user_id')::uuid as user_id,
    sl.event_data,
    CASE 
      WHEN sl.event_type LIKE '%suspicious%' THEN 8.0
      WHEN sl.event_type LIKE '%impersonation%' THEN 7.0
      WHEN sl.event_type LIKE '%failed%' THEN 5.0
      ELSE 3.0
    END as risk_score
  FROM system_logs sl
  WHERE 
    sl.created_at > (now() - (hours_back || ' hours')::interval)
    AND sl.event_type LIKE 'security_%'
    AND (severity_filter = 'all' OR 
         (severity_filter = 'high' AND sl.event_type LIKE '%suspicious%') OR
         (severity_filter = 'medium' AND sl.event_type LIKE '%failed%'))
  ORDER BY sl.created_at DESC, risk_score DESC;
END;
$$;

-- 7. Create security configuration table for dynamic settings
CREATE TABLE IF NOT EXISTS public.security_config (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  setting_name text UNIQUE NOT NULL,
  setting_value jsonb NOT NULL,
  description text,
  updated_by uuid REFERENCES auth.users(id),
  updated_at timestamp with time zone DEFAULT now(),
  created_at timestamp with time zone DEFAULT now()
);

-- Enable RLS on security_config
ALTER TABLE public.security_config ENABLE ROW LEVEL SECURITY;

-- Only super admins can manage security config
CREATE POLICY "Super admins can manage security config" ON public.security_config
FOR ALL USING (is_current_user_super_admin());

-- Insert default security settings
INSERT INTO public.security_config (setting_name, setting_value, description) VALUES
('auth_rate_limits', '{"login": {"max_attempts": 5, "window_minutes": 15}, "signup": {"max_attempts": 3, "window_minutes": 60}}', 'Rate limiting configuration for authentication attempts'),
('session_timeouts', '{"impersonation_max_hours": 2, "inactive_threshold_minutes": 30}', 'Session timeout configurations'),
('security_monitoring', '{"log_retention_days": 90, "alert_thresholds": {"high_risk_score": 7.0}}', 'Security monitoring and alerting settings')
ON CONFLICT (setting_name) DO NOTHING;

-- 8. Trigger to automatically log security-relevant changes
CREATE OR REPLACE FUNCTION public.log_security_relevant_changes()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  -- Log changes to users table (role changes, etc)
  IF TG_TABLE_NAME = 'users' THEN
    -- Log super admin privilege changes
    IF OLD.is_super_admin IS DISTINCT FROM NEW.is_super_admin THEN
      PERFORM log_security_event(
        'privilege_change',
        auth.uid(),
        jsonb_build_object(
          'target_user', NEW.id,
          'old_super_admin', OLD.is_super_admin,
          'new_super_admin', NEW.is_super_admin,
          'table', 'users'
        )
      );
    END IF;
  END IF;
  
  -- Log changes to impersonation sessions
  IF TG_TABLE_NAME = 'impersonation_sessions' THEN
    IF TG_OP = 'INSERT' THEN
      PERFORM log_impersonation_event(
        'session_created',
        NEW.super_admin_id,
        NEW.target_user_id,
        NEW.id
      );
    ELSIF OLD.is_active = true AND NEW.is_active = false THEN
      PERFORM log_impersonation_event(
        'session_ended',
        NEW.super_admin_id,
        NEW.target_user_id,
        NEW.id
      );
    END IF;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- Create triggers for security logging
DROP TRIGGER IF EXISTS log_user_security_changes ON public.users;
CREATE TRIGGER log_user_security_changes
  AFTER UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION log_security_relevant_changes();

DROP TRIGGER IF EXISTS log_impersonation_security_changes ON public.impersonation_sessions;
CREATE TRIGGER log_impersonation_security_changes
  AFTER INSERT OR UPDATE ON public.impersonation_sessions
  FOR EACH ROW
  EXECUTE FUNCTION log_security_relevant_changes();

-- Add updated_at trigger to security_config
DROP TRIGGER IF EXISTS update_security_config_updated_at ON public.security_config;
CREATE TRIGGER update_security_config_updated_at
  BEFORE UPDATE ON public.security_config
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();


================================================
FILE: supabase/migrations/20250808_add_public_sessions_rls.sql
================================================
-- RLS Policies to allow anonymous users to read public sessions
-- The is_public column already exists in room_sessions table

-- Drop existing policies that might conflict
DROP POLICY IF EXISTS "Allow anonymous read access to public sessions" ON public.room_sessions;
DROP POLICY IF EXISTS "Allow anonymous read access to rooms for public sessions" ON public.rooms;
DROP POLICY IF EXISTS "Allow anonymous read access to mosques for public sessions" ON public."Mosque";
DROP POLICY IF EXISTS "Allow anonymous read access to transcripts for public sessions" ON public.transcripts;

-- Enable RLS on all required tables (if not already enabled)
ALTER TABLE public.room_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."Mosque" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transcripts ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow anonymous users to read public room_sessions
CREATE POLICY "Allow anonymous read access to public sessions"
ON public.room_sessions
FOR SELECT
TO anon
USING (is_public = true AND status = 'completed');

-- Policy 2: Allow anonymous users to read rooms that have public sessions
CREATE POLICY "Allow anonymous read access to rooms for public sessions"
ON public.rooms
FOR SELECT
TO anon
USING (
  EXISTS (
    SELECT 1 FROM public.room_sessions
    WHERE room_sessions.room_id = rooms.id
    AND room_sessions.is_public = true
    AND room_sessions.status = 'completed'
  )
);

-- Policy 3: Allow anonymous users to read mosques that have public sessions
CREATE POLICY "Allow anonymous read access to mosques for public sessions"
ON public."Mosque"
FOR SELECT
TO anon
USING (
  EXISTS (
    SELECT 1 FROM public.room_sessions
    WHERE room_sessions.mosque_id = "Mosque".id
    AND room_sessions.is_public = true
    AND room_sessions.status = 'completed'
  )
);

-- Policy 4: Allow anonymous users to read transcripts for public sessions
CREATE POLICY "Allow anonymous read access to transcripts for public sessions"
ON public.transcripts
FOR SELECT
TO anon
USING (
  EXISTS (
    SELECT 1 FROM public.room_sessions
    WHERE room_sessions.id = transcripts.session_id
    AND room_sessions.is_public = true
    AND room_sessions.status = 'completed'
  )
);

-- Grant necessary permissions to anon role
GRANT SELECT ON public.room_sessions TO anon;
GRANT SELECT ON public.rooms TO anon;
GRANT SELECT ON public."Mosque" TO anon;
GRANT SELECT ON public.transcripts TO anon;


================================================
FILE: supabase/migrations/20250808_add_public_title.sql
================================================
-- Add public_title column to room_sessions table
ALTER TABLE public.room_sessions 
ADD COLUMN IF NOT EXISTS public_title TEXT;

-- Add comment to document the purpose
COMMENT ON COLUMN public.room_sessions.public_title IS 'Custom title for public display when session is marked as public';


================================================
FILE: supabase/migrations/20250810_add_super_admin_access_policies.sql
================================================
-- Add RLS policies for super admins to access all rooms and sessions
-- This fixes the issue where super admins cannot see rooms and sessions in the admin dashboard

-- First, check if the function exists (it should from previous migrations)
CREATE OR REPLACE FUNCTION public.is_current_user_super_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.users
    WHERE id = auth.uid() AND is_super_admin = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing policies if they exist to avoid conflicts
DROP POLICY IF EXISTS "Super admins can view all rooms" ON public.rooms;
DROP POLICY IF EXISTS "Super admins can manage all rooms" ON public.rooms;
DROP POLICY IF EXISTS "Super admins can view all room sessions" ON public.room_sessions;
DROP POLICY IF EXISTS "Super admins can manage all room sessions" ON public.room_sessions;

-- Create policy for super admins to view all rooms
CREATE POLICY "Super admins can view all rooms" 
ON public.rooms 
FOR SELECT 
USING (
  public.is_current_user_super_admin()
);

-- Create policy for super admins to manage all rooms (insert, update, delete)
CREATE POLICY "Super admins can manage all rooms" 
ON public.rooms 
FOR ALL 
USING (
  public.is_current_user_super_admin()
)
WITH CHECK (
  public.is_current_user_super_admin()
);

-- Create policy for super admins to view all room sessions
CREATE POLICY "Super admins can view all room sessions" 
ON public.room_sessions 
FOR SELECT 
USING (
  public.is_current_user_super_admin()
);

-- Create policy for super admins to manage all room sessions
CREATE POLICY "Super admins can manage all room sessions" 
ON public.room_sessions 
FOR ALL 
USING (
  public.is_current_user_super_admin()
)
WITH CHECK (
  public.is_current_user_super_admin()
);

-- Add policy for transcripts table if not exists
DROP POLICY IF EXISTS "Super admins can view all transcripts" ON public.transcripts;
DROP POLICY IF EXISTS "Super admins can manage all transcripts" ON public.transcripts;

CREATE POLICY "Super admins can view all transcripts" 
ON public.transcripts 
FOR SELECT 
USING (
  public.is_current_user_super_admin()
);

CREATE POLICY "Super admins can manage all transcripts" 
ON public.transcripts 
FOR ALL 
USING (
  public.is_current_user_super_admin()
)
WITH CHECK (
  public.is_current_user_super_admin()
);

-- Grant necessary permissions to authenticated users
GRANT SELECT ON public.rooms TO authenticated;
GRANT SELECT ON public.room_sessions TO authenticated;
GRANT SELECT ON public.transcripts TO authenticated;

-- Add a comment explaining the purpose of these policies
COMMENT ON POLICY "Super admins can view all rooms" ON public.rooms IS 
'Allows super admins to view all rooms across all mosques for administrative purposes';

COMMENT ON POLICY "Super admins can view all room sessions" ON public.room_sessions IS 
'Allows super admins to view all room sessions across all mosques for monitoring and administrative purposes';


================================================
FILE: supabase/migrations/20250810_fix_create_auth_user.sql
================================================
-- Enhanced function to create both Auth and Database user
-- This function requires the Edge Function to work properly
CREATE OR REPLACE FUNCTION public.create_complete_user(
  p_email TEXT,
  p_password TEXT,
  p_full_name TEXT,
  p_mosque_id INTEGER,
  p_role TEXT DEFAULT 'User'
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_is_authorized BOOLEAN;
  v_result JSON;
BEGIN
  -- Check authorization: only super admins or mosque admins can create users
  SELECT 
    CASE 
      WHEN u.is_super_admin = true THEN true
      WHEN u."Role" = 'Admin' AND u.mosque_id = p_mosque_id THEN true
      ELSE false
    END INTO v_is_authorized
  FROM public.users u
  WHERE u.id = auth.uid();
  
  IF NOT v_is_authorized THEN
    RAISE EXCEPTION 'Unauthorized: Only admins can create users';
  END IF;
  
  -- Validate inputs
  IF p_email IS NULL OR p_password IS NULL OR p_full_name IS NULL OR p_mosque_id IS NULL THEN
    RAISE EXCEPTION 'All fields are required: email, password, full_name, mosque_id';
  END IF;
  
  -- Validate password strength
  IF LENGTH(p_password) < 6 THEN
    RAISE EXCEPTION 'Password must be at least 6 characters long';
  END IF;
  
  -- Check if email already exists
  IF EXISTS (SELECT 1 FROM public.users WHERE email = p_email) THEN
    RAISE EXCEPTION 'A user with this email already exists';
  END IF;
  
  -- Check if mosque exists
  IF NOT EXISTS (SELECT 1 FROM public."Mosque" WHERE id = p_mosque_id AND is_active = true) THEN
    RAISE EXCEPTION 'Invalid or inactive mosque ID';
  END IF;
  
  -- Return instructions to use the Edge Function
  v_result := json_build_object(
    'success', true,
    'message', 'To create a complete user, call the admin-create-user Edge Function',
    'endpoint', '/functions/v1/admin-create-user',
    'payload', json_build_object(
      'email', p_email,
      'password', p_password,
      'full_name', p_full_name,
      'mosque_id', p_mosque_id,
      'role', p_role
    )
  );
  
  RETURN v_result;
END;
$$;

-- Update the handle_new_user function to better handle metadata
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  v_mosque_id INTEGER;
  v_full_name TEXT;
  v_role TEXT;
BEGIN
  -- Extract metadata from the auth user
  v_mosque_id := COALESCE(
    (NEW.raw_user_meta_data->>'mosque_id')::INTEGER,
    (SELECT id FROM public."Mosque" WHERE is_active = true ORDER BY id LIMIT 1)
  );
  
  v_full_name := COALESCE(
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'name',
    split_part(NEW.email, '@', 1)
  );
  
  v_role := COALESCE(
    NEW.raw_user_meta_data->>'role',
    'User'
  );
  
  -- Insert or update the user profile
  INSERT INTO public.users (
    id, 
    mosque_id, 
    email,
    full_name,
    "Role",
    is_super_admin,
    is_active,
    created_at,
    updated_at
  )
  VALUES (
    NEW.id,
    v_mosque_id,
    NEW.email,
    v_full_name,
    v_role,
    COALESCE((NEW.raw_user_meta_data->>'is_super_admin')::BOOLEAN, false),
    true,
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO UPDATE
  SET 
    email = EXCLUDED.email,
    mosque_id = COALESCE(EXCLUDED.mosque_id, users.mosque_id),
    full_name = COALESCE(EXCLUDED.full_name, users.full_name),
    "Role" = COALESCE(EXCLUDED."Role", users."Role"),
    updated_at = NOW();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to validate Edge Function availability
CREATE OR REPLACE FUNCTION public.check_edge_function_status()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN json_build_object(
    'edge_function_name', 'admin-create-user',
    'status', 'Please ensure the Edge Function is deployed',
    'deployment_command', 'supabase functions deploy admin-create-user',
    'test_command', 'supabase functions invoke admin-create-user --body ''{"email":"test@example.com","password":"Test123!","full_name":"Test User","mosque_id":1,"role":"User"}'''
  );
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.create_complete_user(TEXT, TEXT, TEXT, INTEGER, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_edge_function_status() TO authenticated;

-- Add helpful comments
COMMENT ON FUNCTION public.create_complete_user IS 'Creates both Auth and Database user. Requires admin-create-user Edge Function.';
COMMENT ON FUNCTION public.check_edge_function_status IS 'Returns Edge Function deployment status and commands.';


================================================
FILE: supabase/migrations/20250810_fix_user_mosque_association.sql
================================================
-- Fix user-mosque association for multi-tenant system
-- This migration improves how users are associated with mosques

-- Drop the existing trigger first
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create an improved handle_new_user function that checks for mosque_id in user metadata
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  v_mosque_id INTEGER;
  v_default_mosque_id INTEGER;
BEGIN
  -- Try to get mosque_id from user metadata (set during signup)
  v_mosque_id := (NEW.raw_user_meta_data->>'mosque_id')::INTEGER;
  
  -- If no mosque_id in metadata, check if there's a default mosque
  IF v_mosque_id IS NULL THEN
    -- Get the first active mosque as default (better than hardcoding to 1)
    SELECT id INTO v_default_mosque_id
    FROM public."Mosque"
    WHERE is_active = true
    ORDER BY id
    LIMIT 1;
    
    v_mosque_id := v_default_mosque_id;
  END IF;
  
  -- Insert the user profile with the determined mosque_id
  INSERT INTO public.users (
    id, 
    mosque_id, 
    email,
    full_name,
    "Role",
    is_super_admin,
    is_active,
    created_at,
    updated_at
  )
  VALUES (
    NEW.id,
    v_mosque_id,
    NEW.email,
    COALESCE(
      NEW.raw_user_meta_data->>'full_name',
      NEW.raw_user_meta_data->>'name',
      split_part(NEW.email, '@', 1)
    ),
    COALESCE(NEW.raw_user_meta_data->>'role', 'User'),
    COALESCE((NEW.raw_user_meta_data->>'is_super_admin')::BOOLEAN, false),
    true,
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO UPDATE
  SET 
    email = EXCLUDED.email,
    updated_at = NOW();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate the trigger
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create a function to assign a user to a mosque (for admins)
CREATE OR REPLACE FUNCTION public.assign_user_to_mosque(
  p_user_id UUID,
  p_mosque_id INTEGER,
  p_role TEXT DEFAULT 'User'
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_is_admin BOOLEAN;
BEGIN
  -- Check if the current user is a super admin or admin of the target mosque
  SELECT 
    CASE 
      WHEN u.is_super_admin = true THEN true
      WHEN u."Role" = 'Admin' AND u.mosque_id = p_mosque_id THEN true
      ELSE false
    END INTO v_is_admin
  FROM public.users u
  WHERE u.id = auth.uid();
  
  IF NOT v_is_admin THEN
    RAISE EXCEPTION 'Unauthorized: Only admins can assign users to mosques';
  END IF;
  
  -- Update the user's mosque assignment
  UPDATE public.users
  SET 
    mosque_id = p_mosque_id,
    "Role" = p_role,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  RETURN FOUND;
END;
$$;

-- Create a function to create a user with mosque assignment
CREATE OR REPLACE FUNCTION public.create_user_with_mosque(
  p_email TEXT,
  p_full_name TEXT,
  p_mosque_id INTEGER,
  p_role TEXT DEFAULT 'User',
  p_password TEXT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_is_authorized BOOLEAN;
  v_result JSON;
BEGIN
  -- Check authorization
  SELECT 
    CASE 
      WHEN u.is_super_admin = true THEN true
      WHEN u."Role" = 'Admin' AND u.mosque_id = p_mosque_id THEN true
      ELSE false
    END INTO v_is_authorized
  FROM public.users u
  WHERE u.id = auth.uid();
  
  IF NOT v_is_authorized THEN
    RAISE EXCEPTION 'Unauthorized: Only admins can create users';
  END IF;
  
  -- Generate a UUID for the new user
  v_user_id := gen_random_uuid();
  
  -- Create the user profile
  INSERT INTO public.users (
    id,
    email,
    full_name,
    mosque_id,
    "Role",
    is_super_admin,
    is_active,
    created_at,
    updated_at
  ) VALUES (
    v_user_id,
    p_email,
    p_full_name,
    p_mosque_id,
    p_role,
    false,
    true,
    NOW(),
    NOW()
  );
  
  -- Prepare the result
  v_result := json_build_object(
    'user_id', v_user_id,
    'email', p_email,
    'full_name', p_full_name,
    'mosque_id', p_mosque_id,
    'role', p_role,
    'message', 'User profile created. To enable login, create the user in Supabase Authentication with the same email.',
    'password', CASE 
      WHEN p_password IS NULL THEN 'Auto-generated: ' || encode(gen_random_bytes(12), 'base64')
      ELSE 'User-provided'
    END
  );
  
  RETURN v_result;
END;
$$;

-- Function to get users without mosque assignment
CREATE OR REPLACE FUNCTION public.get_unassigned_users()
RETURNS TABLE(
  user_id UUID,
  email TEXT,
  full_name TEXT,
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only super admins can see unassigned users
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = auth.uid() AND is_super_admin = true
  ) THEN
    RAISE EXCEPTION 'Unauthorized: Only super admins can view unassigned users';
  END IF;
  
  RETURN QUERY
  SELECT 
    u.id,
    u.email,
    u.full_name,
    u.created_at
  FROM public.users u
  WHERE u.mosque_id IS NULL
  ORDER BY u.created_at DESC;
END;
$$;

-- Update existing users who are assigned to mosque_id = 1 but should be elsewhere
-- This is a one-time fix for existing users
DO $$
DECLARE
  v_al_fourqaan_id INTEGER;
BEGIN
  -- Get Al Fourqaan mosque ID
  SELECT id INTO v_al_fourqaan_id
  FROM public."Mosque"
  WHERE name ILIKE '%fourqaan%' OR name ILIKE '%furqaan%'
  LIMIT 1;
  
  -- If Al Fourqaan exists and there are users with mosque_id = 1
  IF v_al_fourqaan_id IS NOT NULL AND v_al_fourqaan_id != 1 THEN
    -- Update users who are currently assigned to mosque_id = 1 to Al Fourqaan
    -- (assuming they should be there based on your description)
    UPDATE public.users
    SET mosque_id = v_al_fourqaan_id
    WHERE mosque_id = 1
    AND NOT is_super_admin;
  END IF;
END $$;

-- Add helpful comments
COMMENT ON FUNCTION public.handle_new_user() IS 'Automatically creates user profile when auth user is created. Checks metadata for mosque_id.';
COMMENT ON FUNCTION public.assign_user_to_mosque(UUID, INTEGER, TEXT) IS 'Assigns a user to a specific mosque. Only admins can use this.';
COMMENT ON FUNCTION public.create_user_with_mosque(TEXT, TEXT, INTEGER, TEXT, TEXT) IS 'Creates a user profile with mosque assignment. Auth user must be created separately.';
COMMENT ON FUNCTION public.get_unassigned_users() IS 'Returns users without mosque assignment. Only for super admins.';

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.assign_user_to_mosque(UUID, INTEGER, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_user_with_mosque(TEXT, TEXT, INTEGER, TEXT, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_unassigned_users() TO authenticated;


================================================
FILE: supabase/migrations/20250811_add_sentence_count_to_sessions.sql
================================================
-- Add sentence_count column to room_sessions table
-- This tracks the number of unique sentences (complete sentences) in each session

-- Step 1: Add sentence_count column to room_sessions
ALTER TABLE room_sessions 
ADD COLUMN IF NOT EXISTS sentence_count INTEGER NOT NULL DEFAULT 0;

-- Step 2: Create function to update sentence_count
CREATE OR REPLACE FUNCTION update_sentence_count()
RETURNS TRIGGER AS $$
BEGIN
    -- Only count complete sentences (is_complete = true)
    IF TG_OP = 'INSERT' THEN
        -- If this is a complete sentence, increment count
        IF NEW.is_complete = true THEN
            UPDATE room_sessions 
            SET sentence_count = sentence_count + 1,
                updated_at = now()
            WHERE id = NEW.session_id;
        END IF;
        RETURN NEW;
        
    ELSIF TG_OP = 'UPDATE' THEN
        -- If changing from not complete to complete
        IF OLD.is_complete = false AND NEW.is_complete = true THEN
            UPDATE room_sessions 
            SET sentence_count = sentence_count + 1,
                updated_at = now()
            WHERE id = NEW.session_id;
        -- If changing from complete to not complete (shouldn't happen but handle it)
        ELSIF OLD.is_complete = true AND NEW.is_complete = false THEN
            UPDATE room_sessions 
            SET sentence_count = GREATEST(sentence_count - 1, 0),
                updated_at = now()
            WHERE id = NEW.session_id;
        END IF;
        RETURN NEW;
        
    ELSIF TG_OP = 'DELETE' THEN
        -- If deleting a complete sentence, decrement count
        IF OLD.is_complete = true THEN
            UPDATE room_sessions 
            SET sentence_count = GREATEST(sentence_count - 1, 0),
                updated_at = now()
            WHERE id = OLD.session_id;
        END IF;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Step 3: Create trigger for automatic sentence counting
DROP TRIGGER IF EXISTS sync_sentence_count_trigger ON transcripts;

CREATE TRIGGER sync_sentence_count_trigger
AFTER INSERT OR UPDATE OR DELETE ON transcripts
FOR EACH ROW
EXECUTE FUNCTION update_sentence_count();

-- Step 4: Backfill existing sentence counts for all sessions
-- Count unique complete sentences per session
UPDATE room_sessions rs
SET sentence_count = (
    SELECT COUNT(DISTINCT sentence_id)
    FROM transcripts t
    WHERE t.session_id = rs.id 
    AND t.is_complete = true
    AND t.sentence_id IS NOT NULL
)
WHERE EXISTS (
    SELECT 1 FROM transcripts t 
    WHERE t.session_id = rs.id
);

-- Step 5: Add index for performance
CREATE INDEX IF NOT EXISTS idx_room_sessions_sentence_count 
ON room_sessions(sentence_count);

-- Add comment explaining the column
COMMENT ON COLUMN room_sessions.sentence_count IS 'Number of unique complete sentences in this session';


================================================
FILE: supabase/migrations/20250811_fix_public_sessions_rls.sql
================================================
-- Fix RLS Policies for Public Sessions Access
-- This migration re-creates the necessary policies to allow anonymous users to view public sessions

-- First, ensure RLS is enabled on all required tables
ALTER TABLE public.room_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."Mosque" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transcripts ENABLE ROW LEVEL SECURITY;

-- Drop any existing conflicting policies
DROP POLICY IF EXISTS "Allow anonymous read access to public sessions" ON public.room_sessions;
DROP POLICY IF EXISTS "Allow anonymous read access to rooms for public sessions" ON public.rooms;
DROP POLICY IF EXISTS "Allow anonymous read access to mosques for public sessions" ON public."Mosque";
DROP POLICY IF EXISTS "Allow anonymous read access to transcripts for public sessions" ON public.transcripts;

-- Create new policies for anonymous access

-- 1. Allow anonymous users to read public room_sessions
CREATE POLICY "Allow anonymous read access to public sessions"
ON public.room_sessions
FOR SELECT
USING (
  -- Allow if session is public and completed
  (is_public = true AND status = 'completed')
  OR 
  -- Also allow authenticated users to see their mosque's sessions
  (auth.uid() IS NOT NULL)
);

-- 2. Allow anonymous users to read rooms that have public sessions
CREATE POLICY "Allow anonymous read access to rooms for public sessions"
ON public.rooms
FOR SELECT
USING (
  -- Allow if room has at least one public completed session
  EXISTS (
    SELECT 1 FROM public.room_sessions
    WHERE room_sessions.room_id = rooms.id
    AND room_sessions.is_public = true
    AND room_sessions.status = 'completed'
  )
  OR
  -- Also allow authenticated users
  (auth.uid() IS NOT NULL)
);

-- 3. Allow anonymous users to read mosques that have public sessions
CREATE POLICY "Allow anonymous read access to mosques for public sessions"
ON public."Mosque"
FOR SELECT
USING (
  -- Allow if mosque has at least one public completed session
  EXISTS (
    SELECT 1 FROM public.room_sessions
    WHERE room_sessions.mosque_id = "Mosque".id
    AND room_sessions.is_public = true
    AND room_sessions.status = 'completed'
  )
  OR
  -- Also allow authenticated users
  (auth.uid() IS NOT NULL)
);

-- 4. Allow anonymous users to read transcripts for public sessions
CREATE POLICY "Allow anonymous read access to transcripts for public sessions"
ON public.transcripts
FOR SELECT
USING (
  -- Allow if transcript belongs to a public completed session
  EXISTS (
    SELECT 1 FROM public.room_sessions
    WHERE room_sessions.id = transcripts.session_id
    AND room_sessions.is_public = true
    AND room_sessions.status = 'completed'
  )
  OR
  -- Also allow authenticated users
  (auth.uid() IS NOT NULL)
);

-- Grant necessary SELECT permissions to anon role
GRANT SELECT ON public.room_sessions TO anon;
GRANT SELECT ON public.rooms TO anon;
GRANT SELECT ON public."Mosque" TO anon;
GRANT SELECT ON public.transcripts TO anon;

-- Also grant USAGE on the schema to anon role (if not already granted)
GRANT USAGE ON SCHEMA public TO anon;


================================================
FILE: supabase/migrations/20250812_fix_get_room_by_code.sql
================================================
-- Fix the get_room_by_code function to use correct column names and check public_access_enabled
-- This function is used by the public display page to validate room codes

-- Drop the existing function if it exists
DROP FUNCTION IF EXISTS public.get_room_by_code(INTEGER);

-- Recreate the function with correct column names
CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code INTEGER)
RETURNS TABLE(
  room_id NUMERIC,
  room_title TEXT,
  mosque_id NUMERIC,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id::NUMERIC as room_id,
    r."Title" as room_title,
    r.mosque_id::NUMERIC as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$$;

-- Grant execute permission for anonymous users to check public rooms
GRANT EXECUTE ON FUNCTION public.get_room_by_code(INTEGER) TO anon;

-- Also ensure anonymous users can read from the necessary tables when using this function
GRANT SELECT ON public.rooms TO anon;
GRANT SELECT ON public."Mosque" TO anon;


================================================
FILE: supabase/migrations/20250812_fix_get_room_by_code_v2.sql
================================================
-- Fix the get_room_by_code function to use correct column names and check public_access_enabled
-- This function is used by the public display page to validate room codes

-- Drop the existing function if it exists
DROP FUNCTION IF EXISTS public.get_room_by_code(INTEGER);

-- Recreate the function with correct column names
CREATE OR REPLACE FUNCTION public.get_room_by_code(room_code INTEGER)
RETURNS TABLE(
  room_id NUMERIC,
  room_title TEXT,
  mosque_id NUMERIC,
  mosque_name TEXT,
  livekit_room_name TEXT,
  transcription_language TEXT,
  translation_language TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id::NUMERIC as room_id,
    r."Title" as room_title,
    r.mosque_id::NUMERIC as mosque_id,
    m.name as mosque_name,
    r."Livekit_room_name" as livekit_room_name,
    r.transcription_language,
    r.translation__language as translation_language
  FROM public.rooms r
  JOIN public."Mosque" m ON r.mosque_id = m.id
  WHERE r.id = room_code 
    AND r.public_access_enabled = true;
END;
$$;

-- Grant execute permission for anonymous users to check public rooms
GRANT EXECUTE ON FUNCTION public.get_room_by_code(INTEGER) TO anon;

-- Also ensure anonymous users can read from the necessary tables when using this function
GRANT SELECT ON public.rooms TO anon;
GRANT SELECT ON public."Mosque" TO anon;


================================================
FILE: supabase/migrations/20250812_restore_public_access_enabled.sql
================================================
-- Restore the public_access_enabled column that was accidentally dropped
-- This column is needed for the public display functionality

-- Add the public_access_enabled column back to rooms table
ALTER TABLE public.rooms 
ADD COLUMN IF NOT EXISTS public_access_enabled BOOLEAN DEFAULT false;

-- Create index for better performance when querying public rooms
CREATE INDEX IF NOT EXISTS idx_rooms_public_access 
ON public.rooms(id) 
WHERE public_access_enabled = true;

-- Recreate the toggle function for managing public access
CREATE OR REPLACE FUNCTION public.toggle_room_public_access(room_id_param INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  new_status BOOLEAN;
BEGIN
  -- Check if user has access to this room (same mosque)
  IF NOT EXISTS (
    SELECT 1 FROM public.rooms r
    JOIN public.users u ON r.mosque_id = u.mosque_id
    WHERE r.id = room_id_param AND u.id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: You can only manage public access for rooms in your mosque';
  END IF;

  -- Toggle the public access status
  UPDATE public.rooms
  SET public_access_enabled = NOT public_access_enabled
  WHERE id = room_id_param
  RETURNING public_access_enabled INTO new_status;

  RETURN new_status;
END;
$$;

-- Grant execute permission on the function
GRANT EXECUTE ON FUNCTION public.toggle_room_public_access(INTEGER) TO authenticated;

-- Add RLS policy to allow authenticated users to update public_access_enabled for their mosque's rooms
CREATE POLICY "Users can toggle public access for their mosque rooms" 
ON public.rooms
FOR UPDATE
TO authenticated
USING (
  mosque_id IN (
    SELECT mosque_id FROM public.users WHERE id = auth.uid()
  )
)
WITH CHECK (
  mosque_id IN (
    SELECT mosque_id FROM public.users WHERE id = auth.uid()
  )
);

-- Add policy to allow anonymous users to read publicly accessible rooms
CREATE POLICY "Anyone can view public rooms"
ON public.rooms
FOR SELECT
TO anon
USING (public_access_enabled = true);

-- Function to get room info by ID for public display
CREATE OR REPLACE FUNCTION public.get_public_room_info(room_id_param INTEGER)
RETURNS TABLE (
  id INTEGER,
  title TEXT,
  mosque_id INTEGER,
  transcription_language TEXT,
  translation__language TEXT,
  max_delay NUMERIC,
  punctuation_sensitivity NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id,
    r.title,
    r.mosque_id,
    r.transcription_language,
    r.translation__language,
    r.max_delay,
    r.punctuation_sensitivity
  FROM public.rooms r
  WHERE r.id = room_id_param
    AND r.public_access_enabled = true;
END;
$$;

-- Grant execute permission for anonymous users to check public rooms
GRANT EXECUTE ON FUNCTION public.get_public_room_info(INTEGER) TO anon;

-- Ensure RLS is enabled on rooms table
ALTER TABLE public.rooms ENABLE ROW LEVEL SECURITY;


================================================
FILE: .claude/settings.local.json
================================================
{
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(rm:*)",
      "Bash(npx supabase:*)",
      "mcp__sequential-thinking__sequentialthinking"
    ],
    "deny": []
  }
}

